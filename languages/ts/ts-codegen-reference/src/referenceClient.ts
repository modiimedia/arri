// This file was autogenerated by @arrirpc/codegen-ts. Do not modify directly.
// For more information visit https://github.com/modiimedia/arri

/* eslint-disable */
// @ts-nocheck
import {
    ArriEnumValidator,
    ArriModelValidator,
    type EventSourceController,
    INT8_MAX,
    INT8_MIN,
    INT16_MAX,
    INT16_MIN,
    INT32_MAX,
    INT32_MIN,
    INT64_MAX,
    INT64_MIN,
    isObject,
    serializeString,
    type SseOptions,
    UINT8_MAX,
    UINT16_MAX,
    UINT32_MAX,
    UINT64_MAX,
    type Fetch,
    HeaderInput,
    TransportMap,
    InferRpcDispatcherOptions,
    RpcDispatcher,
    HttpRpcDispatcher,
    UndefinedModelValidator,
    InferRpcDispatcherEventStreamOptions,
} from '@arrirpc/client';

type HeaderMap = Record<string, string | undefined>;

export class ExampleClient<
    THttp extends RpcDispatcher = HttpRpcDispatcher,
    TDispatchers extends TransportMap = {},
> {
    private readonly _onError?: (err: unknown) => void;
    private readonly _headers?: HeaderInput;
    private readonly _http: THttp;
    private readonly _customTransports: TDispatchers;
    books: ExampleClientBooksService<THttp, TDispatchers>;
    constructor(
        config: {
            baseUrl?: string;
            fetch?: Fetch;
            headers?: HeaderInput;
            onError?: (err: unknown) => void;
            options?: InferRpcDispatcherOptions<THttp>;
            /**
             * Override the default HTTP transport dispatcher
             */
            http?: THttp;
            /**
             * Add a custom transport dispatcher
             */
            customTransports?: TDispatchers;
        } = {},
    ) {
        this._onError = config.onError;
        this._headers = config.headers;
        this._http =
            config.http ??
            (new HttpRpcDispatcher({
                baseUrl: config.baseUrl ?? '',
                fetch: config.fetch,
                options: config.options,
            }) as any);
        this._customTransports =
            config.customTransports ?? ({} as TDispatchers);
        this.books = new ExampleClientBooksService(config);
    }

    async sendObject(
        params: NestedObject,
        options?: InferRpcDispatcherOptions<THttp>,
    ): Promise<NestedObject> {
        return this._http.handleRpc<NestedObject, NestedObject>(
            {
                procedure: 'sendObject',
                path: '/send-object',
                method: 'post',
                clientVersion: '20',
                data: params,
                customHeaders: this._headers,
            },
            {
                params: $$NestedObject,
                response: $$NestedObject,
                onError: this._onError,
            },
            options,
        );
    }
}

export class ExampleClientBooksService<
    THttp extends RpcDispatcher = HttpRpcDispatcher,
    TDispatchers extends TransportMap = {},
> {
    private readonly _onError?: (err: unknown) => void;
    private readonly _headers?: HeaderInput;
    private readonly _http: THttp;
    private readonly _transports: TDispatchers;
    constructor(
        config: {
            baseUrl?: string;
            fetch?: Fetch;
            headers?: HeaderInput;
            onError?: (err: unknown) => void;
            options?: InferRpcDispatcherOptions<THttp>;
            http?: THttp;
            transports?: TDispatchers;
        } = {},
    ) {
        this._onError = config.onError;
        this._headers = config.headers;
        this._http =
            config.http ??
            (new HttpRpcDispatcher({
                baseUrl: config.baseUrl ?? '',
                fetch: config.fetch,
                options: config.options,
            }) as any);
        this._transports = config.transports ?? ({} as TDispatchers);
    }
    /**
     * Get a book
     */
    async getBook(
        params: BookParams,
        options?: InferRpcDispatcherOptions<THttp>,
    ): Promise<Book> {
        return this._http.handleRpc<BookParams, Book>(
            {
                procedure: 'books.getBook',
                path: '/books/get-book',
                method: 'get',
                clientVersion: '20',
                data: params,
                customHeaders: this._headers,
            },
            {
                params: $$BookParams,
                response: $$Book,
                onError: this._onError,
            },
            options,
        );
    }
    /**
     * Create a book
     * @deprecated
     */
    async createBook(
        params: Book,
        options?: InferRpcDispatcherOptions<THttp>,
    ): Promise<Book> {
        return this._http.handleRpc<Book, Book>(
            {
                procedure: 'books.createBook',
                path: '/books/create-book',
                method: 'post',
                clientVersion: '20',
                data: params,
                customHeaders: this._headers,
            },
            {
                params: $$Book,
                response: $$Book,
                onError: this._onError,
            },
            options,
        );
    }
    /**
     * @deprecated
     */
    watchBook(
        params: BookParams,
        options: InferRpcDispatcherEventStreamOptions<THttp> = {},
    ): EventSourceController {
        return this._http.handleEventStreamRpc<BookParams, Book>(
            {
                procedure: 'books.watchBook',
                path: '/books/watch-book',
                method: 'get',
                clientVersion: '20',
                data: params,
                customHeaders: this._headers,
            },
            {
                params: $$BookParams,
                response: $$Book,
                onError: this._onError,
            },
            options,
        );
    }
}

export interface EmptyObject {}
export const $$EmptyObject: ArriModelValidator<EmptyObject> = {
    new(): EmptyObject {
        return {};
    },
    validate(input): input is EmptyObject {
        return isObject(input);
    },
    fromJson(input): EmptyObject {
        return {};
    },
    fromJsonString(input): EmptyObject {
        return $$EmptyObject.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        let _hasKey = false;
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        return queryParts.join('&');
    },
};

/**
 * This is a book
 */
export interface Book {
    /**
     * The book ID
     */
    id: string;
    /**
     * The book title
     */
    name: string;
    /**
     * When the book was created
     * @deprecated
     */
    createdAt: Date;
    /**
     * @deprecated
     */
    updatedAt: Date;
}
export const $$Book: ArriModelValidator<Book> = {
    new(): Book {
        return {
            id: '',
            name: '',
            createdAt: new Date(),
            updatedAt: new Date(),
        };
    },
    validate(input): input is Book {
        return (
            isObject(input) &&
            typeof input.id === 'string' &&
            typeof input.name === 'string' &&
            input.createdAt instanceof Date &&
            input.updatedAt instanceof Date
        );
    },
    fromJson(input): Book {
        let _id: string;
        if (typeof input.id === 'string') {
            _id = input.id;
        } else {
            _id = '';
        }
        let _name: string;
        if (typeof input.name === 'string') {
            _name = input.name;
        } else {
            _name = '';
        }
        let _createdAt: Date;
        if (typeof input.createdAt === 'string') {
            _createdAt = new Date(input.createdAt);
        } else if (input.createdAt instanceof Date) {
            _createdAt = input.createdAt;
        } else {
            _createdAt = new Date();
        }
        let _updatedAt: Date;
        if (typeof input.updatedAt === 'string') {
            _updatedAt = new Date(input.updatedAt);
        } else if (input.updatedAt instanceof Date) {
            _updatedAt = input.updatedAt;
        } else {
            _updatedAt = new Date();
        }
        return {
            id: _id,
            name: _name,
            createdAt: _createdAt,
            updatedAt: _updatedAt,
        };
    },
    fromJsonString(input): Book {
        return $$Book.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"id":';
        json += serializeString(input.id);
        json += ',"name":';
        json += serializeString(input.name);
        json += ',"createdAt":';
        json += `"${input.createdAt.toISOString()}"`;
        json += ',"updatedAt":';
        json += `"${input.updatedAt.toISOString()}"`;
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`id=${input.id}`);
        queryParts.push(`name=${input.name}`);
        queryParts.push(`createdAt=${input.createdAt.toISOString()}`);
        queryParts.push(`updatedAt=${input.updatedAt.toISOString()}`);
        return queryParts.join('&');
    },
};

export interface BookParams {
    bookId: string;
}
export const $$BookParams: ArriModelValidator<BookParams> = {
    new(): BookParams {
        return {
            bookId: '',
        };
    },
    validate(input): input is BookParams {
        return isObject(input) && typeof input.bookId === 'string';
    },
    fromJson(input): BookParams {
        let _bookId: string;
        if (typeof input.bookId === 'string') {
            _bookId = input.bookId;
        } else {
            _bookId = '';
        }
        return {
            bookId: _bookId,
        };
    },
    fromJsonString(input): BookParams {
        return $$BookParams.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"bookId":';
        json += serializeString(input.bookId);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`bookId=${input.bookId}`);
        return queryParts.join('&');
    },
};

export interface NestedObject {
    id: string;
    content: string;
}
export const $$NestedObject: ArriModelValidator<NestedObject> = {
    new(): NestedObject {
        return {
            id: '',
            content: '',
        };
    },
    validate(input): input is NestedObject {
        return (
            isObject(input) &&
            typeof input.id === 'string' &&
            typeof input.content === 'string'
        );
    },
    fromJson(input): NestedObject {
        let _id: string;
        if (typeof input.id === 'string') {
            _id = input.id;
        } else {
            _id = '';
        }
        let _content: string;
        if (typeof input.content === 'string') {
            _content = input.content;
        } else {
            _content = '';
        }
        return {
            id: _id,
            content: _content,
        };
    },
    fromJsonString(input): NestedObject {
        return $$NestedObject.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"id":';
        json += serializeString(input.id);
        json += ',"content":';
        json += serializeString(input.content);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`id=${input.id}`);
        queryParts.push(`content=${input.content}`);
        return queryParts.join('&');
    },
};

export interface ObjectWithEveryType {
    string: string;
    boolean: boolean;
    timestamp: Date;
    float32: number;
    float64: number;
    int8: number;
    uint8: number;
    int16: number;
    uint16: number;
    int32: number;
    uint32: number;
    int64: bigint;
    uint64: bigint;
    enum: Enumerator;
    object: NestedObject;
    array: boolean[];
    record: Record<string, boolean>;
    discriminator: Discriminator;
    any: any;
}
export const $$ObjectWithEveryType: ArriModelValidator<ObjectWithEveryType> = {
    new(): ObjectWithEveryType {
        return {
            string: '',
            boolean: false,
            timestamp: new Date(),
            float32: 0,
            float64: 0,
            int8: 0,
            uint8: 0,
            int16: 0,
            uint16: 0,
            int32: 0,
            uint32: 0,
            int64: BigInt(0),
            uint64: BigInt(0),
            enum: $$Enumerator.new(),
            object: $$NestedObject.new(),
            array: [],
            record: {},
            discriminator: $$Discriminator.new(),
            any: undefined,
        };
    },
    validate(input): input is ObjectWithEveryType {
        return (
            isObject(input) &&
            typeof input.string === 'string' &&
            typeof input.boolean === 'boolean' &&
            input.timestamp instanceof Date &&
            typeof input.float32 === 'number' &&
            typeof input.float64 === 'number' &&
            typeof input.int8 === 'number' &&
            Number.isInteger(input.int8) &&
            input.int8 >= INT8_MIN &&
            input.int8 <= INT8_MAX &&
            typeof input.uint8 === 'number' &&
            Number.isInteger(input.uint8) &&
            input.uint8 >= 0 &&
            input.uint8 <= UINT8_MAX &&
            typeof input.int16 === 'number' &&
            Number.isInteger(input.int16) &&
            input.int16 >= INT16_MIN &&
            input.int16 <= INT16_MAX &&
            typeof input.uint16 === 'number' &&
            Number.isInteger(input.uint16) &&
            input.uint16 >= 0 &&
            input.uint16 <= UINT16_MAX &&
            typeof input.int32 === 'number' &&
            Number.isInteger(input.int32) &&
            input.int32 >= INT32_MIN &&
            input.int32 <= INT32_MAX &&
            typeof input.uint32 === 'number' &&
            Number.isInteger(input.uint32) &&
            input.uint32 >= 0 &&
            input.uint32 <= UINT32_MAX &&
            typeof input.int64 === 'bigint' &&
            input.int64 >= INT64_MIN &&
            input.int64 <= INT64_MAX &&
            typeof input.uint64 === 'bigint' &&
            input.uint64 >= BigInt(0) &&
            input.uint64 <= UINT64_MAX &&
            $$Enumerator.validate(input.enum) &&
            $$NestedObject.validate(input.object) &&
            Array.isArray(input.array) &&
            input.array.every((_element) => typeof _element === 'boolean') &&
            isObject(input.record) &&
            Object.values(input.record).every(
                (_value) => typeof _value === 'boolean',
            ) &&
            $$Discriminator.validate(input.discriminator) &&
            true
        );
    },
    fromJson(input): ObjectWithEveryType {
        let _string: string;
        if (typeof input.string === 'string') {
            _string = input.string;
        } else {
            _string = '';
        }
        let _boolean: boolean;
        if (typeof input.boolean === 'boolean') {
            _boolean = input.boolean;
        } else {
            _boolean = false;
        }
        let _timestamp: Date;
        if (typeof input.timestamp === 'string') {
            _timestamp = new Date(input.timestamp);
        } else if (input.timestamp instanceof Date) {
            _timestamp = input.timestamp;
        } else {
            _timestamp = new Date();
        }
        let _float32: number;
        if (typeof input.float32 === 'number') {
            _float32 = input.float32;
        } else {
            _float32 = 0;
        }
        let _float64: number;
        if (typeof input.float64 === 'number') {
            _float64 = input.float64;
        } else {
            _float64 = 0;
        }
        let _int8: number;
        if (
            typeof input.int8 === 'number' &&
            Number.isInteger(input.int8) &&
            input.int8 >= INT8_MIN &&
            input.int8 <= INT8_MAX
        ) {
            _int8 = input.int8;
        } else {
            _int8 = 0;
        }
        let _uint8: number;
        if (
            typeof input.uint8 === 'number' &&
            Number.isInteger(input.uint8) &&
            input.uint8 >= 0 &&
            input.uint8 <= UINT8_MAX
        ) {
            _uint8 = input.uint8;
        } else {
            _uint8 = 0;
        }
        let _int16: number;
        if (
            typeof input.int16 === 'number' &&
            Number.isInteger(input.int16) &&
            input.int16 >= INT16_MIN &&
            input.int16 <= INT16_MAX
        ) {
            _int16 = input.int16;
        } else {
            _int16 = 0;
        }
        let _uint16: number;
        if (
            typeof input.uint16 === 'number' &&
            Number.isInteger(input.uint16) &&
            input.uint16 >= 0 &&
            input.uint16 <= UINT16_MAX
        ) {
            _uint16 = input.uint16;
        } else {
            _uint16 = 0;
        }
        let _int32: number;
        if (
            typeof input.int32 === 'number' &&
            Number.isInteger(input.int32) &&
            input.int32 >= INT32_MIN &&
            input.int32 <= INT32_MAX
        ) {
            _int32 = input.int32;
        } else {
            _int32 = 0;
        }
        let _uint32: number;
        if (
            typeof input.uint32 === 'number' &&
            Number.isInteger(input.uint32) &&
            input.uint32 >= 0 &&
            input.uint32 <= UINT32_MAX
        ) {
            _uint32 = input.uint32;
        } else {
            _uint32 = 0;
        }
        let _int64: bigint;
        if (typeof input.int64 === 'string') {
            _int64 = BigInt(input.int64);
        } else if (typeof input.int64 === 'bigint') {
            _int64 = input.int64;
        } else {
            _int64 = BigInt(0);
        }
        let _uint64: bigint;
        if (
            typeof input.uint64 === 'string' &&
            BigInt(input.uint64) >= BigInt(0)
        ) {
            _uint64 = BigInt(input.uint64);
        } else if (
            typeof input.uint64 === 'bigint' &&
            input.uint64 >= BigInt(0)
        ) {
            _uint64 = input.uint64;
        } else {
            _uint64 = BigInt(0);
        }
        let _enum: Enumerator;
        if (typeof input.enum === 'string') {
            _enum = $$Enumerator.fromSerialValue(input.enum);
        } else {
            _enum = $$Enumerator.new();
        }
        let _object: NestedObject;
        if (isObject(input.object)) {
            _object = $$NestedObject.fromJson(input.object);
        } else {
            _object = $$NestedObject.new();
        }
        let _array: boolean[];
        if (Array.isArray(input.array)) {
            _array = [];
            for (const _arrayEl of input.array) {
                let _arrayElValue: boolean;
                if (typeof _arrayEl === 'boolean') {
                    _arrayElValue = _arrayEl;
                } else {
                    _arrayElValue = false;
                }
                _array.push(_arrayElValue);
            }
        } else {
            _array = [];
        }
        let _record: Record<string, boolean>;
        if (isObject(input.record)) {
            _record = {};
            for (const [_key, _value] of Object.entries(input.record)) {
                let _recordValue: boolean;
                if (typeof _value === 'boolean') {
                    _recordValue = _value;
                } else {
                    _recordValue = false;
                }
                _record[_key] = _recordValue;
            }
        } else {
            _record = {};
        }
        let _discriminator: Discriminator;
        if (isObject(input.discriminator)) {
            _discriminator = $$Discriminator.fromJson(input.discriminator);
        } else {
            _discriminator = $$Discriminator.new();
        }
        let _any: any;
        _any = input.any;
        return {
            string: _string,
            boolean: _boolean,
            timestamp: _timestamp,
            float32: _float32,
            float64: _float64,
            int8: _int8,
            uint8: _uint8,
            int16: _int16,
            uint16: _uint16,
            int32: _int32,
            uint32: _uint32,
            int64: _int64,
            uint64: _uint64,
            enum: _enum,
            object: _object,
            array: _array,
            record: _record,
            discriminator: _discriminator,
            any: _any,
        };
    },
    fromJsonString(input): ObjectWithEveryType {
        return $$ObjectWithEveryType.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"string":';
        json += serializeString(input.string);
        json += ',"boolean":';
        json += `${input.boolean}`;
        json += ',"timestamp":';
        json += `"${input.timestamp.toISOString()}"`;
        json += ',"float32":';
        json += `${input.float32}`;
        json += ',"float64":';
        json += `${input.float64}`;
        json += ',"int8":';
        json += `${input.int8}`;
        json += ',"uint8":';
        json += `${input.uint8}`;
        json += ',"int16":';
        json += `${input.int16}`;
        json += ',"uint16":';
        json += `${input.uint16}`;
        json += ',"int32":';
        json += `${input.int32}`;
        json += ',"uint32":';
        json += `${input.uint32}`;
        json += ',"int64":';
        json += `"${input.int64}"`;
        json += ',"uint64":';
        json += `"${input.uint64}"`;
        json += ',"enum":';
        json += `"${input.enum}"`;
        json += ',"object":';
        json += $$NestedObject.toJsonString(input.object);
        json += ',"array":';
        json += '[';
        for (let i = 0; i < input.array.length; i++) {
            if (i !== 0) json += ',';
            const _inputArrayEl = input.array[i];
            json += `${_inputArrayEl}`;
        }
        json += ']';
        json += ',"record":';
        json += '{';
        let _recordPropertyCount = 0;
        for (const [_key, _value] of Object.entries(input.record)) {
            if (_recordPropertyCount !== 0) {
                json += ',';
            }
            json += `${serializeString(_key)}:`;
            json += `${_value}`;
            _recordPropertyCount++;
        }
        json += '}';
        json += ',"discriminator":';
        json += $$Discriminator.toJsonString(input.discriminator);
        json += ',"any":';
        json += JSON.stringify(input.any);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`string=${input.string}`);
        queryParts.push(`boolean=${input.boolean}`);
        queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
        queryParts.push(`float32=${input.float32}`);
        queryParts.push(`float64=${input.float64}`);
        queryParts.push(`int8=${input.int8}`);
        queryParts.push(`uint8=${input.uint8}`);
        queryParts.push(`int16=${input.int16}`);
        queryParts.push(`uint16=${input.uint16}`);
        queryParts.push(`int32=${input.int32}`);
        queryParts.push(`uint32=${input.uint32}`);
        queryParts.push(`int64=${input.int64}`);
        queryParts.push(`uint64=${input.uint64}`);
        queryParts.push(`enum=${input.enum}`);
        console.warn(
            '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryType/object.',
        );
        console.warn(
            '[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryType/array.',
        );
        console.warn(
            '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryType/record.',
        );
        console.warn(
            '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryType/discriminator.',
        );
        console.warn(
            "[WARNING] Cannot serialize any's to query string. Skipping property at /ObjectWithEveryType/any.",
        );
        return queryParts.join('&');
    },
};

export type Enumerator = (typeof $$EnumeratorValues)[number];
const $$EnumeratorValues = ['FOO', 'BAR', 'BAZ'] as const;
export const $$Enumerator: ArriEnumValidator<Enumerator> = {
    new(): Enumerator {
        return $$EnumeratorValues[0];
    },
    validate(input): input is Enumerator {
        return (
            typeof input === 'string' &&
            $$EnumeratorValues.includes(input as any)
        );
    },
    values: $$EnumeratorValues,
    fromSerialValue(input): Enumerator {
        if ($$EnumeratorValues.includes(input as any)) {
            return input as Enumerator;
        }
        if ($$EnumeratorValues.includes(input.toLowerCase() as any)) {
            return input.toLowerCase() as Enumerator;
        }
        if ($$EnumeratorValues.includes(input.toUpperCase() as any)) {
            return input.toUpperCase() as Enumerator;
        }
        return 'FOO';
    },
};

export type Discriminator = DiscriminatorA | DiscriminatorB | DiscriminatorC;
export const $$Discriminator: ArriModelValidator<Discriminator> = {
    new(): Discriminator {
        return $$DiscriminatorA.new();
    },
    validate(input): input is Discriminator {
        if (!isObject(input)) {
            return false;
        }
        if (typeof input.typeName !== 'string') {
            return false;
        }
        switch (input.typeName) {
            case 'A':
                return $$DiscriminatorA.validate(input);
            case 'B':
                return $$DiscriminatorB.validate(input);
            case 'C':
                return $$DiscriminatorC.validate(input);
            default:
                return false;
        }
    },
    fromJson(input): Discriminator {
        switch (input.typeName) {
            case 'A':
                return $$DiscriminatorA.fromJson(input);
            case 'B':
                return $$DiscriminatorB.fromJson(input);
            case 'C':
                return $$DiscriminatorC.fromJson(input);
            default:
                return $$DiscriminatorA.new();
        }
    },
    fromJsonString(input): Discriminator {
        return $$Discriminator.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        switch (input.typeName) {
            case 'A':
                return $$DiscriminatorA.toJsonString(input);
            case 'B':
                return $$DiscriminatorB.toJsonString(input);
            case 'C':
                return $$DiscriminatorC.toJsonString(input);
            default:
                throw new Error(`Unhandled case "${(input as any).typeName}"`);
        }
    },
    toUrlQueryString(input): string {
        switch (input.typeName) {
            case 'A':
                return $$DiscriminatorA.toUrlQueryString(input);
            case 'B':
                return $$DiscriminatorB.toUrlQueryString(input);
            case 'C':
                return $$DiscriminatorC.toUrlQueryString(input);
            default:
                throw new Error('Unhandled case');
        }
    },
};
export interface DiscriminatorA {
    typeName: 'A';
    id: string;
}
const $$DiscriminatorA: ArriModelValidator<DiscriminatorA> = {
    new(): DiscriminatorA {
        return {
            typeName: 'A',
            id: '',
        };
    },
    validate(input): input is DiscriminatorA {
        return (
            isObject(input) &&
            input.typeName === 'A' &&
            typeof input.id === 'string'
        );
    },
    fromJson(input): DiscriminatorA {
        const _typeName = 'A';
        let _id: string;
        if (typeof input.id === 'string') {
            _id = input.id;
        } else {
            _id = '';
        }
        return {
            typeName: _typeName,
            id: _id,
        };
    },
    fromJsonString(input): DiscriminatorA {
        return $$DiscriminatorA.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"typeName":"A"';
        json += ',"id":';
        json += serializeString(input.id);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push('typeName=A');
        queryParts.push(`id=${input.id}`);
        return queryParts.join('&');
    },
};
export interface DiscriminatorB {
    typeName: 'B';
    id: string;
    name: string;
}
const $$DiscriminatorB: ArriModelValidator<DiscriminatorB> = {
    new(): DiscriminatorB {
        return {
            typeName: 'B',
            id: '',
            name: '',
        };
    },
    validate(input): input is DiscriminatorB {
        return (
            isObject(input) &&
            input.typeName === 'B' &&
            typeof input.id === 'string' &&
            typeof input.name === 'string'
        );
    },
    fromJson(input): DiscriminatorB {
        const _typeName = 'B';
        let _id: string;
        if (typeof input.id === 'string') {
            _id = input.id;
        } else {
            _id = '';
        }
        let _name: string;
        if (typeof input.name === 'string') {
            _name = input.name;
        } else {
            _name = '';
        }
        return {
            typeName: _typeName,
            id: _id,
            name: _name,
        };
    },
    fromJsonString(input): DiscriminatorB {
        return $$DiscriminatorB.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"typeName":"B"';
        json += ',"id":';
        json += serializeString(input.id);
        json += ',"name":';
        json += serializeString(input.name);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push('typeName=B');
        queryParts.push(`id=${input.id}`);
        queryParts.push(`name=${input.name}`);
        return queryParts.join('&');
    },
};
export interface DiscriminatorC {
    typeName: 'C';
    id: string;
    name: string;
    date: Date;
}
const $$DiscriminatorC: ArriModelValidator<DiscriminatorC> = {
    new(): DiscriminatorC {
        return {
            typeName: 'C',
            id: '',
            name: '',
            date: new Date(),
        };
    },
    validate(input): input is DiscriminatorC {
        return (
            isObject(input) &&
            input.typeName === 'C' &&
            typeof input.id === 'string' &&
            typeof input.name === 'string' &&
            input.date instanceof Date
        );
    },
    fromJson(input): DiscriminatorC {
        const _typeName = 'C';
        let _id: string;
        if (typeof input.id === 'string') {
            _id = input.id;
        } else {
            _id = '';
        }
        let _name: string;
        if (typeof input.name === 'string') {
            _name = input.name;
        } else {
            _name = '';
        }
        let _date: Date;
        if (typeof input.date === 'string') {
            _date = new Date(input.date);
        } else if (input.date instanceof Date) {
            _date = input.date;
        } else {
            _date = new Date();
        }
        return {
            typeName: _typeName,
            id: _id,
            name: _name,
            date: _date,
        };
    },
    fromJsonString(input): DiscriminatorC {
        return $$DiscriminatorC.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"typeName":"C"';
        json += ',"id":';
        json += serializeString(input.id);
        json += ',"name":';
        json += serializeString(input.name);
        json += ',"date":';
        json += `"${input.date.toISOString()}"`;
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push('typeName=C');
        queryParts.push(`id=${input.id}`);
        queryParts.push(`name=${input.name}`);
        queryParts.push(`date=${input.date.toISOString()}`);
        return queryParts.join('&');
    },
};

export interface ObjectWithOptionalFields {
    string?: string;
    boolean?: boolean;
    timestamp?: Date;
    float32?: number;
    float64?: number;
    int8?: number;
    uint8?: number;
    int16?: number;
    uint16?: number;
    int32?: number;
    uint32?: number;
    int64?: bigint;
    uint64?: bigint;
    enum?: Enumerator;
    object?: NestedObject;
    array?: boolean[];
    record?: Record<string, boolean>;
    discriminator?: Discriminator;
    any?: any;
}
export const $$ObjectWithOptionalFields: ArriModelValidator<ObjectWithOptionalFields> =
    {
        new(): ObjectWithOptionalFields {
            return {};
        },
        validate(input): input is ObjectWithOptionalFields {
            return (
                isObject(input) &&
                (typeof input.string === 'string' ||
                    typeof input.string === 'undefined') &&
                (typeof input.boolean === 'boolean' ||
                    typeof input.boolean === 'undefined') &&
                (input.timestamp instanceof Date ||
                    typeof input.timestamp === 'undefined') &&
                (typeof input.float32 === 'number' ||
                    typeof input.float32 === 'undefined') &&
                (typeof input.float64 === 'number' ||
                    typeof input.float64 === 'undefined') &&
                ((typeof input.int8 === 'number' &&
                    Number.isInteger(input.int8) &&
                    input.int8 >= INT8_MIN &&
                    input.int8 <= INT8_MAX) ||
                    typeof input.int8 === 'undefined') &&
                ((typeof input.uint8 === 'number' &&
                    Number.isInteger(input.uint8) &&
                    input.uint8 >= 0 &&
                    input.uint8 <= UINT8_MAX) ||
                    typeof input.uint8 === 'undefined') &&
                ((typeof input.int16 === 'number' &&
                    Number.isInteger(input.int16) &&
                    input.int16 >= INT16_MIN &&
                    input.int16 <= INT16_MAX) ||
                    typeof input.int16 === 'undefined') &&
                ((typeof input.uint16 === 'number' &&
                    Number.isInteger(input.uint16) &&
                    input.uint16 >= 0 &&
                    input.uint16 <= UINT16_MAX) ||
                    typeof input.uint16 === 'undefined') &&
                ((typeof input.int32 === 'number' &&
                    Number.isInteger(input.int32) &&
                    input.int32 >= INT32_MIN &&
                    input.int32 <= INT32_MAX) ||
                    typeof input.int32 === 'undefined') &&
                ((typeof input.uint32 === 'number' &&
                    Number.isInteger(input.uint32) &&
                    input.uint32 >= 0 &&
                    input.uint32 <= UINT32_MAX) ||
                    typeof input.uint32 === 'undefined') &&
                ((typeof input.int64 === 'bigint' &&
                    input.int64 >= INT64_MIN &&
                    input.int64 <= INT64_MAX) ||
                    typeof input.int64 === 'undefined') &&
                ((typeof input.uint64 === 'bigint' &&
                    input.uint64 >= BigInt(0) &&
                    input.uint64 <= UINT64_MAX) ||
                    typeof input.uint64 === 'undefined') &&
                ($$Enumerator.validate(input.enum) ||
                    typeof input.enum === 'undefined') &&
                ($$NestedObject.validate(input.object) ||
                    typeof input.object === 'undefined') &&
                ((Array.isArray(input.array) &&
                    input.array.every(
                        (_element) => typeof _element === 'boolean',
                    )) ||
                    typeof input.array === 'undefined') &&
                ((isObject(input.record) &&
                    Object.values(input.record).every(
                        (_value) => typeof _value === 'boolean',
                    )) ||
                    typeof input.record === 'undefined') &&
                ($$Discriminator.validate(input.discriminator) ||
                    typeof input.discriminator === 'undefined') &&
                (true || typeof input.any === 'undefined')
            );
        },
        fromJson(input): ObjectWithOptionalFields {
            let _string: string | undefined;
            if (typeof input.string !== 'undefined') {
                if (typeof input.string === 'string') {
                    _string = input.string;
                } else {
                    _string = '';
                }
            }
            let _boolean: boolean | undefined;
            if (typeof input.boolean !== 'undefined') {
                if (typeof input.boolean === 'boolean') {
                    _boolean = input.boolean;
                } else {
                    _boolean = false;
                }
            }
            let _timestamp: Date | undefined;
            if (typeof input.timestamp !== 'undefined') {
                if (typeof input.timestamp === 'string') {
                    _timestamp = new Date(input.timestamp);
                } else if (input.timestamp instanceof Date) {
                    _timestamp = input.timestamp;
                } else {
                    _timestamp = new Date();
                }
            }
            let _float32: number | undefined;
            if (typeof input.float32 !== 'undefined') {
                if (typeof input.float32 === 'number') {
                    _float32 = input.float32;
                } else {
                    _float32 = 0;
                }
            }
            let _float64: number | undefined;
            if (typeof input.float64 !== 'undefined') {
                if (typeof input.float64 === 'number') {
                    _float64 = input.float64;
                } else {
                    _float64 = 0;
                }
            }
            let _int8: number | undefined;
            if (typeof input.int8 !== 'undefined') {
                if (
                    typeof input.int8 === 'number' &&
                    Number.isInteger(input.int8) &&
                    input.int8 >= INT8_MIN &&
                    input.int8 <= INT8_MAX
                ) {
                    _int8 = input.int8;
                } else {
                    _int8 = 0;
                }
            }
            let _uint8: number | undefined;
            if (typeof input.uint8 !== 'undefined') {
                if (
                    typeof input.uint8 === 'number' &&
                    Number.isInteger(input.uint8) &&
                    input.uint8 >= 0 &&
                    input.uint8 <= UINT8_MAX
                ) {
                    _uint8 = input.uint8;
                } else {
                    _uint8 = 0;
                }
            }
            let _int16: number | undefined;
            if (typeof input.int16 !== 'undefined') {
                if (
                    typeof input.int16 === 'number' &&
                    Number.isInteger(input.int16) &&
                    input.int16 >= INT16_MIN &&
                    input.int16 <= INT16_MAX
                ) {
                    _int16 = input.int16;
                } else {
                    _int16 = 0;
                }
            }
            let _uint16: number | undefined;
            if (typeof input.uint16 !== 'undefined') {
                if (
                    typeof input.uint16 === 'number' &&
                    Number.isInteger(input.uint16) &&
                    input.uint16 >= 0 &&
                    input.uint16 <= UINT16_MAX
                ) {
                    _uint16 = input.uint16;
                } else {
                    _uint16 = 0;
                }
            }
            let _int32: number | undefined;
            if (typeof input.int32 !== 'undefined') {
                if (
                    typeof input.int32 === 'number' &&
                    Number.isInteger(input.int32) &&
                    input.int32 >= INT32_MIN &&
                    input.int32 <= INT32_MAX
                ) {
                    _int32 = input.int32;
                } else {
                    _int32 = 0;
                }
            }
            let _uint32: number | undefined;
            if (typeof input.uint32 !== 'undefined') {
                if (
                    typeof input.uint32 === 'number' &&
                    Number.isInteger(input.uint32) &&
                    input.uint32 >= 0 &&
                    input.uint32 <= UINT32_MAX
                ) {
                    _uint32 = input.uint32;
                } else {
                    _uint32 = 0;
                }
            }
            let _int64: bigint | undefined;
            if (typeof input.int64 !== 'undefined') {
                if (typeof input.int64 === 'string') {
                    _int64 = BigInt(input.int64);
                } else if (typeof input.int64 === 'bigint') {
                    _int64 = input.int64;
                } else {
                    _int64 = BigInt(0);
                }
            }
            let _uint64: bigint | undefined;
            if (typeof input.uint64 !== 'undefined') {
                if (
                    typeof input.uint64 === 'string' &&
                    BigInt(input.uint64) >= BigInt(0)
                ) {
                    _uint64 = BigInt(input.uint64);
                } else if (
                    typeof input.uint64 === 'bigint' &&
                    input.uint64 >= BigInt(0)
                ) {
                    _uint64 = input.uint64;
                } else {
                    _uint64 = BigInt(0);
                }
            }
            let _enum: Enumerator | undefined;
            if (typeof input.enum !== 'undefined') {
                if (typeof input.enum === 'string') {
                    _enum = $$Enumerator.fromSerialValue(input.enum);
                } else {
                    _enum = $$Enumerator.new();
                }
            }
            let _object: NestedObject | undefined;
            if (typeof input.object !== 'undefined') {
                if (isObject(input.object)) {
                    _object = $$NestedObject.fromJson(input.object);
                } else {
                    _object = $$NestedObject.new();
                }
            }
            let _array: boolean[] | undefined;
            if (typeof input.array !== 'undefined') {
                if (Array.isArray(input.array)) {
                    _array = [];
                    for (const _arrayEl of input.array) {
                        let _arrayElValue: boolean;
                        if (typeof _arrayEl === 'boolean') {
                            _arrayElValue = _arrayEl;
                        } else {
                            _arrayElValue = false;
                        }
                        _array.push(_arrayElValue);
                    }
                } else {
                    _array = [];
                }
            }
            let _record: Record<string, boolean> | undefined;
            if (typeof input.record !== 'undefined') {
                if (isObject(input.record)) {
                    _record = {};
                    for (const [_key, _value] of Object.entries(input.record)) {
                        let _recordValue: boolean;
                        if (typeof _value === 'boolean') {
                            _recordValue = _value;
                        } else {
                            _recordValue = false;
                        }
                        _record[_key] = _recordValue;
                    }
                } else {
                    _record = {};
                }
            }
            let _discriminator: Discriminator | undefined;
            if (typeof input.discriminator !== 'undefined') {
                if (isObject(input.discriminator)) {
                    _discriminator = $$Discriminator.fromJson(
                        input.discriminator,
                    );
                } else {
                    _discriminator = $$Discriminator.new();
                }
            }
            let _any: any | undefined;
            if (typeof input.any !== 'undefined') {
                _any = input.any;
            }
            return {
                string: _string,
                boolean: _boolean,
                timestamp: _timestamp,
                float32: _float32,
                float64: _float64,
                int8: _int8,
                uint8: _uint8,
                int16: _int16,
                uint16: _uint16,
                int32: _int32,
                uint32: _uint32,
                int64: _int64,
                uint64: _uint64,
                enum: _enum,
                object: _object,
                array: _array,
                record: _record,
                discriminator: _discriminator,
                any: _any,
            };
        },
        fromJsonString(input): ObjectWithOptionalFields {
            return $$ObjectWithOptionalFields.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            let _hasKey = false;
            if (typeof input.string !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"string":';
                json += serializeString(input.string);
                _hasKey = true;
            }
            if (typeof input.boolean !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"boolean":';
                json += `${input.boolean}`;
                _hasKey = true;
            }
            if (typeof input.timestamp !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"timestamp":';
                json += `"${input.timestamp.toISOString()}"`;
                _hasKey = true;
            }
            if (typeof input.float32 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"float32":';
                json += `${input.float32}`;
                _hasKey = true;
            }
            if (typeof input.float64 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"float64":';
                json += `${input.float64}`;
                _hasKey = true;
            }
            if (typeof input.int8 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"int8":';
                json += `${input.int8}`;
                _hasKey = true;
            }
            if (typeof input.uint8 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"uint8":';
                json += `${input.uint8}`;
                _hasKey = true;
            }
            if (typeof input.int16 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"int16":';
                json += `${input.int16}`;
                _hasKey = true;
            }
            if (typeof input.uint16 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"uint16":';
                json += `${input.uint16}`;
                _hasKey = true;
            }
            if (typeof input.int32 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"int32":';
                json += `${input.int32}`;
                _hasKey = true;
            }
            if (typeof input.uint32 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"uint32":';
                json += `${input.uint32}`;
                _hasKey = true;
            }
            if (typeof input.int64 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"int64":';
                json += `"${input.int64}"`;
                _hasKey = true;
            }
            if (typeof input.uint64 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"uint64":';
                json += `"${input.uint64}"`;
                _hasKey = true;
            }
            if (typeof input.enum !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"enum":';
                json += `"${input.enum}"`;
                _hasKey = true;
            }
            if (typeof input.object !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"object":';
                json += $$NestedObject.toJsonString(input.object);
                _hasKey = true;
            }
            if (typeof input.array !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"array":';
                json += '[';
                for (let i = 0; i < input.array.length; i++) {
                    if (i !== 0) json += ',';
                    const _inputArrayEl = input.array[i];
                    json += `${_inputArrayEl}`;
                }
                json += ']';
                _hasKey = true;
            }
            if (typeof input.record !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"record":';
                json += '{';
                let _recordPropertyCount = 0;
                for (const [_key, _value] of Object.entries(input.record)) {
                    if (_recordPropertyCount !== 0) {
                        json += ',';
                    }
                    json += `${serializeString(_key)}:`;
                    json += `${_value}`;
                    _recordPropertyCount++;
                }
                json += '}';
                _hasKey = true;
            }
            if (typeof input.discriminator !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"discriminator":';
                json += $$Discriminator.toJsonString(input.discriminator);
                _hasKey = true;
            }
            if (typeof input.any !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"any":';
                json += JSON.stringify(input.any);
                _hasKey = true;
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            if (typeof input.string !== 'undefined') {
                queryParts.push(`string=${input.string}`);
            }
            if (typeof input.boolean !== 'undefined') {
                queryParts.push(`boolean=${input.boolean}`);
            }
            if (typeof input.timestamp !== 'undefined') {
                queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            }
            if (typeof input.float32 !== 'undefined') {
                queryParts.push(`float32=${input.float32}`);
            }
            if (typeof input.float64 !== 'undefined') {
                queryParts.push(`float64=${input.float64}`);
            }
            if (typeof input.int8 !== 'undefined') {
                queryParts.push(`int8=${input.int8}`);
            }
            if (typeof input.uint8 !== 'undefined') {
                queryParts.push(`uint8=${input.uint8}`);
            }
            if (typeof input.int16 !== 'undefined') {
                queryParts.push(`int16=${input.int16}`);
            }
            if (typeof input.uint16 !== 'undefined') {
                queryParts.push(`uint16=${input.uint16}`);
            }
            if (typeof input.int32 !== 'undefined') {
                queryParts.push(`int32=${input.int32}`);
            }
            if (typeof input.uint32 !== 'undefined') {
                queryParts.push(`uint32=${input.uint32}`);
            }
            if (typeof input.int64 !== 'undefined') {
                queryParts.push(`int64=${input.int64}`);
            }
            if (typeof input.uint64 !== 'undefined') {
                queryParts.push(`uint64=${input.uint64}`);
            }
            if (typeof input.enum !== 'undefined') {
                queryParts.push(`enum=${input.enum}`);
            }
            if (typeof input.object !== 'undefined') {
                console.warn(
                    '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithOptionalFields/object.',
                );
            }
            if (typeof input.array !== 'undefined') {
                console.warn(
                    '[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithOptionalFields/array.',
                );
            }
            if (typeof input.record !== 'undefined') {
                console.warn(
                    '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithOptionalFields/record.',
                );
            }
            if (typeof input.discriminator !== 'undefined') {
                console.warn(
                    '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithOptionalFields/discriminator.',
                );
            }
            if (typeof input.any !== 'undefined') {
                console.warn(
                    "[WARNING] Cannot serialize any's to query string. Skipping property at /ObjectWithOptionalFields/any.",
                );
            }
            return queryParts.join('&');
        },
    };

export interface ObjectWithNullableFields {
    string: string | null;
    boolean: boolean | null;
    timestamp: Date | null;
    float32: number | null;
    float64: number | null;
    int8: number | null;
    uint8: number | null;
    int16: number | null;
    uint16: number | null;
    int32: number | null;
    uint32: number | null;
    int64: bigint | null;
    uint64: bigint | null;
    enum: Enumerator | null;
    object: NestedObject | null;
    array: boolean[] | null;
    record: Record<string, boolean> | null;
    discriminator: Discriminator | null;
    any: any;
}
export const $$ObjectWithNullableFields: ArriModelValidator<ObjectWithNullableFields> =
    {
        new(): ObjectWithNullableFields {
            return {
                string: null,
                boolean: null,
                timestamp: null,
                float32: null,
                float64: null,
                int8: null,
                uint8: null,
                int16: null,
                uint16: null,
                int32: null,
                uint32: null,
                int64: null,
                uint64: null,
                enum: null,
                object: null,
                array: null,
                record: null,
                discriminator: null,
                any: null,
            };
        },
        validate(input): input is ObjectWithNullableFields {
            return (
                isObject(input) &&
                (typeof input.string === 'string' || input.string === null) &&
                (typeof input.boolean === 'boolean' ||
                    input.boolean === null) &&
                (input.timestamp instanceof Date || input.timestamp === null) &&
                (typeof input.float32 === 'number' || input.float32 === null) &&
                (typeof input.float64 === 'number' || input.float64 === null) &&
                ((typeof input.int8 === 'number' &&
                    Number.isInteger(input.int8) &&
                    input.int8 >= INT8_MIN &&
                    input.int8 <= INT8_MAX) ||
                    input.int8 === null) &&
                ((typeof input.uint8 === 'number' &&
                    Number.isInteger(input.uint8) &&
                    input.uint8 >= 0 &&
                    input.uint8 <= UINT8_MAX) ||
                    input.uint8 === null) &&
                ((typeof input.int16 === 'number' &&
                    Number.isInteger(input.int16) &&
                    input.int16 >= INT16_MIN &&
                    input.int16 <= INT16_MAX) ||
                    input.int16 === null) &&
                ((typeof input.uint16 === 'number' &&
                    Number.isInteger(input.uint16) &&
                    input.uint16 >= 0 &&
                    input.uint16 <= UINT16_MAX) ||
                    input.uint16 === null) &&
                ((typeof input.int32 === 'number' &&
                    Number.isInteger(input.int32) &&
                    input.int32 >= INT32_MIN &&
                    input.int32 <= INT32_MAX) ||
                    input.int32 === null) &&
                ((typeof input.uint32 === 'number' &&
                    Number.isInteger(input.uint32) &&
                    input.uint32 >= 0 &&
                    input.uint32 <= UINT32_MAX) ||
                    input.uint32 === null) &&
                ((typeof input.int64 === 'bigint' &&
                    input.int64 >= INT64_MIN &&
                    input.int64 <= INT64_MAX) ||
                    input.int64 === null) &&
                ((typeof input.uint64 === 'bigint' &&
                    input.uint64 >= BigInt(0) &&
                    input.uint64 <= UINT64_MAX) ||
                    input.uint64 === null) &&
                ($$Enumerator.validate(input.enum) || input.enum === null) &&
                ($$NestedObject.validate(input.object) ||
                    input.object === null) &&
                ((Array.isArray(input.array) &&
                    input.array.every(
                        (_element) => typeof _element === 'boolean',
                    )) ||
                    input.array === null) &&
                ((isObject(input.record) &&
                    Object.values(input.record).every(
                        (_value) => typeof _value === 'boolean',
                    )) ||
                    input.record === null) &&
                ($$Discriminator.validate(input.discriminator) ||
                    input.discriminator === null) &&
                true
            );
        },
        fromJson(input): ObjectWithNullableFields {
            let _string: string | null;
            if (typeof input.string === 'string') {
                _string = input.string;
            } else {
                _string = null;
            }
            let _boolean: boolean | null;
            if (typeof input.boolean === 'boolean') {
                _boolean = input.boolean;
            } else {
                _boolean = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            let _float32: number | null;
            if (typeof input.float32 === 'number') {
                _float32 = input.float32;
            } else {
                _float32 = null;
            }
            let _float64: number | null;
            if (typeof input.float64 === 'number') {
                _float64 = input.float64;
            } else {
                _float64 = null;
            }
            let _int8: number | null;
            if (
                typeof input.int8 === 'number' &&
                Number.isInteger(input.int8) &&
                input.int8 >= INT8_MIN &&
                input.int8 <= INT8_MAX
            ) {
                _int8 = input.int8;
            } else {
                _int8 = null;
            }
            let _uint8: number | null;
            if (
                typeof input.uint8 === 'number' &&
                Number.isInteger(input.uint8) &&
                input.uint8 >= 0 &&
                input.uint8 <= UINT8_MAX
            ) {
                _uint8 = input.uint8;
            } else {
                _uint8 = null;
            }
            let _int16: number | null;
            if (
                typeof input.int16 === 'number' &&
                Number.isInteger(input.int16) &&
                input.int16 >= INT16_MIN &&
                input.int16 <= INT16_MAX
            ) {
                _int16 = input.int16;
            } else {
                _int16 = null;
            }
            let _uint16: number | null;
            if (
                typeof input.uint16 === 'number' &&
                Number.isInteger(input.uint16) &&
                input.uint16 >= 0 &&
                input.uint16 <= UINT16_MAX
            ) {
                _uint16 = input.uint16;
            } else {
                _uint16 = null;
            }
            let _int32: number | null;
            if (
                typeof input.int32 === 'number' &&
                Number.isInteger(input.int32) &&
                input.int32 >= INT32_MIN &&
                input.int32 <= INT32_MAX
            ) {
                _int32 = input.int32;
            } else {
                _int32 = null;
            }
            let _uint32: number | null;
            if (
                typeof input.uint32 === 'number' &&
                Number.isInteger(input.uint32) &&
                input.uint32 >= 0 &&
                input.uint32 <= UINT32_MAX
            ) {
                _uint32 = input.uint32;
            } else {
                _uint32 = null;
            }
            let _int64: bigint | null;
            if (typeof input.int64 === 'string') {
                _int64 = BigInt(input.int64);
            } else if (typeof input.int64 === 'bigint') {
                _int64 = input.int64;
            } else {
                _int64 = null;
            }
            let _uint64: bigint | null;
            if (
                typeof input.uint64 === 'string' &&
                BigInt(input.uint64) >= BigInt(0)
            ) {
                _uint64 = BigInt(input.uint64);
            } else if (
                typeof input.uint64 === 'bigint' &&
                input.uint64 >= BigInt(0)
            ) {
                _uint64 = input.uint64;
            } else {
                _uint64 = null;
            }
            let _enum: Enumerator | null;
            if (typeof input.enum === 'string') {
                _enum = $$Enumerator.fromSerialValue(input.enum);
            } else {
                _enum = null;
            }
            let _object: NestedObject | null;
            if (isObject(input.object)) {
                _object = $$NestedObject.fromJson(input.object);
            } else {
                _object = null;
            }
            let _array: boolean[] | null;
            if (Array.isArray(input.array)) {
                _array = [];
                for (const _arrayEl of input.array) {
                    let _arrayElValue: boolean;
                    if (typeof _arrayEl === 'boolean') {
                        _arrayElValue = _arrayEl;
                    } else {
                        _arrayElValue = false;
                    }
                    _array.push(_arrayElValue);
                }
            } else {
                _array = null;
            }
            let _record: Record<string, boolean> | null;
            if (isObject(input.record)) {
                _record = {};
                for (const [_key, _value] of Object.entries(input.record)) {
                    let _recordValue: boolean;
                    if (typeof _value === 'boolean') {
                        _recordValue = _value;
                    } else {
                        _recordValue = false;
                    }
                    _record[_key] = _recordValue;
                }
            } else {
                _record = null;
            }
            let _discriminator: Discriminator | null;
            if (isObject(input.discriminator)) {
                _discriminator = $$Discriminator.fromJson(input.discriminator);
            } else {
                _discriminator = null;
            }
            let _any: any;
            _any = input.any;
            return {
                string: _string,
                boolean: _boolean,
                timestamp: _timestamp,
                float32: _float32,
                float64: _float64,
                int8: _int8,
                uint8: _uint8,
                int16: _int16,
                uint16: _uint16,
                int32: _int32,
                uint32: _uint32,
                int64: _int64,
                uint64: _uint64,
                enum: _enum,
                object: _object,
                array: _array,
                record: _record,
                discriminator: _discriminator,
                any: _any,
            };
        },
        fromJsonString(input): ObjectWithNullableFields {
            return $$ObjectWithNullableFields.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"string":';
            if (typeof input.string === 'string') {
                json += serializeString(input.string);
            } else {
                json += 'null';
            }
            json += ',"boolean":';
            json += `${input.boolean}`;
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += 'null';
            }
            json += ',"float32":';
            json += `${input.float32}`;
            json += ',"float64":';
            json += `${input.float64}`;
            json += ',"int8":';
            json += `${input.int8}`;
            json += ',"uint8":';
            json += `${input.uint8}`;
            json += ',"int16":';
            json += `${input.int16}`;
            json += ',"uint16":';
            json += `${input.uint16}`;
            json += ',"int32":';
            json += `${input.int32}`;
            json += ',"uint32":';
            json += `${input.uint32}`;
            json += ',"int64":';
            if (typeof input.int64 === 'bigint') {
                json += `"${input.int64}"`;
            } else {
                json += 'null';
            }
            json += ',"uint64":';
            if (typeof input.uint64 === 'bigint') {
                json += `"${input.uint64}"`;
            } else {
                json += 'null';
            }
            json += ',"enum":';
            if (typeof input.enum === 'string') {
                json += `"${input.enum}"`;
            } else {
                json += 'null';
            }
            json += ',"object":';
            if (input.object !== null) {
                json += $$NestedObject.toJsonString(input.object);
            } else {
                json += 'null';
            }
            json += ',"array":';
            if (input.array !== null) {
                json += '[';
                for (let i = 0; i < input.array.length; i++) {
                    if (i !== 0) json += ',';
                    const _inputArrayEl = input.array[i];
                    json += `${_inputArrayEl}`;
                }
                json += ']';
            } else {
                json += 'null';
            }
            json += ',"record":';
            if (input.record !== null) {
                json += '{';
                let _recordPropertyCount = 0;
                for (const [_key, _value] of Object.entries(input.record)) {
                    if (_recordPropertyCount !== 0) {
                        json += ',';
                    }
                    json += `${serializeString(_key)}:`;
                    json += `${_value}`;
                    _recordPropertyCount++;
                }
                json += '}';
            } else {
                json += 'null';
            }
            json += ',"discriminator":';
            if (input.discriminator != null) {
                json += $$Discriminator.toJsonString(input.discriminator);
            } else {
                json += 'null';
            }
            json += ',"any":';
            json += JSON.stringify(input.any);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`string=${input.string}`);
            queryParts.push(`boolean=${input.boolean}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            queryParts.push(`float32=${input.float32}`);
            queryParts.push(`float64=${input.float64}`);
            queryParts.push(`int8=${input.int8}`);
            queryParts.push(`uint8=${input.uint8}`);
            queryParts.push(`int16=${input.int16}`);
            queryParts.push(`uint16=${input.uint16}`);
            queryParts.push(`int32=${input.int32}`);
            queryParts.push(`uint32=${input.uint32}`);
            queryParts.push(`int64=${input.int64}`);
            queryParts.push(`uint64=${input.uint64}`);
            queryParts.push(`enum=${input.enum}`);
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithNullableFields/object.',
            );
            console.warn(
                '[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithNullableFields/array.',
            );
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithNullableFields/record.',
            );
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithNullableFields/discriminator.',
            );
            console.warn(
                "[WARNING] Cannot serialize any's to query string. Skipping property at /ObjectWithNullableFields/any.",
            );
            return queryParts.join('&');
        },
    };

export interface RecursiveObject {
    left: RecursiveObject | null;
    right: RecursiveObject | null;
}
export const $$RecursiveObject: ArriModelValidator<RecursiveObject> = {
    new(): RecursiveObject {
        return {
            left: null,
            right: null,
        };
    },
    validate(input): input is RecursiveObject {
        return (
            isObject(input) &&
            ($$RecursiveObject.validate(input.left) || input.left === null) &&
            ($$RecursiveObject.validate(input.right) || input.right === null)
        );
    },
    fromJson(input): RecursiveObject {
        let _left: RecursiveObject | null;
        if (isObject(input.left)) {
            _left = $$RecursiveObject.fromJson(input.left);
        } else {
            _left = null;
        }
        let _right: RecursiveObject | null;
        if (isObject(input.right)) {
            _right = $$RecursiveObject.fromJson(input.right);
        } else {
            _right = null;
        }
        return {
            left: _left,
            right: _right,
        };
    },
    fromJsonString(input): RecursiveObject {
        return $$RecursiveObject.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"left":';
        if (input.left !== null) {
            json += $$RecursiveObject.toJsonString(input.left);
        } else {
            json += 'null';
        }
        json += ',"right":';
        if (input.right !== null) {
            json += $$RecursiveObject.toJsonString(input.right);
        } else {
            json += 'null';
        }
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        console.warn(
            '[WARNING] Nested objects cannot be serialized to query string. Ignoring property at /RecursiveObject/left.',
        );
        console.warn(
            '[WARNING] Nested objects cannot be serialized to query string. Ignoring property at /RecursiveObject/right.',
        );
        return queryParts.join('&');
    },
};
