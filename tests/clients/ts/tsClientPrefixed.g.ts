// This file was autogenerated by @arrirpc/codegen-ts. Do not modify directly.
// For more information visit https://github.com/modiimedia/arri

/* eslint-disable */
// @ts-nocheck
import {
    ArriEnumValidator,
    ArriModelValidator,
    UndefinedModelValidator,
    INT8_MAX,
    INT8_MIN,
    INT16_MAX,
    INT16_MIN,
    INT32_MAX,
    INT32_MIN,
    INT64_MAX,
    INT64_MIN,
    isObject,
    serializeString,
    UINT8_MAX,
    UINT16_MAX,
    UINT32_MAX,
    UINT64_MAX,
    type Fetch,
    type RpcDispatcher,
    type RpcDispatcherOptions,
    type RpcRequest,
    type RpcRequestValidator,
    HttpDispatcher,
    WsDispatcher,
    type EventStreamController,
    type EventStreamHooks,
    resolveDispatcherOptions,
    resolveTransport,
} from '@arrirpc/client';

export interface TestClientPrefixedOptions
    extends Omit<RpcDispatcherOptions, 'signal'> {
    transport?: 'http' | 'ws';
    dispatchers?: Record<string, RpcDispatcher>;
    // HTTP options
    baseUrl: string;
    fetch?: Fetch;
    // WS options
    wsConnectionUrl: string;
}

export interface RpcOptions<T extends string> extends RpcDispatcherOptions {
    transport?: T;
}

export class TestClientPrefixed {
    private readonly _dispatchers: Record<string, RpcDispatcher>;
    private readonly _options: RpcDispatcherOptions;
    private readonly _defaultTransport: string;

    constructor(config: TestClientPrefixedOptions) {
        this._options = {
            headers: config.headers,
            onError: config.onError,
            retry: config.retry,
            retryDelay: config.retryDelay,
            retryErrorCodes: config.retryErrorCodes,
            timeout: config.timeout,
        };
        this._defaultTransport = config.transport ?? 'http';
        if (!config.dispatchers) config.dispatchers = {};
        if (!config.dispatchers['http']) {
            config.dispatchers['http'] = new HttpDispatcher(config);
        }
        if (!config.dispatchers['ws']) {
            config.dispatchers['ws'] = new WsDispatcher(config);
        }
        this._dispatchers = config.dispatchers!;
    }
    async emptyParamsGetRequest(
        options?: RpcOptions<'http' | 'ws'>,
    ): Promise<FooDefaultPayload> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<undefined> = {
            procedure: 'emptyParamsGetRequest',
            path: '/rpcs/tests/empty-params-get-request',
            method: 'get',
            clientVersion: '10',
            data: undefined,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<undefined, FooDefaultPayload> = {
            params: UndefinedModelValidator,
            response: $$FooDefaultPayload,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<undefined, FooDefaultPayload>(
            req,
            validator,
            finalOptions,
        );
    }
    async emptyParamsPostRequest(
        options?: RpcOptions<'http' | 'ws'>,
    ): Promise<FooDefaultPayload> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<undefined> = {
            procedure: 'emptyParamsPostRequest',
            path: '/rpcs/tests/empty-params-post-request',
            method: undefined,
            clientVersion: '10',
            data: undefined,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<undefined, FooDefaultPayload> = {
            params: UndefinedModelValidator,
            response: $$FooDefaultPayload,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<undefined, FooDefaultPayload>(
            req,
            validator,
            finalOptions,
        );
    }
    async emptyResponseGetRequest(
        params: FooDefaultPayload,
        options?: RpcOptions<'http' | 'ws'>,
    ): Promise<undefined> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<FooDefaultPayload> = {
            procedure: 'emptyResponseGetRequest',
            path: '/rpcs/tests/empty-response-get-request',
            method: 'get',
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<FooDefaultPayload, undefined> = {
            params: $$FooDefaultPayload,
            response: UndefinedModelValidator,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<FooDefaultPayload, undefined>(
            req,
            validator,
            finalOptions,
        );
    }
    async emptyResponsePostRequest(
        params: FooDefaultPayload,
        options?: RpcOptions<'http' | 'ws'>,
    ): Promise<undefined> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<FooDefaultPayload> = {
            procedure: 'emptyResponsePostRequest',
            path: '/rpcs/tests/empty-response-post-request',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<FooDefaultPayload, undefined> = {
            params: $$FooDefaultPayload,
            response: UndefinedModelValidator,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<FooDefaultPayload, undefined>(
            req,
            validator,
            finalOptions,
        );
    }
    /**
     * If the target language supports it. Generated code should mark this procedure as deprecated.
     * @deprecated
     */
    async deprecatedRpc(
        params: FooDeprecatedRpcParams,
        options?: RpcOptions<'http' | 'ws'>,
    ): Promise<undefined> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<FooDeprecatedRpcParams> = {
            procedure: 'deprecatedRpc',
            path: '/rpcs/tests/deprecated-rpc',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<
            FooDeprecatedRpcParams,
            undefined
        > = {
            params: $$FooDeprecatedRpcParams,
            response: UndefinedModelValidator,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<FooDeprecatedRpcParams, undefined>(
            req,
            validator,
            finalOptions,
        );
    }
    async sendDiscriminatorWithEmptyObject(
        params: FooDiscriminatorWithEmptyObject,
        options?: RpcOptions<'http' | 'ws'>,
    ): Promise<FooDiscriminatorWithEmptyObject> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<FooDiscriminatorWithEmptyObject> = {
            procedure: 'sendDiscriminatorWithEmptyObject',
            path: '/rpcs/tests/send-discriminator-with-empty-object',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<
            FooDiscriminatorWithEmptyObject,
            FooDiscriminatorWithEmptyObject
        > = {
            params: $$FooDiscriminatorWithEmptyObject,
            response: $$FooDiscriminatorWithEmptyObject,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<
            FooDiscriminatorWithEmptyObject,
            FooDiscriminatorWithEmptyObject
        >(req, validator, finalOptions);
    }
    async sendError(
        params: FooSendErrorParams,
        options?: RpcOptions<'http' | 'ws'>,
    ): Promise<undefined> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<FooSendErrorParams> = {
            procedure: 'sendError',
            path: '/rpcs/tests/send-error',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<FooSendErrorParams, undefined> = {
            params: $$FooSendErrorParams,
            response: UndefinedModelValidator,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<FooSendErrorParams, undefined>(
            req,
            validator,
            finalOptions,
        );
    }
    async sendObject(
        params: FooObjectWithEveryType,
        options?: RpcOptions<'http' | 'ws'>,
    ): Promise<FooObjectWithEveryType> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<FooObjectWithEveryType> = {
            procedure: 'sendObject',
            path: '/rpcs/tests/send-object',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<
            FooObjectWithEveryType,
            FooObjectWithEveryType
        > = {
            params: $$FooObjectWithEveryType,
            response: $$FooObjectWithEveryType,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<
            FooObjectWithEveryType,
            FooObjectWithEveryType
        >(req, validator, finalOptions);
    }
    async sendObjectWithNullableFields(
        params: FooObjectWithEveryNullableType,
        options?: RpcOptions<'http' | 'ws'>,
    ): Promise<FooObjectWithEveryNullableType> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<FooObjectWithEveryNullableType> = {
            procedure: 'sendObjectWithNullableFields',
            path: '/rpcs/tests/send-object-with-nullable-fields',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<
            FooObjectWithEveryNullableType,
            FooObjectWithEveryNullableType
        > = {
            params: $$FooObjectWithEveryNullableType,
            response: $$FooObjectWithEveryNullableType,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<
            FooObjectWithEveryNullableType,
            FooObjectWithEveryNullableType
        >(req, validator, finalOptions);
    }
    async sendObjectWithPascalCaseKeys(
        params: FooObjectWithPascalCaseKeys,
        options?: RpcOptions<'http' | 'ws'>,
    ): Promise<FooObjectWithPascalCaseKeys> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<FooObjectWithPascalCaseKeys> = {
            procedure: 'sendObjectWithPascalCaseKeys',
            path: '/rpcs/tests/send-object-with-pascal-case-keys',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<
            FooObjectWithPascalCaseKeys,
            FooObjectWithPascalCaseKeys
        > = {
            params: $$FooObjectWithPascalCaseKeys,
            response: $$FooObjectWithPascalCaseKeys,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<
            FooObjectWithPascalCaseKeys,
            FooObjectWithPascalCaseKeys
        >(req, validator, finalOptions);
    }
    async sendObjectWithSnakeCaseKeys(
        params: FooObjectWithSnakeCaseKeys,
        options?: RpcOptions<'http' | 'ws'>,
    ): Promise<FooObjectWithSnakeCaseKeys> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<FooObjectWithSnakeCaseKeys> = {
            procedure: 'sendObjectWithSnakeCaseKeys',
            path: '/rpcs/tests/send-object-with-snake-case-keys',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<
            FooObjectWithSnakeCaseKeys,
            FooObjectWithSnakeCaseKeys
        > = {
            params: $$FooObjectWithSnakeCaseKeys,
            response: $$FooObjectWithSnakeCaseKeys,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<
            FooObjectWithSnakeCaseKeys,
            FooObjectWithSnakeCaseKeys
        >(req, validator, finalOptions);
    }
    async sendPartialObject(
        params: FooObjectWithEveryOptionalType,
        options?: RpcOptions<'http' | 'ws'>,
    ): Promise<FooObjectWithEveryOptionalType> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<FooObjectWithEveryOptionalType> = {
            procedure: 'sendPartialObject',
            path: '/rpcs/tests/send-partial-object',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<
            FooObjectWithEveryOptionalType,
            FooObjectWithEveryOptionalType
        > = {
            params: $$FooObjectWithEveryOptionalType,
            response: $$FooObjectWithEveryOptionalType,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<
            FooObjectWithEveryOptionalType,
            FooObjectWithEveryOptionalType
        >(req, validator, finalOptions);
    }
    async sendRecursiveObject(
        params: FooRecursiveObject,
        options?: RpcOptions<'http' | 'ws'>,
    ): Promise<FooRecursiveObject> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<FooRecursiveObject> = {
            procedure: 'sendRecursiveObject',
            path: '/rpcs/tests/send-recursive-object',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<
            FooRecursiveObject,
            FooRecursiveObject
        > = {
            params: $$FooRecursiveObject,
            response: $$FooRecursiveObject,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<FooRecursiveObject, FooRecursiveObject>(
            req,
            validator,
            finalOptions,
        );
    }
    async sendRecursiveUnion(
        params: FooRecursiveUnion,
        options?: RpcOptions<'http' | 'ws'>,
    ): Promise<FooRecursiveUnion> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<FooRecursiveUnion> = {
            procedure: 'sendRecursiveUnion',
            path: '/rpcs/tests/send-recursive-union',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<
            FooRecursiveUnion,
            FooRecursiveUnion
        > = {
            params: $$FooRecursiveUnion,
            response: $$FooRecursiveUnion,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<FooRecursiveUnion, FooRecursiveUnion>(
            req,
            validator,
            finalOptions,
        );
    }
    streamAutoReconnect(
        params: FooAutoReconnectParams,
        options?: EventStreamHooks<FooAutoReconnectResponse>,
    ): EventStreamController {
        const req: RpcRequest<FooAutoReconnectParams> = {
            procedure: 'streamAutoReconnect',
            path: '/rpcs/tests/stream-auto-reconnect',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: this._options.headers,
        };
        const validator: RpcRequestValidator<
            FooAutoReconnectParams,
            FooAutoReconnectResponse
        > = {
            params: $$FooAutoReconnectParams,
            response: $$FooAutoReconnectResponse,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            this._options.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleEventStreamRpc<
            FooAutoReconnectParams,
            FooAutoReconnectResponse
        >(req, validator, options ?? {});
    }
    /**
     * This route will always return an error. The client should automatically retry with exponential backoff.
     */
    streamConnectionErrorTest(
        params: FooStreamConnectionErrorTestParams,
        options?: EventStreamHooks<FooStreamConnectionErrorTestResponse>,
    ): EventStreamController {
        const req: RpcRequest<FooStreamConnectionErrorTestParams> = {
            procedure: 'streamConnectionErrorTest',
            path: '/rpcs/tests/stream-connection-error-test',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: this._options.headers,
        };
        const validator: RpcRequestValidator<
            FooStreamConnectionErrorTestParams,
            FooStreamConnectionErrorTestResponse
        > = {
            params: $$FooStreamConnectionErrorTestParams,
            response: $$FooStreamConnectionErrorTestResponse,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            this._options.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleEventStreamRpc<
            FooStreamConnectionErrorTestParams,
            FooStreamConnectionErrorTestResponse
        >(req, validator, options ?? {});
    }
    /**
     * Test to ensure that the client can handle receiving streams of large objects. When objects are large messages will sometimes get sent in chunks. Meaning you have to handle receiving a partial message
     */
    streamLargeObjects(
        options?: EventStreamHooks<FooStreamLargeObjectsResponse>,
    ): EventStreamController {
        const req: RpcRequest<undefined> = {
            procedure: 'streamLargeObjects',
            path: '/rpcs/tests/stream-large-objects',
            method: undefined,
            clientVersion: '10',
            data: undefined,
            customHeaders: this._options.headers,
        };
        const validator: RpcRequestValidator<
            undefined,
            FooStreamLargeObjectsResponse
        > = {
            params: UndefinedModelValidator,
            response: $$FooStreamLargeObjectsResponse,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            this._options.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleEventStreamRpc<
            undefined,
            FooStreamLargeObjectsResponse
        >(req, validator, options ?? {});
    }
    streamMessages(
        params: FooChatMessageParams,
        options?: EventStreamHooks<FooChatMessage>,
    ): EventStreamController {
        const req: RpcRequest<FooChatMessageParams> = {
            procedure: 'streamMessages',
            path: '/rpcs/tests/stream-messages',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: this._options.headers,
        };
        const validator: RpcRequestValidator<
            FooChatMessageParams,
            FooChatMessage
        > = {
            params: $$FooChatMessageParams,
            response: $$FooChatMessage,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            this._options.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleEventStreamRpc<
            FooChatMessageParams,
            FooChatMessage
        >(req, validator, options ?? {});
    }
    streamRetryWithNewCredentials(
        options?: EventStreamHooks<FooTestsStreamRetryWithNewCredentialsResponse>,
    ): EventStreamController {
        const req: RpcRequest<undefined> = {
            procedure: 'streamRetryWithNewCredentials',
            path: '/rpcs/tests/stream-retry-with-new-credentials',
            method: undefined,
            clientVersion: '10',
            data: undefined,
            customHeaders: this._options.headers,
        };
        const validator: RpcRequestValidator<
            undefined,
            FooTestsStreamRetryWithNewCredentialsResponse
        > = {
            params: UndefinedModelValidator,
            response: $$FooTestsStreamRetryWithNewCredentialsResponse,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            this._options.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleEventStreamRpc<
            undefined,
            FooTestsStreamRetryWithNewCredentialsResponse
        >(req, validator, options ?? {});
    }
    /**
     * When the client receives the 'done' event, it should close the connection and NOT reconnect
     */
    streamTenEventsThenEnd(
        options?: EventStreamHooks<FooChatMessage>,
    ): EventStreamController {
        const req: RpcRequest<undefined> = {
            procedure: 'streamTenEventsThenEnd',
            path: '/rpcs/tests/stream-ten-events-then-end',
            method: undefined,
            clientVersion: '10',
            data: undefined,
            customHeaders: this._options.headers,
        };
        const validator: RpcRequestValidator<undefined, FooChatMessage> = {
            params: UndefinedModelValidator,
            response: $$FooChatMessage,
        };
        const transport = resolveTransport(
            ['http', 'ws'],
            options?.transport,
            this._defaultTransport,
        );
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            this._options.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleEventStreamRpc<undefined, FooChatMessage>(
            req,
            validator,
            options ?? {},
        );
    }
}

export interface FooManuallyAddedModel {
    hello: string;
}
export const $$FooManuallyAddedModel: ArriModelValidator<FooManuallyAddedModel> =
    {
        new(): FooManuallyAddedModel {
            return {
                hello: '',
            };
        },
        validate(input): input is FooManuallyAddedModel {
            return isObject(input) && typeof input.hello === 'string';
        },
        fromJson(input): FooManuallyAddedModel {
            let _hello: string;
            if (typeof input.hello === 'string') {
                _hello = input.hello;
            } else {
                _hello = '';
            }
            return {
                hello: _hello,
            };
        },
        fromJsonString(input): FooManuallyAddedModel {
            return $$FooManuallyAddedModel.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"hello":';
            json += serializeString(input.hello);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`hello=${input.hello}`);
            return queryParts.join('&');
        },
    };

export interface FooDefaultPayload {
    message: string;
}
export const $$FooDefaultPayload: ArriModelValidator<FooDefaultPayload> = {
    new(): FooDefaultPayload {
        return {
            message: '',
        };
    },
    validate(input): input is FooDefaultPayload {
        return isObject(input) && typeof input.message === 'string';
    },
    fromJson(input): FooDefaultPayload {
        let _message: string;
        if (typeof input.message === 'string') {
            _message = input.message;
        } else {
            _message = '';
        }
        return {
            message: _message,
        };
    },
    fromJsonString(input): FooDefaultPayload {
        return $$FooDefaultPayload.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"message":';
        json += serializeString(input.message);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`message=${input.message}`);
        return queryParts.join('&');
    },
};

/**
 * @deprecated
 */
export interface FooDeprecatedRpcParams {
    /**
     * @deprecated
     */
    deprecatedField: string;
}
export const $$FooDeprecatedRpcParams: ArriModelValidator<FooDeprecatedRpcParams> =
    {
        new(): FooDeprecatedRpcParams {
            return {
                deprecatedField: '',
            };
        },
        validate(input): input is FooDeprecatedRpcParams {
            return isObject(input) && typeof input.deprecatedField === 'string';
        },
        fromJson(input): FooDeprecatedRpcParams {
            let _deprecatedField: string;
            if (typeof input.deprecatedField === 'string') {
                _deprecatedField = input.deprecatedField;
            } else {
                _deprecatedField = '';
            }
            return {
                deprecatedField: _deprecatedField,
            };
        },
        fromJsonString(input): FooDeprecatedRpcParams {
            return $$FooDeprecatedRpcParams.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"deprecatedField":';
            json += serializeString(input.deprecatedField);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`deprecatedField=${input.deprecatedField}`);
            return queryParts.join('&');
        },
    };

export type FooDiscriminatorWithEmptyObject =
    | FooDiscriminatorWithEmptyObjectEmpty
    | FooDiscriminatorWithEmptyObjectNotEmpty;
export const $$FooDiscriminatorWithEmptyObject: ArriModelValidator<FooDiscriminatorWithEmptyObject> =
    {
        new(): FooDiscriminatorWithEmptyObject {
            return $$FooDiscriminatorWithEmptyObjectEmpty.new();
        },
        validate(input): input is FooDiscriminatorWithEmptyObject {
            if (!isObject(input)) {
                return false;
            }
            if (typeof input.type !== 'string') {
                return false;
            }
            switch (input.type) {
                case 'EMPTY':
                    return $$FooDiscriminatorWithEmptyObjectEmpty.validate(
                        input,
                    );
                case 'NOT_EMPTY':
                    return $$FooDiscriminatorWithEmptyObjectNotEmpty.validate(
                        input,
                    );
                default:
                    return false;
            }
        },
        fromJson(input): FooDiscriminatorWithEmptyObject {
            switch (input.type) {
                case 'EMPTY':
                    return $$FooDiscriminatorWithEmptyObjectEmpty.fromJson(
                        input,
                    );
                case 'NOT_EMPTY':
                    return $$FooDiscriminatorWithEmptyObjectNotEmpty.fromJson(
                        input,
                    );
                default:
                    return $$FooDiscriminatorWithEmptyObjectEmpty.new();
            }
        },
        fromJsonString(input): FooDiscriminatorWithEmptyObject {
            return $$FooDiscriminatorWithEmptyObject.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            switch (input.type) {
                case 'EMPTY':
                    return $$FooDiscriminatorWithEmptyObjectEmpty.toJsonString(
                        input,
                    );
                case 'NOT_EMPTY':
                    return $$FooDiscriminatorWithEmptyObjectNotEmpty.toJsonString(
                        input,
                    );
                default:
                    throw new Error(`Unhandled case "${(input as any).type}"`);
            }
        },
        toUrlQueryString(input): string {
            switch (input.type) {
                case 'EMPTY':
                    return $$FooDiscriminatorWithEmptyObjectEmpty.toUrlQueryString(
                        input,
                    );
                case 'NOT_EMPTY':
                    return $$FooDiscriminatorWithEmptyObjectNotEmpty.toUrlQueryString(
                        input,
                    );
                default:
                    throw new Error('Unhandled case');
            }
        },
    };
export interface FooDiscriminatorWithEmptyObjectEmpty {
    type: 'EMPTY';
}
const $$FooDiscriminatorWithEmptyObjectEmpty: ArriModelValidator<FooDiscriminatorWithEmptyObjectEmpty> =
    {
        new(): FooDiscriminatorWithEmptyObjectEmpty {
            return {
                type: 'EMPTY',
            };
        },
        validate(input): input is FooDiscriminatorWithEmptyObjectEmpty {
            return isObject(input) && input.type === 'EMPTY';
        },
        fromJson(input): FooDiscriminatorWithEmptyObjectEmpty {
            const _type = 'EMPTY';
            return {
                type: _type,
            };
        },
        fromJsonString(input): FooDiscriminatorWithEmptyObjectEmpty {
            return $$FooDiscriminatorWithEmptyObjectEmpty.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"type":"EMPTY"';
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('type=EMPTY');
            return queryParts.join('&');
        },
    };

export interface FooDiscriminatorWithEmptyObjectNotEmpty {
    type: 'NOT_EMPTY';
    foo: string;
    bar: number;
    baz: boolean;
}
const $$FooDiscriminatorWithEmptyObjectNotEmpty: ArriModelValidator<FooDiscriminatorWithEmptyObjectNotEmpty> =
    {
        new(): FooDiscriminatorWithEmptyObjectNotEmpty {
            return {
                type: 'NOT_EMPTY',
                foo: '',
                bar: 0,
                baz: false,
            };
        },
        validate(input): input is FooDiscriminatorWithEmptyObjectNotEmpty {
            return (
                isObject(input) &&
                input.type === 'NOT_EMPTY' &&
                typeof input.foo === 'string' &&
                typeof input.bar === 'number' &&
                typeof input.baz === 'boolean'
            );
        },
        fromJson(input): FooDiscriminatorWithEmptyObjectNotEmpty {
            const _type = 'NOT_EMPTY';
            let _foo: string;
            if (typeof input.foo === 'string') {
                _foo = input.foo;
            } else {
                _foo = '';
            }
            let _bar: number;
            if (typeof input.bar === 'number') {
                _bar = input.bar;
            } else {
                _bar = 0;
            }
            let _baz: boolean;
            if (typeof input.baz === 'boolean') {
                _baz = input.baz;
            } else {
                _baz = false;
            }
            return {
                type: _type,
                foo: _foo,
                bar: _bar,
                baz: _baz,
            };
        },
        fromJsonString(input): FooDiscriminatorWithEmptyObjectNotEmpty {
            return $$FooDiscriminatorWithEmptyObjectNotEmpty.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"type":"NOT_EMPTY"';
            json += ',"foo":';
            json += serializeString(input.foo);
            json += ',"bar":';
            json += `${input.bar}`;
            json += ',"baz":';
            json += `${input.baz}`;
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('type=NOT_EMPTY');
            queryParts.push(`foo=${input.foo}`);
            queryParts.push(`bar=${input.bar}`);
            queryParts.push(`baz=${input.baz}`);
            return queryParts.join('&');
        },
    };

export interface FooSendErrorParams {
    code: number;
    message: string;
}
export const $$FooSendErrorParams: ArriModelValidator<FooSendErrorParams> = {
    new(): FooSendErrorParams {
        return {
            code: 0,
            message: '',
        };
    },
    validate(input): input is FooSendErrorParams {
        return (
            isObject(input) &&
            typeof input.code === 'number' &&
            Number.isInteger(input.code) &&
            input.code >= 0 &&
            input.code <= UINT16_MAX &&
            typeof input.message === 'string'
        );
    },
    fromJson(input): FooSendErrorParams {
        let _code: number;
        if (
            typeof input.code === 'number' &&
            Number.isInteger(input.code) &&
            input.code >= 0 &&
            input.code <= UINT16_MAX
        ) {
            _code = input.code;
        } else {
            _code = 0;
        }
        let _message: string;
        if (typeof input.message === 'string') {
            _message = input.message;
        } else {
            _message = '';
        }
        return {
            code: _code,
            message: _message,
        };
    },
    fromJsonString(input): FooSendErrorParams {
        return $$FooSendErrorParams.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"code":';
        json += `${input.code}`;
        json += ',"message":';
        json += serializeString(input.message);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`code=${input.code}`);
        queryParts.push(`message=${input.message}`);
        return queryParts.join('&');
    },
};

export interface FooObjectWithEveryType {
    any: any;
    boolean: boolean;
    string: string;
    timestamp: Date;
    float32: number;
    float64: number;
    int8: number;
    uint8: number;
    int16: number;
    uint16: number;
    int32: number;
    uint32: number;
    int64: bigint;
    uint64: bigint;
    enumerator: FooObjectWithEveryTypeEnumerator;
    array: boolean[];
    object: FooObjectWithEveryTypeObject;
    record: Record<string, bigint>;
    discriminator: FooObjectWithEveryTypeDiscriminator;
    nestedObject: FooObjectWithEveryTypeNestedObject;
    nestedArray: FooObjectWithEveryTypeNestedArrayElementElement[][];
}
export const $$FooObjectWithEveryType: ArriModelValidator<FooObjectWithEveryType> =
    {
        new(): FooObjectWithEveryType {
            return {
                any: undefined,
                boolean: false,
                string: '',
                timestamp: new Date(),
                float32: 0,
                float64: 0,
                int8: 0,
                uint8: 0,
                int16: 0,
                uint16: 0,
                int32: 0,
                uint32: 0,
                int64: BigInt(0),
                uint64: BigInt(0),
                enumerator: $$FooObjectWithEveryTypeEnumerator.new(),
                array: [],
                object: $$FooObjectWithEveryTypeObject.new(),
                record: {},
                discriminator: $$FooObjectWithEveryTypeDiscriminator.new(),
                nestedObject: $$FooObjectWithEveryTypeNestedObject.new(),
                nestedArray: [],
            };
        },
        validate(input): input is FooObjectWithEveryType {
            return (
                isObject(input) &&
                true &&
                typeof input.boolean === 'boolean' &&
                typeof input.string === 'string' &&
                input.timestamp instanceof Date &&
                typeof input.float32 === 'number' &&
                typeof input.float64 === 'number' &&
                typeof input.int8 === 'number' &&
                Number.isInteger(input.int8) &&
                input.int8 >= INT8_MIN &&
                input.int8 <= INT8_MAX &&
                typeof input.uint8 === 'number' &&
                Number.isInteger(input.uint8) &&
                input.uint8 >= 0 &&
                input.uint8 <= UINT8_MAX &&
                typeof input.int16 === 'number' &&
                Number.isInteger(input.int16) &&
                input.int16 >= INT16_MIN &&
                input.int16 <= INT16_MAX &&
                typeof input.uint16 === 'number' &&
                Number.isInteger(input.uint16) &&
                input.uint16 >= 0 &&
                input.uint16 <= UINT16_MAX &&
                typeof input.int32 === 'number' &&
                Number.isInteger(input.int32) &&
                input.int32 >= INT32_MIN &&
                input.int32 <= INT32_MAX &&
                typeof input.uint32 === 'number' &&
                Number.isInteger(input.uint32) &&
                input.uint32 >= 0 &&
                input.uint32 <= UINT32_MAX &&
                typeof input.int64 === 'bigint' &&
                input.int64 >= INT64_MIN &&
                input.int64 <= INT64_MAX &&
                typeof input.uint64 === 'bigint' &&
                input.uint64 >= BigInt(0) &&
                input.uint64 <= UINT64_MAX &&
                $$FooObjectWithEveryTypeEnumerator.validate(input.enumerator) &&
                Array.isArray(input.array) &&
                input.array.every(
                    (_element) => typeof _element === 'boolean',
                ) &&
                $$FooObjectWithEveryTypeObject.validate(input.object) &&
                isObject(input.record) &&
                Object.values(input.record).every(
                    (_value) =>
                        typeof _value === 'bigint' &&
                        _value >= BigInt(0) &&
                        _value <= UINT64_MAX,
                ) &&
                $$FooObjectWithEveryTypeDiscriminator.validate(
                    input.discriminator,
                ) &&
                $$FooObjectWithEveryTypeNestedObject.validate(
                    input.nestedObject,
                ) &&
                Array.isArray(input.nestedArray) &&
                input.nestedArray.every(
                    (_element) =>
                        Array.isArray(_element) &&
                        _element.every((_element) =>
                            $$FooObjectWithEveryTypeNestedArrayElementElement.validate(
                                _element,
                            ),
                        ),
                )
            );
        },
        fromJson(input): FooObjectWithEveryType {
            let _any: any;
            _any = input.any;
            let _boolean: boolean;
            if (typeof input.boolean === 'boolean') {
                _boolean = input.boolean;
            } else {
                _boolean = false;
            }
            let _string: string;
            if (typeof input.string === 'string') {
                _string = input.string;
            } else {
                _string = '';
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            let _float32: number;
            if (typeof input.float32 === 'number') {
                _float32 = input.float32;
            } else {
                _float32 = 0;
            }
            let _float64: number;
            if (typeof input.float64 === 'number') {
                _float64 = input.float64;
            } else {
                _float64 = 0;
            }
            let _int8: number;
            if (
                typeof input.int8 === 'number' &&
                Number.isInteger(input.int8) &&
                input.int8 >= INT8_MIN &&
                input.int8 <= INT8_MAX
            ) {
                _int8 = input.int8;
            } else {
                _int8 = 0;
            }
            let _uint8: number;
            if (
                typeof input.uint8 === 'number' &&
                Number.isInteger(input.uint8) &&
                input.uint8 >= 0 &&
                input.uint8 <= UINT8_MAX
            ) {
                _uint8 = input.uint8;
            } else {
                _uint8 = 0;
            }
            let _int16: number;
            if (
                typeof input.int16 === 'number' &&
                Number.isInteger(input.int16) &&
                input.int16 >= INT16_MIN &&
                input.int16 <= INT16_MAX
            ) {
                _int16 = input.int16;
            } else {
                _int16 = 0;
            }
            let _uint16: number;
            if (
                typeof input.uint16 === 'number' &&
                Number.isInteger(input.uint16) &&
                input.uint16 >= 0 &&
                input.uint16 <= UINT16_MAX
            ) {
                _uint16 = input.uint16;
            } else {
                _uint16 = 0;
            }
            let _int32: number;
            if (
                typeof input.int32 === 'number' &&
                Number.isInteger(input.int32) &&
                input.int32 >= INT32_MIN &&
                input.int32 <= INT32_MAX
            ) {
                _int32 = input.int32;
            } else {
                _int32 = 0;
            }
            let _uint32: number;
            if (
                typeof input.uint32 === 'number' &&
                Number.isInteger(input.uint32) &&
                input.uint32 >= 0 &&
                input.uint32 <= UINT32_MAX
            ) {
                _uint32 = input.uint32;
            } else {
                _uint32 = 0;
            }
            let _int64: bigint;
            if (typeof input.int64 === 'string') {
                _int64 = BigInt(input.int64);
            } else if (typeof input.int64 === 'bigint') {
                _int64 = input.int64;
            } else {
                _int64 = BigInt(0);
            }
            let _uint64: bigint;
            if (
                typeof input.uint64 === 'string' &&
                BigInt(input.uint64) >= BigInt(0)
            ) {
                _uint64 = BigInt(input.uint64);
            } else if (
                typeof input.uint64 === 'bigint' &&
                input.uint64 >= BigInt(0)
            ) {
                _uint64 = input.uint64;
            } else {
                _uint64 = BigInt(0);
            }
            let _enumerator: FooObjectWithEveryTypeEnumerator;
            if (typeof input.enumerator === 'string') {
                _enumerator =
                    $$FooObjectWithEveryTypeEnumerator.fromSerialValue(
                        input.enumerator,
                    );
            } else {
                _enumerator = $$FooObjectWithEveryTypeEnumerator.new();
            }
            let _array: boolean[];
            if (Array.isArray(input.array)) {
                _array = [];
                for (const _arrayEl of input.array) {
                    let _arrayElValue: boolean;
                    if (typeof _arrayEl === 'boolean') {
                        _arrayElValue = _arrayEl;
                    } else {
                        _arrayElValue = false;
                    }
                    _array.push(_arrayElValue);
                }
            } else {
                _array = [];
            }
            let _object: FooObjectWithEveryTypeObject;
            if (isObject(input.object)) {
                _object = $$FooObjectWithEveryTypeObject.fromJson(input.object);
            } else {
                _object = $$FooObjectWithEveryTypeObject.new();
            }
            let _record: Record<string, bigint>;
            if (isObject(input.record)) {
                _record = {};
                for (const [_key, _value] of Object.entries(input.record)) {
                    let _recordValue: bigint;
                    if (
                        typeof _value === 'string' &&
                        BigInt(_value) >= BigInt(0)
                    ) {
                        _recordValue = BigInt(_value);
                    } else if (
                        typeof _value === 'bigint' &&
                        _value >= BigInt(0)
                    ) {
                        _recordValue = _value;
                    } else {
                        _recordValue = BigInt(0);
                    }
                    _record[_key] = _recordValue;
                }
            } else {
                _record = {};
            }
            let _discriminator: FooObjectWithEveryTypeDiscriminator;
            if (isObject(input.discriminator)) {
                _discriminator = $$FooObjectWithEveryTypeDiscriminator.fromJson(
                    input.discriminator,
                );
            } else {
                _discriminator = $$FooObjectWithEveryTypeDiscriminator.new();
            }
            let _nestedObject: FooObjectWithEveryTypeNestedObject;
            if (isObject(input.nestedObject)) {
                _nestedObject = $$FooObjectWithEveryTypeNestedObject.fromJson(
                    input.nestedObject,
                );
            } else {
                _nestedObject = $$FooObjectWithEveryTypeNestedObject.new();
            }
            let _nestedArray: FooObjectWithEveryTypeNestedArrayElementElement[][];
            if (Array.isArray(input.nestedArray)) {
                _nestedArray = [];
                for (const _nestedArrayEl of input.nestedArray) {
                    let _nestedArrayElValue: FooObjectWithEveryTypeNestedArrayElementElement[];
                    if (Array.isArray(_nestedArrayEl)) {
                        _nestedArrayElValue = [];
                        for (const _nestedArrayElValueEl of _nestedArrayEl) {
                            let _nestedArrayElValueElValue: FooObjectWithEveryTypeNestedArrayElementElement;
                            if (isObject(_nestedArrayElValueEl)) {
                                _nestedArrayElValueElValue =
                                    $$FooObjectWithEveryTypeNestedArrayElementElement.fromJson(
                                        _nestedArrayElValueEl,
                                    );
                            } else {
                                _nestedArrayElValueElValue =
                                    $$FooObjectWithEveryTypeNestedArrayElementElement.new();
                            }
                            _nestedArrayElValue.push(
                                _nestedArrayElValueElValue,
                            );
                        }
                    } else {
                        _nestedArrayElValue = [];
                    }
                    _nestedArray.push(_nestedArrayElValue);
                }
            } else {
                _nestedArray = [];
            }
            return {
                any: _any,
                boolean: _boolean,
                string: _string,
                timestamp: _timestamp,
                float32: _float32,
                float64: _float64,
                int8: _int8,
                uint8: _uint8,
                int16: _int16,
                uint16: _uint16,
                int32: _int32,
                uint32: _uint32,
                int64: _int64,
                uint64: _uint64,
                enumerator: _enumerator,
                array: _array,
                object: _object,
                record: _record,
                discriminator: _discriminator,
                nestedObject: _nestedObject,
                nestedArray: _nestedArray,
            };
        },
        fromJsonString(input): FooObjectWithEveryType {
            return $$FooObjectWithEveryType.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"any":';
            json += JSON.stringify(input.any);
            json += ',"boolean":';
            json += `${input.boolean}`;
            json += ',"string":';
            json += serializeString(input.string);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += ',"float32":';
            json += `${input.float32}`;
            json += ',"float64":';
            json += `${input.float64}`;
            json += ',"int8":';
            json += `${input.int8}`;
            json += ',"uint8":';
            json += `${input.uint8}`;
            json += ',"int16":';
            json += `${input.int16}`;
            json += ',"uint16":';
            json += `${input.uint16}`;
            json += ',"int32":';
            json += `${input.int32}`;
            json += ',"uint32":';
            json += `${input.uint32}`;
            json += ',"int64":';
            json += `"${input.int64}"`;
            json += ',"uint64":';
            json += `"${input.uint64}"`;
            json += ',"enumerator":';
            json += `"${input.enumerator}"`;
            json += ',"array":';
            json += '[';
            for (let i = 0; i < input.array.length; i++) {
                if (i !== 0) json += ',';
                const _inputArrayEl = input.array[i];
                json += `${_inputArrayEl}`;
            }
            json += ']';
            json += ',"object":';
            json += $$FooObjectWithEveryTypeObject.toJsonString(input.object);
            json += ',"record":';
            json += '{';
            let _recordPropertyCount = 0;
            for (const [_key, _value] of Object.entries(input.record)) {
                if (_recordPropertyCount !== 0) {
                    json += ',';
                }
                json += `${serializeString(_key)}:`;
                json += `"${_value}"`;
                _recordPropertyCount++;
            }
            json += '}';

            json += ',"discriminator":';
            json += $$FooObjectWithEveryTypeDiscriminator.toJsonString(
                input.discriminator,
            );
            json += ',"nestedObject":';
            json += $$FooObjectWithEveryTypeNestedObject.toJsonString(
                input.nestedObject,
            );
            json += ',"nestedArray":';
            json += '[';
            for (let i = 0; i < input.nestedArray.length; i++) {
                if (i !== 0) json += ',';
                const _inputNestedArrayEl = input.nestedArray[i];
                json += '[';
                for (let i = 0; i < _inputNestedArrayEl.length; i++) {
                    if (i !== 0) json += ',';
                    const _inputNestedArrayElEl = _inputNestedArrayEl[i];
                    json +=
                        $$FooObjectWithEveryTypeNestedArrayElementElement.toJsonString(
                            _inputNestedArrayElEl,
                        );
                }
                json += ']';
            }
            json += ']';
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            console.warn(
                "[WARNING] Cannot serialize any's to query string. Skipping property at /ObjectWithEveryType/any.",
            );
            queryParts.push(`boolean=${input.boolean}`);
            queryParts.push(`string=${input.string}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            queryParts.push(`float32=${input.float32}`);
            queryParts.push(`float64=${input.float64}`);
            queryParts.push(`int8=${input.int8}`);
            queryParts.push(`uint8=${input.uint8}`);
            queryParts.push(`int16=${input.int16}`);
            queryParts.push(`uint16=${input.uint16}`);
            queryParts.push(`int32=${input.int32}`);
            queryParts.push(`uint32=${input.uint32}`);
            queryParts.push(`int64=${input.int64}`);
            queryParts.push(`uint64=${input.uint64}`);
            queryParts.push(`enumerator=${input.enumerator}`);
            console.warn(
                '[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryType/array.',
            );
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryType/object.',
            );
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryType/record.',
            );
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryType/discriminator.',
            );
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryType/nestedObject.',
            );
            console.warn(
                '[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryType/nestedArray.',
            );
            return queryParts.join('&');
        },
    };

export type FooObjectWithEveryTypeEnumerator =
    (typeof $$FooObjectWithEveryTypeEnumeratorValues)[number];
const $$FooObjectWithEveryTypeEnumeratorValues = ['A', 'B', 'C'] as const;
export const $$FooObjectWithEveryTypeEnumerator: ArriEnumValidator<FooObjectWithEveryTypeEnumerator> =
    {
        new(): FooObjectWithEveryTypeEnumerator {
            return $$FooObjectWithEveryTypeEnumeratorValues[0];
        },
        validate(input): input is ObjectWithEveryTypeEnumerator {
            return (
                typeof input === 'string' &&
                $$FooObjectWithEveryTypeEnumeratorValues.includes(input as any)
            );
        },
        values: $$FooObjectWithEveryTypeEnumeratorValues,
        fromSerialValue(input): FooObjectWithEveryTypeEnumerator {
            if (
                $$FooObjectWithEveryTypeEnumeratorValues.includes(input as any)
            ) {
                return input as FooObjectWithEveryTypeEnumerator;
            }
            if (
                $$FooObjectWithEveryTypeEnumeratorValues.includes(
                    input.toLowerCase() as any,
                )
            ) {
                return input.toLowerCase() as FooObjectWithEveryTypeEnumerator;
            }
            if (
                $$FooObjectWithEveryTypeEnumeratorValues.includes(
                    input.toUpperCase() as any,
                )
            ) {
                return input.toUpperCase() as FooObjectWithEveryTypeEnumerator;
            }
            return 'A';
        },
    };

export interface FooObjectWithEveryTypeObject {
    string: string;
    boolean: boolean;
    timestamp: Date;
}
export const $$FooObjectWithEveryTypeObject: ArriModelValidator<FooObjectWithEveryTypeObject> =
    {
        new(): FooObjectWithEveryTypeObject {
            return {
                string: '',
                boolean: false,
                timestamp: new Date(),
            };
        },
        validate(input): input is FooObjectWithEveryTypeObject {
            return (
                isObject(input) &&
                typeof input.string === 'string' &&
                typeof input.boolean === 'boolean' &&
                input.timestamp instanceof Date
            );
        },
        fromJson(input): FooObjectWithEveryTypeObject {
            let _string: string;
            if (typeof input.string === 'string') {
                _string = input.string;
            } else {
                _string = '';
            }
            let _boolean: boolean;
            if (typeof input.boolean === 'boolean') {
                _boolean = input.boolean;
            } else {
                _boolean = false;
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            return {
                string: _string,
                boolean: _boolean,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): FooObjectWithEveryTypeObject {
            return $$FooObjectWithEveryTypeObject.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"string":';
            json += serializeString(input.string);
            json += ',"boolean":';
            json += `${input.boolean}`;
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`string=${input.string}`);
            queryParts.push(`boolean=${input.boolean}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            return queryParts.join('&');
        },
    };

export type FooObjectWithEveryTypeDiscriminator =
    | FooObjectWithEveryTypeDiscriminatorA
    | FooObjectWithEveryTypeDiscriminatorB;
export const $$FooObjectWithEveryTypeDiscriminator: ArriModelValidator<FooObjectWithEveryTypeDiscriminator> =
    {
        new(): FooObjectWithEveryTypeDiscriminator {
            return $$FooObjectWithEveryTypeDiscriminatorA.new();
        },
        validate(input): input is FooObjectWithEveryTypeDiscriminator {
            if (!isObject(input)) {
                return false;
            }
            if (typeof input.type !== 'string') {
                return false;
            }
            switch (input.type) {
                case 'A':
                    return $$FooObjectWithEveryTypeDiscriminatorA.validate(
                        input,
                    );
                case 'B':
                    return $$FooObjectWithEveryTypeDiscriminatorB.validate(
                        input,
                    );
                default:
                    return false;
            }
        },
        fromJson(input): FooObjectWithEveryTypeDiscriminator {
            switch (input.type) {
                case 'A':
                    return $$FooObjectWithEveryTypeDiscriminatorA.fromJson(
                        input,
                    );
                case 'B':
                    return $$FooObjectWithEveryTypeDiscriminatorB.fromJson(
                        input,
                    );
                default:
                    return $$FooObjectWithEveryTypeDiscriminatorA.new();
            }
        },
        fromJsonString(input): FooObjectWithEveryTypeDiscriminator {
            return $$FooObjectWithEveryTypeDiscriminator.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            switch (input.type) {
                case 'A':
                    return $$FooObjectWithEveryTypeDiscriminatorA.toJsonString(
                        input,
                    );
                case 'B':
                    return $$FooObjectWithEveryTypeDiscriminatorB.toJsonString(
                        input,
                    );
                default:
                    throw new Error(`Unhandled case "${(input as any).type}"`);
            }
        },
        toUrlQueryString(input): string {
            switch (input.type) {
                case 'A':
                    return $$FooObjectWithEveryTypeDiscriminatorA.toUrlQueryString(
                        input,
                    );
                case 'B':
                    return $$FooObjectWithEveryTypeDiscriminatorB.toUrlQueryString(
                        input,
                    );
                default:
                    throw new Error('Unhandled case');
            }
        },
    };
export interface FooObjectWithEveryTypeDiscriminatorA {
    type: 'A';
    title: string;
}
const $$FooObjectWithEveryTypeDiscriminatorA: ArriModelValidator<FooObjectWithEveryTypeDiscriminatorA> =
    {
        new(): FooObjectWithEveryTypeDiscriminatorA {
            return {
                type: 'A',
                title: '',
            };
        },
        validate(input): input is FooObjectWithEveryTypeDiscriminatorA {
            return (
                isObject(input) &&
                input.type === 'A' &&
                typeof input.title === 'string'
            );
        },
        fromJson(input): FooObjectWithEveryTypeDiscriminatorA {
            const _type = 'A';
            let _title: string;
            if (typeof input.title === 'string') {
                _title = input.title;
            } else {
                _title = '';
            }
            return {
                type: _type,
                title: _title,
            };
        },
        fromJsonString(input): FooObjectWithEveryTypeDiscriminatorA {
            return $$FooObjectWithEveryTypeDiscriminatorA.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"type":"A"';
            json += ',"title":';
            json += serializeString(input.title);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('type=A');
            queryParts.push(`title=${input.title}`);
            return queryParts.join('&');
        },
    };

export interface FooObjectWithEveryTypeDiscriminatorB {
    type: 'B';
    title: string;
    description: string;
}
const $$FooObjectWithEveryTypeDiscriminatorB: ArriModelValidator<FooObjectWithEveryTypeDiscriminatorB> =
    {
        new(): FooObjectWithEveryTypeDiscriminatorB {
            return {
                type: 'B',
                title: '',
                description: '',
            };
        },
        validate(input): input is FooObjectWithEveryTypeDiscriminatorB {
            return (
                isObject(input) &&
                input.type === 'B' &&
                typeof input.title === 'string' &&
                typeof input.description === 'string'
            );
        },
        fromJson(input): FooObjectWithEveryTypeDiscriminatorB {
            const _type = 'B';
            let _title: string;
            if (typeof input.title === 'string') {
                _title = input.title;
            } else {
                _title = '';
            }
            let _description: string;
            if (typeof input.description === 'string') {
                _description = input.description;
            } else {
                _description = '';
            }
            return {
                type: _type,
                title: _title,
                description: _description,
            };
        },
        fromJsonString(input): FooObjectWithEveryTypeDiscriminatorB {
            return $$FooObjectWithEveryTypeDiscriminatorB.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"type":"B"';
            json += ',"title":';
            json += serializeString(input.title);
            json += ',"description":';
            json += serializeString(input.description);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('type=B');
            queryParts.push(`title=${input.title}`);
            queryParts.push(`description=${input.description}`);
            return queryParts.join('&');
        },
    };

export interface FooObjectWithEveryTypeNestedObject {
    id: string;
    timestamp: Date;
    data: FooObjectWithEveryTypeNestedObjectData;
}
export const $$FooObjectWithEveryTypeNestedObject: ArriModelValidator<FooObjectWithEveryTypeNestedObject> =
    {
        new(): FooObjectWithEveryTypeNestedObject {
            return {
                id: '',
                timestamp: new Date(),
                data: $$FooObjectWithEveryTypeNestedObjectData.new(),
            };
        },
        validate(input): input is FooObjectWithEveryTypeNestedObject {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                input.timestamp instanceof Date &&
                $$FooObjectWithEveryTypeNestedObjectData.validate(input.data)
            );
        },
        fromJson(input): FooObjectWithEveryTypeNestedObject {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            let _data: FooObjectWithEveryTypeNestedObjectData;
            if (isObject(input.data)) {
                _data = $$FooObjectWithEveryTypeNestedObjectData.fromJson(
                    input.data,
                );
            } else {
                _data = $$FooObjectWithEveryTypeNestedObjectData.new();
            }
            return {
                id: _id,
                timestamp: _timestamp,
                data: _data,
            };
        },
        fromJsonString(input): FooObjectWithEveryTypeNestedObject {
            return $$FooObjectWithEveryTypeNestedObject.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += ',"data":';
            json += $$FooObjectWithEveryTypeNestedObjectData.toJsonString(
                input.data,
            );
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryTypeNestedObject/data.',
            );
            return queryParts.join('&');
        },
    };

export interface FooObjectWithEveryTypeNestedObjectData {
    id: string;
    timestamp: Date;
    data: FooObjectWithEveryTypeNestedObjectDataData;
}
export const $$FooObjectWithEveryTypeNestedObjectData: ArriModelValidator<FooObjectWithEveryTypeNestedObjectData> =
    {
        new(): FooObjectWithEveryTypeNestedObjectData {
            return {
                id: '',
                timestamp: new Date(),
                data: $$FooObjectWithEveryTypeNestedObjectDataData.new(),
            };
        },
        validate(input): input is FooObjectWithEveryTypeNestedObjectData {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                input.timestamp instanceof Date &&
                $$FooObjectWithEveryTypeNestedObjectDataData.validate(
                    input.data,
                )
            );
        },
        fromJson(input): FooObjectWithEveryTypeNestedObjectData {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            let _data: FooObjectWithEveryTypeNestedObjectDataData;
            if (isObject(input.data)) {
                _data = $$FooObjectWithEveryTypeNestedObjectDataData.fromJson(
                    input.data,
                );
            } else {
                _data = $$FooObjectWithEveryTypeNestedObjectDataData.new();
            }
            return {
                id: _id,
                timestamp: _timestamp,
                data: _data,
            };
        },
        fromJsonString(input): FooObjectWithEveryTypeNestedObjectData {
            return $$FooObjectWithEveryTypeNestedObjectData.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += ',"data":';
            json += $$FooObjectWithEveryTypeNestedObjectDataData.toJsonString(
                input.data,
            );
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryTypeNestedObjectData/data.',
            );
            return queryParts.join('&');
        },
    };

export interface FooObjectWithEveryTypeNestedObjectDataData {
    id: string;
    timestamp: Date;
}
export const $$FooObjectWithEveryTypeNestedObjectDataData: ArriModelValidator<FooObjectWithEveryTypeNestedObjectDataData> =
    {
        new(): FooObjectWithEveryTypeNestedObjectDataData {
            return {
                id: '',
                timestamp: new Date(),
            };
        },
        validate(input): input is FooObjectWithEveryTypeNestedObjectDataData {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                input.timestamp instanceof Date
            );
        },
        fromJson(input): FooObjectWithEveryTypeNestedObjectDataData {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            return {
                id: _id,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): FooObjectWithEveryTypeNestedObjectDataData {
            return $$FooObjectWithEveryTypeNestedObjectDataData.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            return queryParts.join('&');
        },
    };

export interface FooObjectWithEveryTypeNestedArrayElementElement {
    id: string;
    timestamp: Date;
}
export const $$FooObjectWithEveryTypeNestedArrayElementElement: ArriModelValidator<FooObjectWithEveryTypeNestedArrayElementElement> =
    {
        new(): FooObjectWithEveryTypeNestedArrayElementElement {
            return {
                id: '',
                timestamp: new Date(),
            };
        },
        validate(
            input,
        ): input is FooObjectWithEveryTypeNestedArrayElementElement {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                input.timestamp instanceof Date
            );
        },
        fromJson(input): FooObjectWithEveryTypeNestedArrayElementElement {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            return {
                id: _id,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): FooObjectWithEveryTypeNestedArrayElementElement {
            return $$FooObjectWithEveryTypeNestedArrayElementElement.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            return queryParts.join('&');
        },
    };

export interface FooObjectWithEveryNullableType {
    any: any;
    boolean: boolean | null;
    string: string | null;
    timestamp: Date | null;
    float32: number | null;
    float64: number | null;
    int8: number | null;
    uint8: number | null;
    int16: number | null;
    uint16: number | null;
    int32: number | null;
    uint32: number | null;
    int64: bigint | null;
    uint64: bigint | null;
    enumerator: FooObjectWithEveryNullableTypeEnumerator | null;
    array: (boolean | null)[] | null;
    object: FooObjectWithEveryNullableTypeObject | null;
    record: Record<string, bigint | null> | null;
    discriminator: FooObjectWithEveryNullableTypeDiscriminator | null;
    nestedObject: FooObjectWithEveryNullableTypeNestedObject | null;
    nestedArray:
        | (
              | (FooObjectWithEveryNullableTypeNestedArrayElementElement | null)[]
              | null
          )[]
        | null;
}
export const $$FooObjectWithEveryNullableType: ArriModelValidator<FooObjectWithEveryNullableType> =
    {
        new(): FooObjectWithEveryNullableType {
            return {
                any: null,
                boolean: null,
                string: null,
                timestamp: null,
                float32: null,
                float64: null,
                int8: null,
                uint8: null,
                int16: null,
                uint16: null,
                int32: null,
                uint32: null,
                int64: null,
                uint64: null,
                enumerator: null,
                array: null,
                object: null,
                record: null,
                discriminator: null,
                nestedObject: null,
                nestedArray: null,
            };
        },
        validate(input): input is FooObjectWithEveryNullableType {
            return (
                isObject(input) &&
                true &&
                (typeof input.boolean === 'boolean' ||
                    input.boolean === null) &&
                (typeof input.string === 'string' || input.string === null) &&
                (input.timestamp instanceof Date || input.timestamp === null) &&
                (typeof input.float32 === 'number' || input.float32 === null) &&
                (typeof input.float64 === 'number' || input.float64 === null) &&
                ((typeof input.int8 === 'number' &&
                    Number.isInteger(input.int8) &&
                    input.int8 >= INT8_MIN &&
                    input.int8 <= INT8_MAX) ||
                    input.int8 === null) &&
                ((typeof input.uint8 === 'number' &&
                    Number.isInteger(input.uint8) &&
                    input.uint8 >= 0 &&
                    input.uint8 <= UINT8_MAX) ||
                    input.uint8 === null) &&
                ((typeof input.int16 === 'number' &&
                    Number.isInteger(input.int16) &&
                    input.int16 >= INT16_MIN &&
                    input.int16 <= INT16_MAX) ||
                    input.int16 === null) &&
                ((typeof input.uint16 === 'number' &&
                    Number.isInteger(input.uint16) &&
                    input.uint16 >= 0 &&
                    input.uint16 <= UINT16_MAX) ||
                    input.uint16 === null) &&
                ((typeof input.int32 === 'number' &&
                    Number.isInteger(input.int32) &&
                    input.int32 >= INT32_MIN &&
                    input.int32 <= INT32_MAX) ||
                    input.int32 === null) &&
                ((typeof input.uint32 === 'number' &&
                    Number.isInteger(input.uint32) &&
                    input.uint32 >= 0 &&
                    input.uint32 <= UINT32_MAX) ||
                    input.uint32 === null) &&
                ((typeof input.int64 === 'bigint' &&
                    input.int64 >= INT64_MIN &&
                    input.int64 <= INT64_MAX) ||
                    input.int64 === null) &&
                ((typeof input.uint64 === 'bigint' &&
                    input.uint64 >= BigInt(0) &&
                    input.uint64 <= UINT64_MAX) ||
                    input.uint64 === null) &&
                ($$FooObjectWithEveryNullableTypeEnumerator.validate(
                    input.enumerator,
                ) ||
                    input.enumerator === null) &&
                ((Array.isArray(input.array) &&
                    input.array.every(
                        (_element) =>
                            typeof _element === 'boolean' || _element === null,
                    )) ||
                    input.array === null) &&
                ($$FooObjectWithEveryNullableTypeObject.validate(
                    input.object,
                ) ||
                    input.object === null) &&
                ((isObject(input.record) &&
                    Object.values(input.record).every(
                        (_value) =>
                            (typeof _value === 'bigint' &&
                                _value >= BigInt(0) &&
                                _value <= UINT64_MAX) ||
                            _value === null,
                    )) ||
                    input.record === null) &&
                ($$FooObjectWithEveryNullableTypeDiscriminator.validate(
                    input.discriminator,
                ) ||
                    input.discriminator === null) &&
                ($$FooObjectWithEveryNullableTypeNestedObject.validate(
                    input.nestedObject,
                ) ||
                    input.nestedObject === null) &&
                ((Array.isArray(input.nestedArray) &&
                    input.nestedArray.every(
                        (_element) =>
                            (Array.isArray(_element) &&
                                _element.every(
                                    (_element) =>
                                        $$FooObjectWithEveryNullableTypeNestedArrayElementElement.validate(
                                            _element,
                                        ) || _element === null,
                                )) ||
                            _element === null,
                    )) ||
                    input.nestedArray === null)
            );
        },
        fromJson(input): FooObjectWithEveryNullableType {
            let _any: any;
            _any = input.any;
            let _boolean: boolean | null;
            if (typeof input.boolean === 'boolean') {
                _boolean = input.boolean;
            } else {
                _boolean = null;
            }
            let _string: string | null;
            if (typeof input.string === 'string') {
                _string = input.string;
            } else {
                _string = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            let _float32: number | null;
            if (typeof input.float32 === 'number') {
                _float32 = input.float32;
            } else {
                _float32 = null;
            }
            let _float64: number | null;
            if (typeof input.float64 === 'number') {
                _float64 = input.float64;
            } else {
                _float64 = null;
            }
            let _int8: number | null;
            if (
                typeof input.int8 === 'number' &&
                Number.isInteger(input.int8) &&
                input.int8 >= INT8_MIN &&
                input.int8 <= INT8_MAX
            ) {
                _int8 = input.int8;
            } else {
                _int8 = null;
            }
            let _uint8: number | null;
            if (
                typeof input.uint8 === 'number' &&
                Number.isInteger(input.uint8) &&
                input.uint8 >= 0 &&
                input.uint8 <= UINT8_MAX
            ) {
                _uint8 = input.uint8;
            } else {
                _uint8 = null;
            }
            let _int16: number | null;
            if (
                typeof input.int16 === 'number' &&
                Number.isInteger(input.int16) &&
                input.int16 >= INT16_MIN &&
                input.int16 <= INT16_MAX
            ) {
                _int16 = input.int16;
            } else {
                _int16 = null;
            }
            let _uint16: number | null;
            if (
                typeof input.uint16 === 'number' &&
                Number.isInteger(input.uint16) &&
                input.uint16 >= 0 &&
                input.uint16 <= UINT16_MAX
            ) {
                _uint16 = input.uint16;
            } else {
                _uint16 = null;
            }
            let _int32: number | null;
            if (
                typeof input.int32 === 'number' &&
                Number.isInteger(input.int32) &&
                input.int32 >= INT32_MIN &&
                input.int32 <= INT32_MAX
            ) {
                _int32 = input.int32;
            } else {
                _int32 = null;
            }
            let _uint32: number | null;
            if (
                typeof input.uint32 === 'number' &&
                Number.isInteger(input.uint32) &&
                input.uint32 >= 0 &&
                input.uint32 <= UINT32_MAX
            ) {
                _uint32 = input.uint32;
            } else {
                _uint32 = null;
            }
            let _int64: bigint | null;
            if (typeof input.int64 === 'string') {
                _int64 = BigInt(input.int64);
            } else if (typeof input.int64 === 'bigint') {
                _int64 = input.int64;
            } else {
                _int64 = null;
            }
            let _uint64: bigint | null;
            if (
                typeof input.uint64 === 'string' &&
                BigInt(input.uint64) >= BigInt(0)
            ) {
                _uint64 = BigInt(input.uint64);
            } else if (
                typeof input.uint64 === 'bigint' &&
                input.uint64 >= BigInt(0)
            ) {
                _uint64 = input.uint64;
            } else {
                _uint64 = null;
            }
            let _enumerator: FooObjectWithEveryNullableTypeEnumerator | null;
            if (typeof input.enumerator === 'string') {
                _enumerator =
                    $$FooObjectWithEveryNullableTypeEnumerator.fromSerialValue(
                        input.enumerator,
                    );
            } else {
                _enumerator = null;
            }
            let _array: (boolean | null)[] | null;
            if (Array.isArray(input.array)) {
                _array = [];
                for (const _arrayEl of input.array) {
                    let _arrayElValue: boolean | null;
                    if (typeof _arrayEl === 'boolean') {
                        _arrayElValue = _arrayEl;
                    } else {
                        _arrayElValue = null;
                    }
                    _array.push(_arrayElValue);
                }
            } else {
                _array = null;
            }
            let _object: FooObjectWithEveryNullableTypeObject | null;
            if (isObject(input.object)) {
                _object = $$FooObjectWithEveryNullableTypeObject.fromJson(
                    input.object,
                );
            } else {
                _object = null;
            }
            let _record: Record<string, bigint | null> | null;
            if (isObject(input.record)) {
                _record = {};
                for (const [_key, _value] of Object.entries(input.record)) {
                    let _recordValue: bigint | null;
                    if (
                        typeof _value === 'string' &&
                        BigInt(_value) >= BigInt(0)
                    ) {
                        _recordValue = BigInt(_value);
                    } else if (
                        typeof _value === 'bigint' &&
                        _value >= BigInt(0)
                    ) {
                        _recordValue = _value;
                    } else {
                        _recordValue = null;
                    }
                    _record[_key] = _recordValue;
                }
            } else {
                _record = null;
            }
            let _discriminator: FooObjectWithEveryNullableTypeDiscriminator | null;
            if (isObject(input.discriminator)) {
                _discriminator =
                    $$FooObjectWithEveryNullableTypeDiscriminator.fromJson(
                        input.discriminator,
                    );
            } else {
                _discriminator = null;
            }
            let _nestedObject: FooObjectWithEveryNullableTypeNestedObject | null;
            if (isObject(input.nestedObject)) {
                _nestedObject =
                    $$FooObjectWithEveryNullableTypeNestedObject.fromJson(
                        input.nestedObject,
                    );
            } else {
                _nestedObject = null;
            }
            let _nestedArray:
                | (
                      | (FooObjectWithEveryNullableTypeNestedArrayElementElement | null)[]
                      | null
                  )[]
                | null;
            if (Array.isArray(input.nestedArray)) {
                _nestedArray = [];
                for (const _nestedArrayEl of input.nestedArray) {
                    let _nestedArrayElValue:
                        | (FooObjectWithEveryNullableTypeNestedArrayElementElement | null)[]
                        | null;
                    if (Array.isArray(_nestedArrayEl)) {
                        _nestedArrayElValue = [];
                        for (const _nestedArrayElValueEl of _nestedArrayEl) {
                            let _nestedArrayElValueElValue: FooObjectWithEveryNullableTypeNestedArrayElementElement | null;
                            if (isObject(_nestedArrayElValueEl)) {
                                _nestedArrayElValueElValue =
                                    $$FooObjectWithEveryNullableTypeNestedArrayElementElement.fromJson(
                                        _nestedArrayElValueEl,
                                    );
                            } else {
                                _nestedArrayElValueElValue = null;
                            }
                            _nestedArrayElValue.push(
                                _nestedArrayElValueElValue,
                            );
                        }
                    } else {
                        _nestedArrayElValue = null;
                    }
                    _nestedArray.push(_nestedArrayElValue);
                }
            } else {
                _nestedArray = null;
            }
            return {
                any: _any,
                boolean: _boolean,
                string: _string,
                timestamp: _timestamp,
                float32: _float32,
                float64: _float64,
                int8: _int8,
                uint8: _uint8,
                int16: _int16,
                uint16: _uint16,
                int32: _int32,
                uint32: _uint32,
                int64: _int64,
                uint64: _uint64,
                enumerator: _enumerator,
                array: _array,
                object: _object,
                record: _record,
                discriminator: _discriminator,
                nestedObject: _nestedObject,
                nestedArray: _nestedArray,
            };
        },
        fromJsonString(input): FooObjectWithEveryNullableType {
            return $$FooObjectWithEveryNullableType.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"any":';
            json += JSON.stringify(input.any);
            json += ',"boolean":';
            json += `${input.boolean}`;
            json += ',"string":';
            if (typeof input.string === 'string') {
                json += serializeString(input.string);
            } else {
                json += 'null';
            }
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += 'null';
            }
            json += ',"float32":';
            json += `${input.float32}`;
            json += ',"float64":';
            json += `${input.float64}`;
            json += ',"int8":';
            json += `${input.int8}`;
            json += ',"uint8":';
            json += `${input.uint8}`;
            json += ',"int16":';
            json += `${input.int16}`;
            json += ',"uint16":';
            json += `${input.uint16}`;
            json += ',"int32":';
            json += `${input.int32}`;
            json += ',"uint32":';
            json += `${input.uint32}`;
            json += ',"int64":';
            if (typeof input.int64 === 'bigint') {
                json += `"${input.int64}"`;
            } else {
                json += 'null';
            }
            json += ',"uint64":';
            if (typeof input.uint64 === 'bigint') {
                json += `"${input.uint64}"`;
            } else {
                json += 'null';
            }
            json += ',"enumerator":';
            if (typeof input.enumerator === 'string') {
                json += `"${input.enumerator}"`;
            } else {
                json += 'null';
            }
            json += ',"array":';
            if (input.array !== null) {
                json += '[';
                for (let i = 0; i < input.array.length; i++) {
                    if (i !== 0) json += ',';
                    const _inputArrayEl = input.array[i];
                    json += `${_inputArrayEl}`;
                }
                json += ']';
            } else {
                json += 'null';
            }
            json += ',"object":';
            if (input.object !== null) {
                json += $$FooObjectWithEveryNullableTypeObject.toJsonString(
                    input.object,
                );
            } else {
                json += 'null';
            }
            json += ',"record":';
            if (input.record !== null) {
                json += '{';
                let _recordPropertyCount = 0;
                for (const [_key, _value] of Object.entries(input.record)) {
                    if (_recordPropertyCount !== 0) {
                        json += ',';
                    }
                    json += `${serializeString(_key)}:`;
                    if (typeof _value === 'bigint') {
                        json += `"${_value}"`;
                    } else {
                        json += 'null';
                    }
                    _recordPropertyCount++;
                }
                json += '}';
            } else {
                json += 'null';
            }
            json += ',"discriminator":';
            if (input.discriminator != null) {
                json +=
                    $$FooObjectWithEveryNullableTypeDiscriminator.toJsonString(
                        input.discriminator,
                    );
            } else {
                json += 'null';
            }
            json += ',"nestedObject":';
            if (input.nestedObject !== null) {
                json +=
                    $$FooObjectWithEveryNullableTypeNestedObject.toJsonString(
                        input.nestedObject,
                    );
            } else {
                json += 'null';
            }
            json += ',"nestedArray":';
            if (input.nestedArray !== null) {
                json += '[';
                for (let i = 0; i < input.nestedArray.length; i++) {
                    if (i !== 0) json += ',';
                    const _inputNestedArrayEl = input.nestedArray[i];
                    if (_inputNestedArrayEl !== null) {
                        json += '[';
                        for (let i = 0; i < _inputNestedArrayEl.length; i++) {
                            if (i !== 0) json += ',';
                            const _inputNestedArrayElEl =
                                _inputNestedArrayEl[i];
                            if (_inputNestedArrayElEl !== null) {
                                json +=
                                    $$FooObjectWithEveryNullableTypeNestedArrayElementElement.toJsonString(
                                        _inputNestedArrayElEl,
                                    );
                            } else {
                                json += 'null';
                            }
                        }
                        json += ']';
                    } else {
                        json += 'null';
                    }
                }
                json += ']';
            } else {
                json += 'null';
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            console.warn(
                "[WARNING] Cannot serialize any's to query string. Skipping property at /ObjectWithEveryNullableType/any.",
            );
            queryParts.push(`boolean=${input.boolean}`);
            queryParts.push(`string=${input.string}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            queryParts.push(`float32=${input.float32}`);
            queryParts.push(`float64=${input.float64}`);
            queryParts.push(`int8=${input.int8}`);
            queryParts.push(`uint8=${input.uint8}`);
            queryParts.push(`int16=${input.int16}`);
            queryParts.push(`uint16=${input.uint16}`);
            queryParts.push(`int32=${input.int32}`);
            queryParts.push(`uint32=${input.uint32}`);
            queryParts.push(`int64=${input.int64}`);
            queryParts.push(`uint64=${input.uint64}`);
            queryParts.push(`enumerator=${input.enumerator}`);
            console.warn(
                '[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryNullableType/array.',
            );
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryNullableType/object.',
            );
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryNullableType/record.',
            );
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryNullableType/discriminator.',
            );
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryNullableType/nestedObject.',
            );
            console.warn(
                '[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryNullableType/nestedArray.',
            );
            return queryParts.join('&');
        },
    };

export type FooObjectWithEveryNullableTypeEnumerator =
    (typeof $$FooObjectWithEveryNullableTypeEnumeratorValues)[number];
const $$FooObjectWithEveryNullableTypeEnumeratorValues = [
    'A',
    'B',
    'C',
] as const;
export const $$FooObjectWithEveryNullableTypeEnumerator: ArriEnumValidator<FooObjectWithEveryNullableTypeEnumerator> =
    {
        new(): FooObjectWithEveryNullableTypeEnumerator {
            return $$FooObjectWithEveryNullableTypeEnumeratorValues[0];
        },
        validate(input): input is ObjectWithEveryNullableTypeEnumerator {
            return (
                typeof input === 'string' &&
                $$FooObjectWithEveryNullableTypeEnumeratorValues.includes(
                    input as any,
                )
            );
        },
        values: $$FooObjectWithEveryNullableTypeEnumeratorValues,
        fromSerialValue(input): FooObjectWithEveryNullableTypeEnumerator {
            if (
                $$FooObjectWithEveryNullableTypeEnumeratorValues.includes(
                    input as any,
                )
            ) {
                return input as FooObjectWithEveryNullableTypeEnumerator;
            }
            if (
                $$FooObjectWithEveryNullableTypeEnumeratorValues.includes(
                    input.toLowerCase() as any,
                )
            ) {
                return input.toLowerCase() as FooObjectWithEveryNullableTypeEnumerator;
            }
            if (
                $$FooObjectWithEveryNullableTypeEnumeratorValues.includes(
                    input.toUpperCase() as any,
                )
            ) {
                return input.toUpperCase() as FooObjectWithEveryNullableTypeEnumerator;
            }
            return 'A';
        },
    };

export interface FooObjectWithEveryNullableTypeObject {
    string: string | null;
    boolean: boolean | null;
    timestamp: Date | null;
}
export const $$FooObjectWithEveryNullableTypeObject: ArriModelValidator<FooObjectWithEveryNullableTypeObject> =
    {
        new(): FooObjectWithEveryNullableTypeObject {
            return {
                string: null,
                boolean: null,
                timestamp: null,
            };
        },
        validate(input): input is FooObjectWithEveryNullableTypeObject {
            return (
                isObject(input) &&
                (typeof input.string === 'string' || input.string === null) &&
                (typeof input.boolean === 'boolean' ||
                    input.boolean === null) &&
                (input.timestamp instanceof Date || input.timestamp === null)
            );
        },
        fromJson(input): FooObjectWithEveryNullableTypeObject {
            let _string: string | null;
            if (typeof input.string === 'string') {
                _string = input.string;
            } else {
                _string = null;
            }
            let _boolean: boolean | null;
            if (typeof input.boolean === 'boolean') {
                _boolean = input.boolean;
            } else {
                _boolean = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            return {
                string: _string,
                boolean: _boolean,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): FooObjectWithEveryNullableTypeObject {
            return $$FooObjectWithEveryNullableTypeObject.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"string":';
            if (typeof input.string === 'string') {
                json += serializeString(input.string);
            } else {
                json += 'null';
            }
            json += ',"boolean":';
            json += `${input.boolean}`;
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += 'null';
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`string=${input.string}`);
            queryParts.push(`boolean=${input.boolean}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            return queryParts.join('&');
        },
    };

export type FooObjectWithEveryNullableTypeDiscriminator =
    | FooObjectWithEveryNullableTypeDiscriminatorA
    | FooObjectWithEveryNullableTypeDiscriminatorB;
export const $$FooObjectWithEveryNullableTypeDiscriminator: ArriModelValidator<FooObjectWithEveryNullableTypeDiscriminator> =
    {
        new(): FooObjectWithEveryNullableTypeDiscriminator {
            return $$FooObjectWithEveryNullableTypeDiscriminatorA.new();
        },
        validate(input): input is FooObjectWithEveryNullableTypeDiscriminator {
            if (!isObject(input)) {
                return false;
            }
            if (typeof input.type !== 'string') {
                return false;
            }
            switch (input.type) {
                case 'A':
                    return $$FooObjectWithEveryNullableTypeDiscriminatorA.validate(
                        input,
                    );
                case 'B':
                    return $$FooObjectWithEveryNullableTypeDiscriminatorB.validate(
                        input,
                    );
                default:
                    return false;
            }
        },
        fromJson(input): FooObjectWithEveryNullableTypeDiscriminator {
            switch (input.type) {
                case 'A':
                    return $$FooObjectWithEveryNullableTypeDiscriminatorA.fromJson(
                        input,
                    );
                case 'B':
                    return $$FooObjectWithEveryNullableTypeDiscriminatorB.fromJson(
                        input,
                    );
                default:
                    return $$FooObjectWithEveryNullableTypeDiscriminatorA.new();
            }
        },
        fromJsonString(input): FooObjectWithEveryNullableTypeDiscriminator {
            return $$FooObjectWithEveryNullableTypeDiscriminator.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            switch (input.type) {
                case 'A':
                    return $$FooObjectWithEveryNullableTypeDiscriminatorA.toJsonString(
                        input,
                    );
                case 'B':
                    return $$FooObjectWithEveryNullableTypeDiscriminatorB.toJsonString(
                        input,
                    );
                default:
                    throw new Error(`Unhandled case "${(input as any).type}"`);
            }
        },
        toUrlQueryString(input): string {
            switch (input.type) {
                case 'A':
                    return $$FooObjectWithEveryNullableTypeDiscriminatorA.toUrlQueryString(
                        input,
                    );
                case 'B':
                    return $$FooObjectWithEveryNullableTypeDiscriminatorB.toUrlQueryString(
                        input,
                    );
                default:
                    throw new Error('Unhandled case');
            }
        },
    };
export interface FooObjectWithEveryNullableTypeDiscriminatorA {
    type: 'A';
    title: string | null;
}
const $$FooObjectWithEveryNullableTypeDiscriminatorA: ArriModelValidator<FooObjectWithEveryNullableTypeDiscriminatorA> =
    {
        new(): FooObjectWithEveryNullableTypeDiscriminatorA {
            return {
                type: 'A',
                title: null,
            };
        },
        validate(input): input is FooObjectWithEveryNullableTypeDiscriminatorA {
            return (
                isObject(input) &&
                input.type === 'A' &&
                (typeof input.title === 'string' || input.title === null)
            );
        },
        fromJson(input): FooObjectWithEveryNullableTypeDiscriminatorA {
            const _type = 'A';
            let _title: string | null;
            if (typeof input.title === 'string') {
                _title = input.title;
            } else {
                _title = null;
            }
            return {
                type: _type,
                title: _title,
            };
        },
        fromJsonString(input): FooObjectWithEveryNullableTypeDiscriminatorA {
            return $$FooObjectWithEveryNullableTypeDiscriminatorA.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"type":"A"';
            json += ',"title":';
            if (typeof input.title === 'string') {
                json += serializeString(input.title);
            } else {
                json += 'null';
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('type=A');
            queryParts.push(`title=${input.title}`);
            return queryParts.join('&');
        },
    };

export interface FooObjectWithEveryNullableTypeDiscriminatorB {
    type: 'B';
    title: string | null;
    description: string | null;
}
const $$FooObjectWithEveryNullableTypeDiscriminatorB: ArriModelValidator<FooObjectWithEveryNullableTypeDiscriminatorB> =
    {
        new(): FooObjectWithEveryNullableTypeDiscriminatorB {
            return {
                type: 'B',
                title: null,
                description: null,
            };
        },
        validate(input): input is FooObjectWithEveryNullableTypeDiscriminatorB {
            return (
                isObject(input) &&
                input.type === 'B' &&
                (typeof input.title === 'string' || input.title === null) &&
                (typeof input.description === 'string' ||
                    input.description === null)
            );
        },
        fromJson(input): FooObjectWithEveryNullableTypeDiscriminatorB {
            const _type = 'B';
            let _title: string | null;
            if (typeof input.title === 'string') {
                _title = input.title;
            } else {
                _title = null;
            }
            let _description: string | null;
            if (typeof input.description === 'string') {
                _description = input.description;
            } else {
                _description = null;
            }
            return {
                type: _type,
                title: _title,
                description: _description,
            };
        },
        fromJsonString(input): FooObjectWithEveryNullableTypeDiscriminatorB {
            return $$FooObjectWithEveryNullableTypeDiscriminatorB.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"type":"B"';
            json += ',"title":';
            if (typeof input.title === 'string') {
                json += serializeString(input.title);
            } else {
                json += 'null';
            }
            json += ',"description":';
            if (typeof input.description === 'string') {
                json += serializeString(input.description);
            } else {
                json += 'null';
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('type=B');
            queryParts.push(`title=${input.title}`);
            queryParts.push(`description=${input.description}`);
            return queryParts.join('&');
        },
    };

export interface FooObjectWithEveryNullableTypeNestedObject {
    id: string | null;
    timestamp: Date | null;
    data: FooObjectWithEveryNullableTypeNestedObjectData | null;
}
export const $$FooObjectWithEveryNullableTypeNestedObject: ArriModelValidator<FooObjectWithEveryNullableTypeNestedObject> =
    {
        new(): FooObjectWithEveryNullableTypeNestedObject {
            return {
                id: null,
                timestamp: null,
                data: null,
            };
        },
        validate(input): input is FooObjectWithEveryNullableTypeNestedObject {
            return (
                isObject(input) &&
                (typeof input.id === 'string' || input.id === null) &&
                (input.timestamp instanceof Date || input.timestamp === null) &&
                ($$FooObjectWithEveryNullableTypeNestedObjectData.validate(
                    input.data,
                ) ||
                    input.data === null)
            );
        },
        fromJson(input): FooObjectWithEveryNullableTypeNestedObject {
            let _id: string | null;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            let _data: FooObjectWithEveryNullableTypeNestedObjectData | null;
            if (isObject(input.data)) {
                _data =
                    $$FooObjectWithEveryNullableTypeNestedObjectData.fromJson(
                        input.data,
                    );
            } else {
                _data = null;
            }
            return {
                id: _id,
                timestamp: _timestamp,
                data: _data,
            };
        },
        fromJsonString(input): FooObjectWithEveryNullableTypeNestedObject {
            return $$FooObjectWithEveryNullableTypeNestedObject.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            if (typeof input.id === 'string') {
                json += serializeString(input.id);
            } else {
                json += 'null';
            }
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += 'null';
            }
            json += ',"data":';
            if (input.data !== null) {
                json +=
                    $$FooObjectWithEveryNullableTypeNestedObjectData.toJsonString(
                        input.data,
                    );
            } else {
                json += 'null';
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryNullableTypeNestedObject/data.',
            );
            return queryParts.join('&');
        },
    };

export interface FooObjectWithEveryNullableTypeNestedObjectData {
    id: string | null;
    timestamp: Date | null;
    data: FooObjectWithEveryNullableTypeNestedObjectDataData | null;
}
export const $$FooObjectWithEveryNullableTypeNestedObjectData: ArriModelValidator<FooObjectWithEveryNullableTypeNestedObjectData> =
    {
        new(): FooObjectWithEveryNullableTypeNestedObjectData {
            return {
                id: null,
                timestamp: null,
                data: null,
            };
        },
        validate(
            input,
        ): input is FooObjectWithEveryNullableTypeNestedObjectData {
            return (
                isObject(input) &&
                (typeof input.id === 'string' || input.id === null) &&
                (input.timestamp instanceof Date || input.timestamp === null) &&
                ($$FooObjectWithEveryNullableTypeNestedObjectDataData.validate(
                    input.data,
                ) ||
                    input.data === null)
            );
        },
        fromJson(input): FooObjectWithEveryNullableTypeNestedObjectData {
            let _id: string | null;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            let _data: FooObjectWithEveryNullableTypeNestedObjectDataData | null;
            if (isObject(input.data)) {
                _data =
                    $$FooObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
                        input.data,
                    );
            } else {
                _data = null;
            }
            return {
                id: _id,
                timestamp: _timestamp,
                data: _data,
            };
        },
        fromJsonString(input): FooObjectWithEveryNullableTypeNestedObjectData {
            return $$FooObjectWithEveryNullableTypeNestedObjectData.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            if (typeof input.id === 'string') {
                json += serializeString(input.id);
            } else {
                json += 'null';
            }
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += 'null';
            }
            json += ',"data":';
            if (input.data !== null) {
                json +=
                    $$FooObjectWithEveryNullableTypeNestedObjectDataData.toJsonString(
                        input.data,
                    );
            } else {
                json += 'null';
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryNullableTypeNestedObjectData/data.',
            );
            return queryParts.join('&');
        },
    };

export interface FooObjectWithEveryNullableTypeNestedObjectDataData {
    id: string | null;
    timestamp: Date | null;
}
export const $$FooObjectWithEveryNullableTypeNestedObjectDataData: ArriModelValidator<FooObjectWithEveryNullableTypeNestedObjectDataData> =
    {
        new(): FooObjectWithEveryNullableTypeNestedObjectDataData {
            return {
                id: null,
                timestamp: null,
            };
        },
        validate(
            input,
        ): input is FooObjectWithEveryNullableTypeNestedObjectDataData {
            return (
                isObject(input) &&
                (typeof input.id === 'string' || input.id === null) &&
                (input.timestamp instanceof Date || input.timestamp === null)
            );
        },
        fromJson(input): FooObjectWithEveryNullableTypeNestedObjectDataData {
            let _id: string | null;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            return {
                id: _id,
                timestamp: _timestamp,
            };
        },
        fromJsonString(
            input,
        ): FooObjectWithEveryNullableTypeNestedObjectDataData {
            return $$FooObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            if (typeof input.id === 'string') {
                json += serializeString(input.id);
            } else {
                json += 'null';
            }
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += 'null';
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            return queryParts.join('&');
        },
    };

export interface FooObjectWithEveryNullableTypeNestedArrayElementElement {
    id: string | null;
    timestamp: Date | null;
}
export const $$FooObjectWithEveryNullableTypeNestedArrayElementElement: ArriModelValidator<FooObjectWithEveryNullableTypeNestedArrayElementElement> =
    {
        new(): FooObjectWithEveryNullableTypeNestedArrayElementElement {
            return {
                id: null,
                timestamp: null,
            };
        },
        validate(
            input,
        ): input is FooObjectWithEveryNullableTypeNestedArrayElementElement {
            return (
                isObject(input) &&
                (typeof input.id === 'string' || input.id === null) &&
                (input.timestamp instanceof Date || input.timestamp === null)
            );
        },
        fromJson(
            input,
        ): FooObjectWithEveryNullableTypeNestedArrayElementElement {
            let _id: string | null;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            return {
                id: _id,
                timestamp: _timestamp,
            };
        },
        fromJsonString(
            input,
        ): FooObjectWithEveryNullableTypeNestedArrayElementElement {
            return $$FooObjectWithEveryNullableTypeNestedArrayElementElement.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            if (typeof input.id === 'string') {
                json += serializeString(input.id);
            } else {
                json += 'null';
            }
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += 'null';
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            return queryParts.join('&');
        },
    };

export interface FooObjectWithPascalCaseKeys {
    createdAt: Date;
    displayName: string;
    phoneNumber: string | null;
    emailAddress?: string;
    isAdmin?: boolean;
}
export const $$FooObjectWithPascalCaseKeys: ArriModelValidator<FooObjectWithPascalCaseKeys> =
    {
        new(): FooObjectWithPascalCaseKeys {
            return {
                createdAt: new Date(),
                displayName: '',
                phoneNumber: null,
            };
        },
        validate(input): input is FooObjectWithPascalCaseKeys {
            return (
                isObject(input) &&
                input.createdAt instanceof Date &&
                typeof input.displayName === 'string' &&
                (typeof input.phoneNumber === 'string' ||
                    input.phoneNumber === null) &&
                (typeof input.emailAddress === 'string' ||
                    typeof input.emailAddress === 'undefined') &&
                (typeof input.isAdmin === 'boolean' ||
                    typeof input.isAdmin === 'undefined')
            );
        },
        fromJson(input): FooObjectWithPascalCaseKeys {
            let _CreatedAt: Date;
            if (typeof input.CreatedAt === 'string') {
                _CreatedAt = new Date(input.CreatedAt);
            } else if (input.CreatedAt instanceof Date) {
                _CreatedAt = input.CreatedAt;
            } else {
                _CreatedAt = new Date();
            }
            let _DisplayName: string;
            if (typeof input.DisplayName === 'string') {
                _DisplayName = input.DisplayName;
            } else {
                _DisplayName = '';
            }
            let _PhoneNumber: string | null;
            if (typeof input.PhoneNumber === 'string') {
                _PhoneNumber = input.PhoneNumber;
            } else {
                _PhoneNumber = null;
            }
            let _EmailAddress: string | undefined;
            if (typeof input.EmailAddress !== 'undefined') {
                if (typeof input.EmailAddress === 'string') {
                    _EmailAddress = input.EmailAddress;
                } else {
                    _EmailAddress = '';
                }
            }
            let _IsAdmin: boolean | undefined;
            if (typeof input.IsAdmin !== 'undefined') {
                if (typeof input.IsAdmin === 'boolean') {
                    _IsAdmin = input.IsAdmin;
                } else {
                    _IsAdmin = false;
                }
            }
            return {
                createdAt: _CreatedAt,
                displayName: _DisplayName,
                phoneNumber: _PhoneNumber,
                emailAddress: _EmailAddress,
                isAdmin: _IsAdmin,
            };
        },
        fromJsonString(input): FooObjectWithPascalCaseKeys {
            return $$FooObjectWithPascalCaseKeys.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"CreatedAt":';
            json += `"${input.createdAt.toISOString()}"`;
            json += ',"DisplayName":';
            json += serializeString(input.displayName);
            json += ',"PhoneNumber":';
            if (typeof input.phoneNumber === 'string') {
                json += serializeString(input.phoneNumber);
            } else {
                json += 'null';
            }
            if (typeof input.emailAddress !== 'undefined') {
                json += `,"EmailAddress":`;
                json += serializeString(input.emailAddress);
            }
            if (typeof input.isAdmin !== 'undefined') {
                json += `,"IsAdmin":`;
                json += `${input.isAdmin}`;
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`CreatedAt=${input.createdAt.toISOString()}`);
            queryParts.push(`DisplayName=${input.displayName}`);
            queryParts.push(`PhoneNumber=${input.phoneNumber}`);
            if (typeof input.emailAddress !== 'undefined') {
                queryParts.push(`EmailAddress=${input.emailAddress}`);
            }
            if (typeof input.isAdmin !== 'undefined') {
                queryParts.push(`IsAdmin=${input.isAdmin}`);
            }
            return queryParts.join('&');
        },
    };

export interface FooObjectWithSnakeCaseKeys {
    createdAt: Date;
    displayName: string;
    phoneNumber: string | null;
    emailAddress?: string;
    isAdmin?: boolean;
}
export const $$FooObjectWithSnakeCaseKeys: ArriModelValidator<FooObjectWithSnakeCaseKeys> =
    {
        new(): FooObjectWithSnakeCaseKeys {
            return {
                createdAt: new Date(),
                displayName: '',
                phoneNumber: null,
            };
        },
        validate(input): input is FooObjectWithSnakeCaseKeys {
            return (
                isObject(input) &&
                input.createdAt instanceof Date &&
                typeof input.displayName === 'string' &&
                (typeof input.phoneNumber === 'string' ||
                    input.phoneNumber === null) &&
                (typeof input.emailAddress === 'string' ||
                    typeof input.emailAddress === 'undefined') &&
                (typeof input.isAdmin === 'boolean' ||
                    typeof input.isAdmin === 'undefined')
            );
        },
        fromJson(input): FooObjectWithSnakeCaseKeys {
            let _created_at: Date;
            if (typeof input.created_at === 'string') {
                _created_at = new Date(input.created_at);
            } else if (input.created_at instanceof Date) {
                _created_at = input.created_at;
            } else {
                _created_at = new Date();
            }
            let _display_name: string;
            if (typeof input.display_name === 'string') {
                _display_name = input.display_name;
            } else {
                _display_name = '';
            }
            let _phone_number: string | null;
            if (typeof input.phone_number === 'string') {
                _phone_number = input.phone_number;
            } else {
                _phone_number = null;
            }
            let _email_address: string | undefined;
            if (typeof input.email_address !== 'undefined') {
                if (typeof input.email_address === 'string') {
                    _email_address = input.email_address;
                } else {
                    _email_address = '';
                }
            }
            let _is_admin: boolean | undefined;
            if (typeof input.is_admin !== 'undefined') {
                if (typeof input.is_admin === 'boolean') {
                    _is_admin = input.is_admin;
                } else {
                    _is_admin = false;
                }
            }
            return {
                createdAt: _created_at,
                displayName: _display_name,
                phoneNumber: _phone_number,
                emailAddress: _email_address,
                isAdmin: _is_admin,
            };
        },
        fromJsonString(input): FooObjectWithSnakeCaseKeys {
            return $$FooObjectWithSnakeCaseKeys.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"created_at":';
            json += `"${input.createdAt.toISOString()}"`;
            json += ',"display_name":';
            json += serializeString(input.displayName);
            json += ',"phone_number":';
            if (typeof input.phoneNumber === 'string') {
                json += serializeString(input.phoneNumber);
            } else {
                json += 'null';
            }
            if (typeof input.emailAddress !== 'undefined') {
                json += `,"email_address":`;
                json += serializeString(input.emailAddress);
            }
            if (typeof input.isAdmin !== 'undefined') {
                json += `,"is_admin":`;
                json += `${input.isAdmin}`;
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`created_at=${input.createdAt.toISOString()}`);
            queryParts.push(`display_name=${input.displayName}`);
            queryParts.push(`phone_number=${input.phoneNumber}`);
            if (typeof input.emailAddress !== 'undefined') {
                queryParts.push(`email_address=${input.emailAddress}`);
            }
            if (typeof input.isAdmin !== 'undefined') {
                queryParts.push(`is_admin=${input.isAdmin}`);
            }
            return queryParts.join('&');
        },
    };

export interface FooObjectWithEveryOptionalType {
    any?: any;
    boolean?: boolean;
    string?: string;
    timestamp?: Date;
    float32?: number;
    float64?: number;
    int8?: number;
    uint8?: number;
    int16?: number;
    uint16?: number;
    int32?: number;
    uint32?: number;
    int64?: bigint;
    uint64?: bigint;
    enumerator?: FooObjectWithEveryOptionalTypeEnumerator;
    array?: boolean[];
    object?: FooObjectWithEveryOptionalTypeObject;
    record?: Record<string, bigint>;
    discriminator?: FooObjectWithEveryOptionalTypeDiscriminator;
    nestedObject?: FooObjectWithEveryOptionalTypeNestedObject;
    nestedArray?: FooObjectWithEveryOptionalTypeNestedArrayElementElement[][];
}
export const $$FooObjectWithEveryOptionalType: ArriModelValidator<FooObjectWithEveryOptionalType> =
    {
        new(): FooObjectWithEveryOptionalType {
            return {};
        },
        validate(input): input is FooObjectWithEveryOptionalType {
            return (
                isObject(input) &&
                (true || typeof input.any === 'undefined') &&
                (typeof input.boolean === 'boolean' ||
                    typeof input.boolean === 'undefined') &&
                (typeof input.string === 'string' ||
                    typeof input.string === 'undefined') &&
                (input.timestamp instanceof Date ||
                    typeof input.timestamp === 'undefined') &&
                (typeof input.float32 === 'number' ||
                    typeof input.float32 === 'undefined') &&
                (typeof input.float64 === 'number' ||
                    typeof input.float64 === 'undefined') &&
                ((typeof input.int8 === 'number' &&
                    Number.isInteger(input.int8) &&
                    input.int8 >= INT8_MIN &&
                    input.int8 <= INT8_MAX) ||
                    typeof input.int8 === 'undefined') &&
                ((typeof input.uint8 === 'number' &&
                    Number.isInteger(input.uint8) &&
                    input.uint8 >= 0 &&
                    input.uint8 <= UINT8_MAX) ||
                    typeof input.uint8 === 'undefined') &&
                ((typeof input.int16 === 'number' &&
                    Number.isInteger(input.int16) &&
                    input.int16 >= INT16_MIN &&
                    input.int16 <= INT16_MAX) ||
                    typeof input.int16 === 'undefined') &&
                ((typeof input.uint16 === 'number' &&
                    Number.isInteger(input.uint16) &&
                    input.uint16 >= 0 &&
                    input.uint16 <= UINT16_MAX) ||
                    typeof input.uint16 === 'undefined') &&
                ((typeof input.int32 === 'number' &&
                    Number.isInteger(input.int32) &&
                    input.int32 >= INT32_MIN &&
                    input.int32 <= INT32_MAX) ||
                    typeof input.int32 === 'undefined') &&
                ((typeof input.uint32 === 'number' &&
                    Number.isInteger(input.uint32) &&
                    input.uint32 >= 0 &&
                    input.uint32 <= UINT32_MAX) ||
                    typeof input.uint32 === 'undefined') &&
                ((typeof input.int64 === 'bigint' &&
                    input.int64 >= INT64_MIN &&
                    input.int64 <= INT64_MAX) ||
                    typeof input.int64 === 'undefined') &&
                ((typeof input.uint64 === 'bigint' &&
                    input.uint64 >= BigInt(0) &&
                    input.uint64 <= UINT64_MAX) ||
                    typeof input.uint64 === 'undefined') &&
                ($$FooObjectWithEveryOptionalTypeEnumerator.validate(
                    input.enumerator,
                ) ||
                    typeof input.enumerator === 'undefined') &&
                ((Array.isArray(input.array) &&
                    input.array.every(
                        (_element) => typeof _element === 'boolean',
                    )) ||
                    typeof input.array === 'undefined') &&
                ($$FooObjectWithEveryOptionalTypeObject.validate(
                    input.object,
                ) ||
                    typeof input.object === 'undefined') &&
                ((isObject(input.record) &&
                    Object.values(input.record).every(
                        (_value) =>
                            typeof _value === 'bigint' &&
                            _value >= BigInt(0) &&
                            _value <= UINT64_MAX,
                    )) ||
                    typeof input.record === 'undefined') &&
                ($$FooObjectWithEveryOptionalTypeDiscriminator.validate(
                    input.discriminator,
                ) ||
                    typeof input.discriminator === 'undefined') &&
                ($$FooObjectWithEveryOptionalTypeNestedObject.validate(
                    input.nestedObject,
                ) ||
                    typeof input.nestedObject === 'undefined') &&
                ((Array.isArray(input.nestedArray) &&
                    input.nestedArray.every(
                        (_element) =>
                            Array.isArray(_element) &&
                            _element.every((_element) =>
                                $$FooObjectWithEveryOptionalTypeNestedArrayElementElement.validate(
                                    _element,
                                ),
                            ),
                    )) ||
                    typeof input.nestedArray === 'undefined')
            );
        },
        fromJson(input): FooObjectWithEveryOptionalType {
            let _any: any | undefined;
            if (typeof input.any !== 'undefined') {
                _any = input.any;
            }
            let _boolean: boolean | undefined;
            if (typeof input.boolean !== 'undefined') {
                if (typeof input.boolean === 'boolean') {
                    _boolean = input.boolean;
                } else {
                    _boolean = false;
                }
            }
            let _string: string | undefined;
            if (typeof input.string !== 'undefined') {
                if (typeof input.string === 'string') {
                    _string = input.string;
                } else {
                    _string = '';
                }
            }
            let _timestamp: Date | undefined;
            if (typeof input.timestamp !== 'undefined') {
                if (typeof input.timestamp === 'string') {
                    _timestamp = new Date(input.timestamp);
                } else if (input.timestamp instanceof Date) {
                    _timestamp = input.timestamp;
                } else {
                    _timestamp = new Date();
                }
            }
            let _float32: number | undefined;
            if (typeof input.float32 !== 'undefined') {
                if (typeof input.float32 === 'number') {
                    _float32 = input.float32;
                } else {
                    _float32 = 0;
                }
            }
            let _float64: number | undefined;
            if (typeof input.float64 !== 'undefined') {
                if (typeof input.float64 === 'number') {
                    _float64 = input.float64;
                } else {
                    _float64 = 0;
                }
            }
            let _int8: number | undefined;
            if (typeof input.int8 !== 'undefined') {
                if (
                    typeof input.int8 === 'number' &&
                    Number.isInteger(input.int8) &&
                    input.int8 >= INT8_MIN &&
                    input.int8 <= INT8_MAX
                ) {
                    _int8 = input.int8;
                } else {
                    _int8 = 0;
                }
            }
            let _uint8: number | undefined;
            if (typeof input.uint8 !== 'undefined') {
                if (
                    typeof input.uint8 === 'number' &&
                    Number.isInteger(input.uint8) &&
                    input.uint8 >= 0 &&
                    input.uint8 <= UINT8_MAX
                ) {
                    _uint8 = input.uint8;
                } else {
                    _uint8 = 0;
                }
            }
            let _int16: number | undefined;
            if (typeof input.int16 !== 'undefined') {
                if (
                    typeof input.int16 === 'number' &&
                    Number.isInteger(input.int16) &&
                    input.int16 >= INT16_MIN &&
                    input.int16 <= INT16_MAX
                ) {
                    _int16 = input.int16;
                } else {
                    _int16 = 0;
                }
            }
            let _uint16: number | undefined;
            if (typeof input.uint16 !== 'undefined') {
                if (
                    typeof input.uint16 === 'number' &&
                    Number.isInteger(input.uint16) &&
                    input.uint16 >= 0 &&
                    input.uint16 <= UINT16_MAX
                ) {
                    _uint16 = input.uint16;
                } else {
                    _uint16 = 0;
                }
            }
            let _int32: number | undefined;
            if (typeof input.int32 !== 'undefined') {
                if (
                    typeof input.int32 === 'number' &&
                    Number.isInteger(input.int32) &&
                    input.int32 >= INT32_MIN &&
                    input.int32 <= INT32_MAX
                ) {
                    _int32 = input.int32;
                } else {
                    _int32 = 0;
                }
            }
            let _uint32: number | undefined;
            if (typeof input.uint32 !== 'undefined') {
                if (
                    typeof input.uint32 === 'number' &&
                    Number.isInteger(input.uint32) &&
                    input.uint32 >= 0 &&
                    input.uint32 <= UINT32_MAX
                ) {
                    _uint32 = input.uint32;
                } else {
                    _uint32 = 0;
                }
            }
            let _int64: bigint | undefined;
            if (typeof input.int64 !== 'undefined') {
                if (typeof input.int64 === 'string') {
                    _int64 = BigInt(input.int64);
                } else if (typeof input.int64 === 'bigint') {
                    _int64 = input.int64;
                } else {
                    _int64 = BigInt(0);
                }
            }
            let _uint64: bigint | undefined;
            if (typeof input.uint64 !== 'undefined') {
                if (
                    typeof input.uint64 === 'string' &&
                    BigInt(input.uint64) >= BigInt(0)
                ) {
                    _uint64 = BigInt(input.uint64);
                } else if (
                    typeof input.uint64 === 'bigint' &&
                    input.uint64 >= BigInt(0)
                ) {
                    _uint64 = input.uint64;
                } else {
                    _uint64 = BigInt(0);
                }
            }
            let _enumerator:
                | FooObjectWithEveryOptionalTypeEnumerator
                | undefined;
            if (typeof input.enumerator !== 'undefined') {
                if (typeof input.enumerator === 'string') {
                    _enumerator =
                        $$FooObjectWithEveryOptionalTypeEnumerator.fromSerialValue(
                            input.enumerator,
                        );
                } else {
                    _enumerator =
                        $$FooObjectWithEveryOptionalTypeEnumerator.new();
                }
            }
            let _array: boolean[] | undefined;
            if (typeof input.array !== 'undefined') {
                if (Array.isArray(input.array)) {
                    _array = [];
                    for (const _arrayEl of input.array) {
                        let _arrayElValue: boolean;
                        if (typeof _arrayEl === 'boolean') {
                            _arrayElValue = _arrayEl;
                        } else {
                            _arrayElValue = false;
                        }
                        _array.push(_arrayElValue);
                    }
                } else {
                    _array = [];
                }
            }
            let _object: FooObjectWithEveryOptionalTypeObject | undefined;
            if (typeof input.object !== 'undefined') {
                if (isObject(input.object)) {
                    _object = $$FooObjectWithEveryOptionalTypeObject.fromJson(
                        input.object,
                    );
                } else {
                    _object = $$FooObjectWithEveryOptionalTypeObject.new();
                }
            }
            let _record: Record<string, bigint> | undefined;
            if (typeof input.record !== 'undefined') {
                if (isObject(input.record)) {
                    _record = {};
                    for (const [_key, _value] of Object.entries(input.record)) {
                        let _recordValue: bigint;
                        if (
                            typeof _value === 'string' &&
                            BigInt(_value) >= BigInt(0)
                        ) {
                            _recordValue = BigInt(_value);
                        } else if (
                            typeof _value === 'bigint' &&
                            _value >= BigInt(0)
                        ) {
                            _recordValue = _value;
                        } else {
                            _recordValue = BigInt(0);
                        }
                        _record[_key] = _recordValue;
                    }
                } else {
                    _record = {};
                }
            }
            let _discriminator:
                | FooObjectWithEveryOptionalTypeDiscriminator
                | undefined;
            if (typeof input.discriminator !== 'undefined') {
                if (isObject(input.discriminator)) {
                    _discriminator =
                        $$FooObjectWithEveryOptionalTypeDiscriminator.fromJson(
                            input.discriminator,
                        );
                } else {
                    _discriminator =
                        $$FooObjectWithEveryOptionalTypeDiscriminator.new();
                }
            }
            let _nestedObject:
                | FooObjectWithEveryOptionalTypeNestedObject
                | undefined;
            if (typeof input.nestedObject !== 'undefined') {
                if (isObject(input.nestedObject)) {
                    _nestedObject =
                        $$FooObjectWithEveryOptionalTypeNestedObject.fromJson(
                            input.nestedObject,
                        );
                } else {
                    _nestedObject =
                        $$FooObjectWithEveryOptionalTypeNestedObject.new();
                }
            }
            let _nestedArray:
                | FooObjectWithEveryOptionalTypeNestedArrayElementElement[][]
                | undefined;
            if (typeof input.nestedArray !== 'undefined') {
                if (Array.isArray(input.nestedArray)) {
                    _nestedArray = [];
                    for (const _nestedArrayEl of input.nestedArray) {
                        let _nestedArrayElValue: FooObjectWithEveryOptionalTypeNestedArrayElementElement[];
                        if (Array.isArray(_nestedArrayEl)) {
                            _nestedArrayElValue = [];
                            for (const _nestedArrayElValueEl of _nestedArrayEl) {
                                let _nestedArrayElValueElValue: FooObjectWithEveryOptionalTypeNestedArrayElementElement;
                                if (isObject(_nestedArrayElValueEl)) {
                                    _nestedArrayElValueElValue =
                                        $$FooObjectWithEveryOptionalTypeNestedArrayElementElement.fromJson(
                                            _nestedArrayElValueEl,
                                        );
                                } else {
                                    _nestedArrayElValueElValue =
                                        $$FooObjectWithEveryOptionalTypeNestedArrayElementElement.new();
                                }
                                _nestedArrayElValue.push(
                                    _nestedArrayElValueElValue,
                                );
                            }
                        } else {
                            _nestedArrayElValue = [];
                        }
                        _nestedArray.push(_nestedArrayElValue);
                    }
                } else {
                    _nestedArray = [];
                }
            }
            return {
                any: _any,
                boolean: _boolean,
                string: _string,
                timestamp: _timestamp,
                float32: _float32,
                float64: _float64,
                int8: _int8,
                uint8: _uint8,
                int16: _int16,
                uint16: _uint16,
                int32: _int32,
                uint32: _uint32,
                int64: _int64,
                uint64: _uint64,
                enumerator: _enumerator,
                array: _array,
                object: _object,
                record: _record,
                discriminator: _discriminator,
                nestedObject: _nestedObject,
                nestedArray: _nestedArray,
            };
        },
        fromJsonString(input): FooObjectWithEveryOptionalType {
            return $$FooObjectWithEveryOptionalType.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            let _hasKey = false;
            if (typeof input.any !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"any":';
                json += JSON.stringify(input.any);
                _hasKey = true;
            }
            if (typeof input.boolean !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"boolean":';
                json += `${input.boolean}`;
                _hasKey = true;
            }
            if (typeof input.string !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"string":';
                json += serializeString(input.string);
                _hasKey = true;
            }
            if (typeof input.timestamp !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"timestamp":';
                json += `"${input.timestamp.toISOString()}"`;
                _hasKey = true;
            }
            if (typeof input.float32 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"float32":';
                json += `${input.float32}`;
                _hasKey = true;
            }
            if (typeof input.float64 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"float64":';
                json += `${input.float64}`;
                _hasKey = true;
            }
            if (typeof input.int8 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"int8":';
                json += `${input.int8}`;
                _hasKey = true;
            }
            if (typeof input.uint8 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"uint8":';
                json += `${input.uint8}`;
                _hasKey = true;
            }
            if (typeof input.int16 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"int16":';
                json += `${input.int16}`;
                _hasKey = true;
            }
            if (typeof input.uint16 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"uint16":';
                json += `${input.uint16}`;
                _hasKey = true;
            }
            if (typeof input.int32 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"int32":';
                json += `${input.int32}`;
                _hasKey = true;
            }
            if (typeof input.uint32 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"uint32":';
                json += `${input.uint32}`;
                _hasKey = true;
            }
            if (typeof input.int64 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"int64":';
                json += `"${input.int64}"`;
                _hasKey = true;
            }
            if (typeof input.uint64 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"uint64":';
                json += `"${input.uint64}"`;
                _hasKey = true;
            }
            if (typeof input.enumerator !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"enumerator":';
                json += `"${input.enumerator}"`;
                _hasKey = true;
            }
            if (typeof input.array !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"array":';
                json += '[';
                for (let i = 0; i < input.array.length; i++) {
                    if (i !== 0) json += ',';
                    const _inputArrayEl = input.array[i];
                    json += `${_inputArrayEl}`;
                }
                json += ']';
                _hasKey = true;
            }
            if (typeof input.object !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"object":';
                json += $$FooObjectWithEveryOptionalTypeObject.toJsonString(
                    input.object,
                );
                _hasKey = true;
            }
            if (typeof input.record !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"record":';
                json += '{';
                let _recordPropertyCount = 0;
                for (const [_key, _value] of Object.entries(input.record)) {
                    if (_recordPropertyCount !== 0) {
                        json += ',';
                    }
                    json += `${serializeString(_key)}:`;
                    json += `"${_value}"`;
                    _recordPropertyCount++;
                }
                json += '}';

                _hasKey = true;
            }
            if (typeof input.discriminator !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"discriminator":';
                json +=
                    $$FooObjectWithEveryOptionalTypeDiscriminator.toJsonString(
                        input.discriminator,
                    );
                _hasKey = true;
            }
            if (typeof input.nestedObject !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"nestedObject":';
                json +=
                    $$FooObjectWithEveryOptionalTypeNestedObject.toJsonString(
                        input.nestedObject,
                    );
                _hasKey = true;
            }
            if (typeof input.nestedArray !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"nestedArray":';
                json += '[';
                for (let i = 0; i < input.nestedArray.length; i++) {
                    if (i !== 0) json += ',';
                    const _inputNestedArrayEl = input.nestedArray[i];
                    json += '[';
                    for (let i = 0; i < _inputNestedArrayEl.length; i++) {
                        if (i !== 0) json += ',';
                        const _inputNestedArrayElEl = _inputNestedArrayEl[i];
                        json +=
                            $$FooObjectWithEveryOptionalTypeNestedArrayElementElement.toJsonString(
                                _inputNestedArrayElEl,
                            );
                    }
                    json += ']';
                }
                json += ']';
                _hasKey = true;
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            if (typeof input.any !== 'undefined') {
                console.warn(
                    "[WARNING] Cannot serialize any's to query string. Skipping property at /ObjectWithEveryOptionalType/any.",
                );
            }
            if (typeof input.boolean !== 'undefined') {
                queryParts.push(`boolean=${input.boolean}`);
            }
            if (typeof input.string !== 'undefined') {
                queryParts.push(`string=${input.string}`);
            }
            if (typeof input.timestamp !== 'undefined') {
                queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            }
            if (typeof input.float32 !== 'undefined') {
                queryParts.push(`float32=${input.float32}`);
            }
            if (typeof input.float64 !== 'undefined') {
                queryParts.push(`float64=${input.float64}`);
            }
            if (typeof input.int8 !== 'undefined') {
                queryParts.push(`int8=${input.int8}`);
            }
            if (typeof input.uint8 !== 'undefined') {
                queryParts.push(`uint8=${input.uint8}`);
            }
            if (typeof input.int16 !== 'undefined') {
                queryParts.push(`int16=${input.int16}`);
            }
            if (typeof input.uint16 !== 'undefined') {
                queryParts.push(`uint16=${input.uint16}`);
            }
            if (typeof input.int32 !== 'undefined') {
                queryParts.push(`int32=${input.int32}`);
            }
            if (typeof input.uint32 !== 'undefined') {
                queryParts.push(`uint32=${input.uint32}`);
            }
            if (typeof input.int64 !== 'undefined') {
                queryParts.push(`int64=${input.int64}`);
            }
            if (typeof input.uint64 !== 'undefined') {
                queryParts.push(`uint64=${input.uint64}`);
            }
            if (typeof input.enumerator !== 'undefined') {
                queryParts.push(`enumerator=${input.enumerator}`);
            }
            if (typeof input.array !== 'undefined') {
                console.warn(
                    '[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryOptionalType/array.',
                );
            }
            if (typeof input.object !== 'undefined') {
                console.warn(
                    '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryOptionalType/object.',
                );
            }
            if (typeof input.record !== 'undefined') {
                console.warn(
                    '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryOptionalType/record.',
                );
            }
            if (typeof input.discriminator !== 'undefined') {
                console.warn(
                    '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryOptionalType/discriminator.',
                );
            }
            if (typeof input.nestedObject !== 'undefined') {
                console.warn(
                    '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryOptionalType/nestedObject.',
                );
            }
            if (typeof input.nestedArray !== 'undefined') {
                console.warn(
                    '[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryOptionalType/nestedArray.',
                );
            }
            return queryParts.join('&');
        },
    };

export type FooObjectWithEveryOptionalTypeEnumerator =
    (typeof $$FooObjectWithEveryOptionalTypeEnumeratorValues)[number];
const $$FooObjectWithEveryOptionalTypeEnumeratorValues = [
    'A',
    'B',
    'C',
] as const;
export const $$FooObjectWithEveryOptionalTypeEnumerator: ArriEnumValidator<FooObjectWithEveryOptionalTypeEnumerator> =
    {
        new(): FooObjectWithEveryOptionalTypeEnumerator {
            return $$FooObjectWithEveryOptionalTypeEnumeratorValues[0];
        },
        validate(input): input is ObjectWithEveryOptionalTypeEnumerator {
            return (
                typeof input === 'string' &&
                $$FooObjectWithEveryOptionalTypeEnumeratorValues.includes(
                    input as any,
                )
            );
        },
        values: $$FooObjectWithEveryOptionalTypeEnumeratorValues,
        fromSerialValue(input): FooObjectWithEveryOptionalTypeEnumerator {
            if (
                $$FooObjectWithEveryOptionalTypeEnumeratorValues.includes(
                    input as any,
                )
            ) {
                return input as FooObjectWithEveryOptionalTypeEnumerator;
            }
            if (
                $$FooObjectWithEveryOptionalTypeEnumeratorValues.includes(
                    input.toLowerCase() as any,
                )
            ) {
                return input.toLowerCase() as FooObjectWithEveryOptionalTypeEnumerator;
            }
            if (
                $$FooObjectWithEveryOptionalTypeEnumeratorValues.includes(
                    input.toUpperCase() as any,
                )
            ) {
                return input.toUpperCase() as FooObjectWithEveryOptionalTypeEnumerator;
            }
            return 'A';
        },
    };

export interface FooObjectWithEveryOptionalTypeObject {
    string: string;
    boolean: boolean;
    timestamp: Date;
}
export const $$FooObjectWithEveryOptionalTypeObject: ArriModelValidator<FooObjectWithEveryOptionalTypeObject> =
    {
        new(): FooObjectWithEveryOptionalTypeObject {
            return {
                string: '',
                boolean: false,
                timestamp: new Date(),
            };
        },
        validate(input): input is FooObjectWithEveryOptionalTypeObject {
            return (
                isObject(input) &&
                typeof input.string === 'string' &&
                typeof input.boolean === 'boolean' &&
                input.timestamp instanceof Date
            );
        },
        fromJson(input): FooObjectWithEveryOptionalTypeObject {
            let _string: string;
            if (typeof input.string === 'string') {
                _string = input.string;
            } else {
                _string = '';
            }
            let _boolean: boolean;
            if (typeof input.boolean === 'boolean') {
                _boolean = input.boolean;
            } else {
                _boolean = false;
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            return {
                string: _string,
                boolean: _boolean,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): FooObjectWithEveryOptionalTypeObject {
            return $$FooObjectWithEveryOptionalTypeObject.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"string":';
            json += serializeString(input.string);
            json += ',"boolean":';
            json += `${input.boolean}`;
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`string=${input.string}`);
            queryParts.push(`boolean=${input.boolean}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            return queryParts.join('&');
        },
    };

export type FooObjectWithEveryOptionalTypeDiscriminator =
    | FooObjectWithEveryOptionalTypeDiscriminatorA
    | FooObjectWithEveryOptionalTypeDiscriminatorB;
export const $$FooObjectWithEveryOptionalTypeDiscriminator: ArriModelValidator<FooObjectWithEveryOptionalTypeDiscriminator> =
    {
        new(): FooObjectWithEveryOptionalTypeDiscriminator {
            return $$FooObjectWithEveryOptionalTypeDiscriminatorA.new();
        },
        validate(input): input is FooObjectWithEveryOptionalTypeDiscriminator {
            if (!isObject(input)) {
                return false;
            }
            if (typeof input.type !== 'string') {
                return false;
            }
            switch (input.type) {
                case 'A':
                    return $$FooObjectWithEveryOptionalTypeDiscriminatorA.validate(
                        input,
                    );
                case 'B':
                    return $$FooObjectWithEveryOptionalTypeDiscriminatorB.validate(
                        input,
                    );
                default:
                    return false;
            }
        },
        fromJson(input): FooObjectWithEveryOptionalTypeDiscriminator {
            switch (input.type) {
                case 'A':
                    return $$FooObjectWithEveryOptionalTypeDiscriminatorA.fromJson(
                        input,
                    );
                case 'B':
                    return $$FooObjectWithEveryOptionalTypeDiscriminatorB.fromJson(
                        input,
                    );
                default:
                    return $$FooObjectWithEveryOptionalTypeDiscriminatorA.new();
            }
        },
        fromJsonString(input): FooObjectWithEveryOptionalTypeDiscriminator {
            return $$FooObjectWithEveryOptionalTypeDiscriminator.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            switch (input.type) {
                case 'A':
                    return $$FooObjectWithEveryOptionalTypeDiscriminatorA.toJsonString(
                        input,
                    );
                case 'B':
                    return $$FooObjectWithEveryOptionalTypeDiscriminatorB.toJsonString(
                        input,
                    );
                default:
                    throw new Error(`Unhandled case "${(input as any).type}"`);
            }
        },
        toUrlQueryString(input): string {
            switch (input.type) {
                case 'A':
                    return $$FooObjectWithEveryOptionalTypeDiscriminatorA.toUrlQueryString(
                        input,
                    );
                case 'B':
                    return $$FooObjectWithEveryOptionalTypeDiscriminatorB.toUrlQueryString(
                        input,
                    );
                default:
                    throw new Error('Unhandled case');
            }
        },
    };
export interface FooObjectWithEveryOptionalTypeDiscriminatorA {
    type: 'A';
    title: string;
}
const $$FooObjectWithEveryOptionalTypeDiscriminatorA: ArriModelValidator<FooObjectWithEveryOptionalTypeDiscriminatorA> =
    {
        new(): FooObjectWithEveryOptionalTypeDiscriminatorA {
            return {
                type: 'A',
                title: '',
            };
        },
        validate(input): input is FooObjectWithEveryOptionalTypeDiscriminatorA {
            return (
                isObject(input) &&
                input.type === 'A' &&
                typeof input.title === 'string'
            );
        },
        fromJson(input): FooObjectWithEveryOptionalTypeDiscriminatorA {
            const _type = 'A';
            let _title: string;
            if (typeof input.title === 'string') {
                _title = input.title;
            } else {
                _title = '';
            }
            return {
                type: _type,
                title: _title,
            };
        },
        fromJsonString(input): FooObjectWithEveryOptionalTypeDiscriminatorA {
            return $$FooObjectWithEveryOptionalTypeDiscriminatorA.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"type":"A"';
            json += ',"title":';
            json += serializeString(input.title);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('type=A');
            queryParts.push(`title=${input.title}`);
            return queryParts.join('&');
        },
    };

export interface FooObjectWithEveryOptionalTypeDiscriminatorB {
    type: 'B';
    title: string;
    description: string;
}
const $$FooObjectWithEveryOptionalTypeDiscriminatorB: ArriModelValidator<FooObjectWithEveryOptionalTypeDiscriminatorB> =
    {
        new(): FooObjectWithEveryOptionalTypeDiscriminatorB {
            return {
                type: 'B',
                title: '',
                description: '',
            };
        },
        validate(input): input is FooObjectWithEveryOptionalTypeDiscriminatorB {
            return (
                isObject(input) &&
                input.type === 'B' &&
                typeof input.title === 'string' &&
                typeof input.description === 'string'
            );
        },
        fromJson(input): FooObjectWithEveryOptionalTypeDiscriminatorB {
            const _type = 'B';
            let _title: string;
            if (typeof input.title === 'string') {
                _title = input.title;
            } else {
                _title = '';
            }
            let _description: string;
            if (typeof input.description === 'string') {
                _description = input.description;
            } else {
                _description = '';
            }
            return {
                type: _type,
                title: _title,
                description: _description,
            };
        },
        fromJsonString(input): FooObjectWithEveryOptionalTypeDiscriminatorB {
            return $$FooObjectWithEveryOptionalTypeDiscriminatorB.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"type":"B"';
            json += ',"title":';
            json += serializeString(input.title);
            json += ',"description":';
            json += serializeString(input.description);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('type=B');
            queryParts.push(`title=${input.title}`);
            queryParts.push(`description=${input.description}`);
            return queryParts.join('&');
        },
    };

export interface FooObjectWithEveryOptionalTypeNestedObject {
    id: string;
    timestamp: Date;
    data: FooObjectWithEveryOptionalTypeNestedObjectData;
}
export const $$FooObjectWithEveryOptionalTypeNestedObject: ArriModelValidator<FooObjectWithEveryOptionalTypeNestedObject> =
    {
        new(): FooObjectWithEveryOptionalTypeNestedObject {
            return {
                id: '',
                timestamp: new Date(),
                data: $$FooObjectWithEveryOptionalTypeNestedObjectData.new(),
            };
        },
        validate(input): input is FooObjectWithEveryOptionalTypeNestedObject {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                input.timestamp instanceof Date &&
                $$FooObjectWithEveryOptionalTypeNestedObjectData.validate(
                    input.data,
                )
            );
        },
        fromJson(input): FooObjectWithEveryOptionalTypeNestedObject {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            let _data: FooObjectWithEveryOptionalTypeNestedObjectData;
            if (isObject(input.data)) {
                _data =
                    $$FooObjectWithEveryOptionalTypeNestedObjectData.fromJson(
                        input.data,
                    );
            } else {
                _data = $$FooObjectWithEveryOptionalTypeNestedObjectData.new();
            }
            return {
                id: _id,
                timestamp: _timestamp,
                data: _data,
            };
        },
        fromJsonString(input): FooObjectWithEveryOptionalTypeNestedObject {
            return $$FooObjectWithEveryOptionalTypeNestedObject.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += ',"data":';
            json +=
                $$FooObjectWithEveryOptionalTypeNestedObjectData.toJsonString(
                    input.data,
                );
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryOptionalTypeNestedObject/data.',
            );
            return queryParts.join('&');
        },
    };

export interface FooObjectWithEveryOptionalTypeNestedObjectData {
    id: string;
    timestamp: Date;
    data: FooObjectWithEveryOptionalTypeNestedObjectDataData;
}
export const $$FooObjectWithEveryOptionalTypeNestedObjectData: ArriModelValidator<FooObjectWithEveryOptionalTypeNestedObjectData> =
    {
        new(): FooObjectWithEveryOptionalTypeNestedObjectData {
            return {
                id: '',
                timestamp: new Date(),
                data: $$FooObjectWithEveryOptionalTypeNestedObjectDataData.new(),
            };
        },
        validate(
            input,
        ): input is FooObjectWithEveryOptionalTypeNestedObjectData {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                input.timestamp instanceof Date &&
                $$FooObjectWithEveryOptionalTypeNestedObjectDataData.validate(
                    input.data,
                )
            );
        },
        fromJson(input): FooObjectWithEveryOptionalTypeNestedObjectData {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            let _data: FooObjectWithEveryOptionalTypeNestedObjectDataData;
            if (isObject(input.data)) {
                _data =
                    $$FooObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
                        input.data,
                    );
            } else {
                _data =
                    $$FooObjectWithEveryOptionalTypeNestedObjectDataData.new();
            }
            return {
                id: _id,
                timestamp: _timestamp,
                data: _data,
            };
        },
        fromJsonString(input): FooObjectWithEveryOptionalTypeNestedObjectData {
            return $$FooObjectWithEveryOptionalTypeNestedObjectData.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += ',"data":';
            json +=
                $$FooObjectWithEveryOptionalTypeNestedObjectDataData.toJsonString(
                    input.data,
                );
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryOptionalTypeNestedObjectData/data.',
            );
            return queryParts.join('&');
        },
    };

export interface FooObjectWithEveryOptionalTypeNestedObjectDataData {
    id: string;
    timestamp: Date;
}
export const $$FooObjectWithEveryOptionalTypeNestedObjectDataData: ArriModelValidator<FooObjectWithEveryOptionalTypeNestedObjectDataData> =
    {
        new(): FooObjectWithEveryOptionalTypeNestedObjectDataData {
            return {
                id: '',
                timestamp: new Date(),
            };
        },
        validate(
            input,
        ): input is FooObjectWithEveryOptionalTypeNestedObjectDataData {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                input.timestamp instanceof Date
            );
        },
        fromJson(input): FooObjectWithEveryOptionalTypeNestedObjectDataData {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            return {
                id: _id,
                timestamp: _timestamp,
            };
        },
        fromJsonString(
            input,
        ): FooObjectWithEveryOptionalTypeNestedObjectDataData {
            return $$FooObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            return queryParts.join('&');
        },
    };

export interface FooObjectWithEveryOptionalTypeNestedArrayElementElement {
    id: string;
    timestamp: Date;
}
export const $$FooObjectWithEveryOptionalTypeNestedArrayElementElement: ArriModelValidator<FooObjectWithEveryOptionalTypeNestedArrayElementElement> =
    {
        new(): FooObjectWithEveryOptionalTypeNestedArrayElementElement {
            return {
                id: '',
                timestamp: new Date(),
            };
        },
        validate(
            input,
        ): input is FooObjectWithEveryOptionalTypeNestedArrayElementElement {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                input.timestamp instanceof Date
            );
        },
        fromJson(
            input,
        ): FooObjectWithEveryOptionalTypeNestedArrayElementElement {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            return {
                id: _id,
                timestamp: _timestamp,
            };
        },
        fromJsonString(
            input,
        ): FooObjectWithEveryOptionalTypeNestedArrayElementElement {
            return $$FooObjectWithEveryOptionalTypeNestedArrayElementElement.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            return queryParts.join('&');
        },
    };

export interface FooRecursiveObject {
    left: FooRecursiveObject | null;
    right: FooRecursiveObject | null;
    value: string;
}
export const $$FooRecursiveObject: ArriModelValidator<FooRecursiveObject> = {
    new(): FooRecursiveObject {
        return {
            left: null,
            right: null,
            value: '',
        };
    },
    validate(input): input is FooRecursiveObject {
        return (
            isObject(input) &&
            ($$FooRecursiveObject.validate(input.left) ||
                input.left === null) &&
            ($$FooRecursiveObject.validate(input.right) ||
                input.right === null) &&
            typeof input.value === 'string'
        );
    },
    fromJson(input): FooRecursiveObject {
        let _left: FooRecursiveObject | null;
        if (isObject(input.left)) {
            _left = $$FooRecursiveObject.fromJson(input.left);
        } else {
            _left = null;
        }
        let _right: FooRecursiveObject | null;
        if (isObject(input.right)) {
            _right = $$FooRecursiveObject.fromJson(input.right);
        } else {
            _right = null;
        }
        let _value: string;
        if (typeof input.value === 'string') {
            _value = input.value;
        } else {
            _value = '';
        }
        return {
            left: _left,
            right: _right,
            value: _value,
        };
    },
    fromJsonString(input): FooRecursiveObject {
        return $$FooRecursiveObject.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"left":';
        if (input.left !== null) {
            json += $$FooRecursiveObject.toJsonString(input.left);
        } else {
            json += 'null';
        }
        json += ',"right":';
        if (input.right !== null) {
            json += $$FooRecursiveObject.toJsonString(input.right);
        } else {
            json += 'null';
        }
        json += ',"value":';
        json += serializeString(input.value);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        console.warn(
            '[WARNING] Nested objects cannot be serialized to query string. Ignoring property at /RecursiveObject/left.',
        );
        console.warn(
            '[WARNING] Nested objects cannot be serialized to query string. Ignoring property at /RecursiveObject/right.',
        );
        queryParts.push(`value=${input.value}`);
        return queryParts.join('&');
    },
};

export type FooRecursiveUnion =
    | FooRecursiveUnionChild
    | FooRecursiveUnionChildren
    | FooRecursiveUnionText
    | FooRecursiveUnionShape;
export const $$FooRecursiveUnion: ArriModelValidator<FooRecursiveUnion> = {
    new(): FooRecursiveUnion {
        return $$FooRecursiveUnionChild.new();
    },
    validate(input): input is FooRecursiveUnion {
        if (!isObject(input)) {
            return false;
        }
        if (typeof input.type !== 'string') {
            return false;
        }
        switch (input.type) {
            case 'CHILD':
                return $$FooRecursiveUnionChild.validate(input);
            case 'CHILDREN':
                return $$FooRecursiveUnionChildren.validate(input);
            case 'TEXT':
                return $$FooRecursiveUnionText.validate(input);
            case 'SHAPE':
                return $$FooRecursiveUnionShape.validate(input);
            default:
                return false;
        }
    },
    fromJson(input): FooRecursiveUnion {
        switch (input.type) {
            case 'CHILD':
                return $$FooRecursiveUnionChild.fromJson(input);
            case 'CHILDREN':
                return $$FooRecursiveUnionChildren.fromJson(input);
            case 'TEXT':
                return $$FooRecursiveUnionText.fromJson(input);
            case 'SHAPE':
                return $$FooRecursiveUnionShape.fromJson(input);
            default:
                return $$FooRecursiveUnionChild.new();
        }
    },
    fromJsonString(input): FooRecursiveUnion {
        return $$FooRecursiveUnion.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        switch (input.type) {
            case 'CHILD':
                return $$FooRecursiveUnionChild.toJsonString(input);
            case 'CHILDREN':
                return $$FooRecursiveUnionChildren.toJsonString(input);
            case 'TEXT':
                return $$FooRecursiveUnionText.toJsonString(input);
            case 'SHAPE':
                return $$FooRecursiveUnionShape.toJsonString(input);
            default:
                throw new Error(`Unhandled case "${(input as any).type}"`);
        }
    },
    toUrlQueryString(input): string {
        switch (input.type) {
            case 'CHILD':
                return $$FooRecursiveUnionChild.toUrlQueryString(input);
            case 'CHILDREN':
                return $$FooRecursiveUnionChildren.toUrlQueryString(input);
            case 'TEXT':
                return $$FooRecursiveUnionText.toUrlQueryString(input);
            case 'SHAPE':
                return $$FooRecursiveUnionShape.toUrlQueryString(input);
            default:
                throw new Error('Unhandled case');
        }
    },
};
/**
 * Child node
 */
export interface FooRecursiveUnionChild {
    type: 'CHILD';
    data: FooRecursiveUnion;
}
const $$FooRecursiveUnionChild: ArriModelValidator<FooRecursiveUnionChild> = {
    new(): FooRecursiveUnionChild {
        return {
            type: 'CHILD',
            data: FooRecursiveUnion.new(),
        };
    },
    validate(input): input is FooRecursiveUnionChild {
        return (
            isObject(input) &&
            input.type === 'CHILD' &&
            $$FooRecursiveUnion.validate(input.data)
        );
    },
    fromJson(input): FooRecursiveUnionChild {
        const _type = 'CHILD';
        let _data: FooRecursiveUnion;
        if (isObject(input.data)) {
            _data = $$FooRecursiveUnion.fromJson(input.data);
        } else {
            _data = FooRecursiveUnion.new();
        }
        return {
            type: _type,
            data: _data,
        };
    },
    fromJsonString(input): FooRecursiveUnionChild {
        return $$FooRecursiveUnionChild.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"type":"CHILD"';
        json += ',"data":';
        json += $$FooRecursiveUnion.toJsonString(input.data);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push('type=CHILD');
        console.warn(
            '[WARNING] Nested objects cannot be serialized to query string. Ignoring property at /RecursiveUnionChild/data.',
        );
        return queryParts.join('&');
    },
};

/**
 * List of children node
 */
export interface FooRecursiveUnionChildren {
    type: 'CHILDREN';
    data: FooRecursiveUnion[];
}
const $$FooRecursiveUnionChildren: ArriModelValidator<FooRecursiveUnionChildren> =
    {
        new(): FooRecursiveUnionChildren {
            return {
                type: 'CHILDREN',
                data: [],
            };
        },
        validate(input): input is FooRecursiveUnionChildren {
            return (
                isObject(input) &&
                input.type === 'CHILDREN' &&
                Array.isArray(input.data) &&
                input.data.every((_element) =>
                    $$FooRecursiveUnion.validate(_element),
                )
            );
        },
        fromJson(input): FooRecursiveUnionChildren {
            const _type = 'CHILDREN';
            let _data: FooRecursiveUnion[];
            if (Array.isArray(input.data)) {
                _data = [];
                for (const _dataEl of input.data) {
                    let _dataElValue: FooRecursiveUnion;
                    if (isObject(_dataEl)) {
                        _dataElValue = $$FooRecursiveUnion.fromJson(_dataEl);
                    } else {
                        _dataElValue = FooRecursiveUnion.new();
                    }
                    _data.push(_dataElValue);
                }
            } else {
                _data = [];
            }
            return {
                type: _type,
                data: _data,
            };
        },
        fromJsonString(input): FooRecursiveUnionChildren {
            return $$FooRecursiveUnionChildren.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"type":"CHILDREN"';
            json += ',"data":';
            json += '[';
            for (let i = 0; i < input.data.length; i++) {
                if (i !== 0) json += ',';
                const _inputDataEl = input.data[i];
                json += $$FooRecursiveUnion.toJsonString(_inputDataEl);
            }
            json += ']';
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('type=CHILDREN');
            console.warn(
                '[WARNING] Cannot serialize arrays to query string. Skipping property at /RecursiveUnionChildren/data.',
            );
            return queryParts.join('&');
        },
    };

/**
 * Text node
 */
export interface FooRecursiveUnionText {
    type: 'TEXT';
    data: string;
}
const $$FooRecursiveUnionText: ArriModelValidator<FooRecursiveUnionText> = {
    new(): FooRecursiveUnionText {
        return {
            type: 'TEXT',
            data: '',
        };
    },
    validate(input): input is FooRecursiveUnionText {
        return (
            isObject(input) &&
            input.type === 'TEXT' &&
            typeof input.data === 'string'
        );
    },
    fromJson(input): FooRecursiveUnionText {
        const _type = 'TEXT';
        let _data: string;
        if (typeof input.data === 'string') {
            _data = input.data;
        } else {
            _data = '';
        }
        return {
            type: _type,
            data: _data,
        };
    },
    fromJsonString(input): FooRecursiveUnionText {
        return $$FooRecursiveUnionText.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"type":"TEXT"';
        json += ',"data":';
        json += serializeString(input.data);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push('type=TEXT');
        queryParts.push(`data=${input.data}`);
        return queryParts.join('&');
    },
};

/**
 * Shape node
 */
export interface FooRecursiveUnionShape {
    type: 'SHAPE';
    data: FooRecursiveUnionShapeData;
}
const $$FooRecursiveUnionShape: ArriModelValidator<FooRecursiveUnionShape> = {
    new(): FooRecursiveUnionShape {
        return {
            type: 'SHAPE',
            data: $$FooRecursiveUnionShapeData.new(),
        };
    },
    validate(input): input is FooRecursiveUnionShape {
        return (
            isObject(input) &&
            input.type === 'SHAPE' &&
            $$FooRecursiveUnionShapeData.validate(input.data)
        );
    },
    fromJson(input): FooRecursiveUnionShape {
        const _type = 'SHAPE';
        let _data: FooRecursiveUnionShapeData;
        if (isObject(input.data)) {
            _data = $$FooRecursiveUnionShapeData.fromJson(input.data);
        } else {
            _data = $$FooRecursiveUnionShapeData.new();
        }
        return {
            type: _type,
            data: _data,
        };
    },
    fromJsonString(input): FooRecursiveUnionShape {
        return $$FooRecursiveUnionShape.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"type":"SHAPE"';
        json += ',"data":';
        json += $$FooRecursiveUnionShapeData.toJsonString(input.data);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push('type=SHAPE');
        console.warn(
            '[WARNING] Cannot serialize nested objects to query string. Skipping property at /RecursiveUnionShape/data.',
        );
        return queryParts.join('&');
    },
};

export interface FooRecursiveUnionShapeData {
    width: number;
    height: number;
    color: string;
}
export const $$FooRecursiveUnionShapeData: ArriModelValidator<FooRecursiveUnionShapeData> =
    {
        new(): FooRecursiveUnionShapeData {
            return {
                width: 0,
                height: 0,
                color: '',
            };
        },
        validate(input): input is FooRecursiveUnionShapeData {
            return (
                isObject(input) &&
                typeof input.width === 'number' &&
                typeof input.height === 'number' &&
                typeof input.color === 'string'
            );
        },
        fromJson(input): FooRecursiveUnionShapeData {
            let _width: number;
            if (typeof input.width === 'number') {
                _width = input.width;
            } else {
                _width = 0;
            }
            let _height: number;
            if (typeof input.height === 'number') {
                _height = input.height;
            } else {
                _height = 0;
            }
            let _color: string;
            if (typeof input.color === 'string') {
                _color = input.color;
            } else {
                _color = '';
            }
            return {
                width: _width,
                height: _height,
                color: _color,
            };
        },
        fromJsonString(input): FooRecursiveUnionShapeData {
            return $$FooRecursiveUnionShapeData.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"width":';
            json += `${input.width}`;
            json += ',"height":';
            json += `${input.height}`;
            json += ',"color":';
            json += serializeString(input.color);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`width=${input.width}`);
            queryParts.push(`height=${input.height}`);
            queryParts.push(`color=${input.color}`);
            return queryParts.join('&');
        },
    };

export interface FooAutoReconnectParams {
    messageCount: number;
}
export const $$FooAutoReconnectParams: ArriModelValidator<FooAutoReconnectParams> =
    {
        new(): FooAutoReconnectParams {
            return {
                messageCount: 0,
            };
        },
        validate(input): input is FooAutoReconnectParams {
            return (
                isObject(input) &&
                typeof input.messageCount === 'number' &&
                Number.isInteger(input.messageCount) &&
                input.messageCount >= 0 &&
                input.messageCount <= UINT8_MAX
            );
        },
        fromJson(input): FooAutoReconnectParams {
            let _messageCount: number;
            if (
                typeof input.messageCount === 'number' &&
                Number.isInteger(input.messageCount) &&
                input.messageCount >= 0 &&
                input.messageCount <= UINT8_MAX
            ) {
                _messageCount = input.messageCount;
            } else {
                _messageCount = 0;
            }
            return {
                messageCount: _messageCount,
            };
        },
        fromJsonString(input): FooAutoReconnectParams {
            return $$FooAutoReconnectParams.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"messageCount":';
            json += `${input.messageCount}`;
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`messageCount=${input.messageCount}`);
            return queryParts.join('&');
        },
    };

export interface FooAutoReconnectResponse {
    count: number;
    message: string;
}
export const $$FooAutoReconnectResponse: ArriModelValidator<FooAutoReconnectResponse> =
    {
        new(): FooAutoReconnectResponse {
            return {
                count: 0,
                message: '',
            };
        },
        validate(input): input is FooAutoReconnectResponse {
            return (
                isObject(input) &&
                typeof input.count === 'number' &&
                Number.isInteger(input.count) &&
                input.count >= 0 &&
                input.count <= UINT8_MAX &&
                typeof input.message === 'string'
            );
        },
        fromJson(input): FooAutoReconnectResponse {
            let _count: number;
            if (
                typeof input.count === 'number' &&
                Number.isInteger(input.count) &&
                input.count >= 0 &&
                input.count <= UINT8_MAX
            ) {
                _count = input.count;
            } else {
                _count = 0;
            }
            let _message: string;
            if (typeof input.message === 'string') {
                _message = input.message;
            } else {
                _message = '';
            }
            return {
                count: _count,
                message: _message,
            };
        },
        fromJsonString(input): FooAutoReconnectResponse {
            return $$FooAutoReconnectResponse.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"count":';
            json += `${input.count}`;
            json += ',"message":';
            json += serializeString(input.message);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`count=${input.count}`);
            queryParts.push(`message=${input.message}`);
            return queryParts.join('&');
        },
    };

export interface FooStreamConnectionErrorTestParams {
    statusCode: number;
    statusMessage: string;
}
export const $$FooStreamConnectionErrorTestParams: ArriModelValidator<FooStreamConnectionErrorTestParams> =
    {
        new(): FooStreamConnectionErrorTestParams {
            return {
                statusCode: 0,
                statusMessage: '',
            };
        },
        validate(input): input is FooStreamConnectionErrorTestParams {
            return (
                isObject(input) &&
                typeof input.statusCode === 'number' &&
                Number.isInteger(input.statusCode) &&
                input.statusCode >= INT32_MIN &&
                input.statusCode <= INT32_MAX &&
                typeof input.statusMessage === 'string'
            );
        },
        fromJson(input): FooStreamConnectionErrorTestParams {
            let _statusCode: number;
            if (
                typeof input.statusCode === 'number' &&
                Number.isInteger(input.statusCode) &&
                input.statusCode >= INT32_MIN &&
                input.statusCode <= INT32_MAX
            ) {
                _statusCode = input.statusCode;
            } else {
                _statusCode = 0;
            }
            let _statusMessage: string;
            if (typeof input.statusMessage === 'string') {
                _statusMessage = input.statusMessage;
            } else {
                _statusMessage = '';
            }
            return {
                statusCode: _statusCode,
                statusMessage: _statusMessage,
            };
        },
        fromJsonString(input): FooStreamConnectionErrorTestParams {
            return $$FooStreamConnectionErrorTestParams.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"statusCode":';
            json += `${input.statusCode}`;
            json += ',"statusMessage":';
            json += serializeString(input.statusMessage);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`statusCode=${input.statusCode}`);
            queryParts.push(`statusMessage=${input.statusMessage}`);
            return queryParts.join('&');
        },
    };

export interface FooStreamConnectionErrorTestResponse {
    message: string;
}
export const $$FooStreamConnectionErrorTestResponse: ArriModelValidator<FooStreamConnectionErrorTestResponse> =
    {
        new(): FooStreamConnectionErrorTestResponse {
            return {
                message: '',
            };
        },
        validate(input): input is FooStreamConnectionErrorTestResponse {
            return isObject(input) && typeof input.message === 'string';
        },
        fromJson(input): FooStreamConnectionErrorTestResponse {
            let _message: string;
            if (typeof input.message === 'string') {
                _message = input.message;
            } else {
                _message = '';
            }
            return {
                message: _message,
            };
        },
        fromJsonString(input): FooStreamConnectionErrorTestResponse {
            return $$FooStreamConnectionErrorTestResponse.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"message":';
            json += serializeString(input.message);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`message=${input.message}`);
            return queryParts.join('&');
        },
    };

export interface FooStreamLargeObjectsResponse {
    numbers: number[];
    objects: FooStreamLargeObjectsResponseObjectsElement[];
}
export const $$FooStreamLargeObjectsResponse: ArriModelValidator<FooStreamLargeObjectsResponse> =
    {
        new(): FooStreamLargeObjectsResponse {
            return {
                numbers: [],
                objects: [],
            };
        },
        validate(input): input is FooStreamLargeObjectsResponse {
            return (
                isObject(input) &&
                Array.isArray(input.numbers) &&
                input.numbers.every(
                    (_element) => typeof _element === 'number',
                ) &&
                Array.isArray(input.objects) &&
                input.objects.every((_element) =>
                    $$FooStreamLargeObjectsResponseObjectsElement.validate(
                        _element,
                    ),
                )
            );
        },
        fromJson(input): FooStreamLargeObjectsResponse {
            let _numbers: number[];
            if (Array.isArray(input.numbers)) {
                _numbers = [];
                for (const _numbersEl of input.numbers) {
                    let _numbersElValue: number;
                    if (typeof _numbersEl === 'number') {
                        _numbersElValue = _numbersEl;
                    } else {
                        _numbersElValue = 0;
                    }
                    _numbers.push(_numbersElValue);
                }
            } else {
                _numbers = [];
            }
            let _objects: FooStreamLargeObjectsResponseObjectsElement[];
            if (Array.isArray(input.objects)) {
                _objects = [];
                for (const _objectsEl of input.objects) {
                    let _objectsElValue: FooStreamLargeObjectsResponseObjectsElement;
                    if (isObject(_objectsEl)) {
                        _objectsElValue =
                            $$FooStreamLargeObjectsResponseObjectsElement.fromJson(
                                _objectsEl,
                            );
                    } else {
                        _objectsElValue =
                            $$FooStreamLargeObjectsResponseObjectsElement.new();
                    }
                    _objects.push(_objectsElValue);
                }
            } else {
                _objects = [];
            }
            return {
                numbers: _numbers,
                objects: _objects,
            };
        },
        fromJsonString(input): FooStreamLargeObjectsResponse {
            return $$FooStreamLargeObjectsResponse.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"numbers":';
            json += '[';
            for (let i = 0; i < input.numbers.length; i++) {
                if (i !== 0) json += ',';
                const _inputNumbersEl = input.numbers[i];
                json += `${_inputNumbersEl}`;
            }
            json += ']';
            json += ',"objects":';
            json += '[';
            for (let i = 0; i < input.objects.length; i++) {
                if (i !== 0) json += ',';
                const _inputObjectsEl = input.objects[i];
                json +=
                    $$FooStreamLargeObjectsResponseObjectsElement.toJsonString(
                        _inputObjectsEl,
                    );
            }
            json += ']';
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            console.warn(
                '[WARNING] Cannot serialize arrays to query string. Skipping property at /StreamLargeObjectsResponse/numbers.',
            );
            console.warn(
                '[WARNING] Cannot serialize arrays to query string. Skipping property at /StreamLargeObjectsResponse/objects.',
            );
            return queryParts.join('&');
        },
    };

export interface FooStreamLargeObjectsResponseObjectsElement {
    id: string;
    name: string;
    email: string;
}
export const $$FooStreamLargeObjectsResponseObjectsElement: ArriModelValidator<FooStreamLargeObjectsResponseObjectsElement> =
    {
        new(): FooStreamLargeObjectsResponseObjectsElement {
            return {
                id: '',
                name: '',
                email: '',
            };
        },
        validate(input): input is FooStreamLargeObjectsResponseObjectsElement {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                typeof input.name === 'string' &&
                typeof input.email === 'string'
            );
        },
        fromJson(input): FooStreamLargeObjectsResponseObjectsElement {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _name: string;
            if (typeof input.name === 'string') {
                _name = input.name;
            } else {
                _name = '';
            }
            let _email: string;
            if (typeof input.email === 'string') {
                _email = input.email;
            } else {
                _email = '';
            }
            return {
                id: _id,
                name: _name,
                email: _email,
            };
        },
        fromJsonString(input): FooStreamLargeObjectsResponseObjectsElement {
            return $$FooStreamLargeObjectsResponseObjectsElement.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"name":';
            json += serializeString(input.name);
            json += ',"email":';
            json += serializeString(input.email);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`name=${input.name}`);
            queryParts.push(`email=${input.email}`);
            return queryParts.join('&');
        },
    };

export interface FooChatMessageParams {
    channelId: string;
}
export const $$FooChatMessageParams: ArriModelValidator<FooChatMessageParams> =
    {
        new(): FooChatMessageParams {
            return {
                channelId: '',
            };
        },
        validate(input): input is FooChatMessageParams {
            return isObject(input) && typeof input.channelId === 'string';
        },
        fromJson(input): FooChatMessageParams {
            let _channelId: string;
            if (typeof input.channelId === 'string') {
                _channelId = input.channelId;
            } else {
                _channelId = '';
            }
            return {
                channelId: _channelId,
            };
        },
        fromJsonString(input): FooChatMessageParams {
            return $$FooChatMessageParams.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"channelId":';
            json += serializeString(input.channelId);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`channelId=${input.channelId}`);
            return queryParts.join('&');
        },
    };

export type FooChatMessage =
    | FooChatMessageText
    | FooChatMessageImage
    | FooChatMessageUrl;
export const $$FooChatMessage: ArriModelValidator<FooChatMessage> = {
    new(): FooChatMessage {
        return $$FooChatMessageText.new();
    },
    validate(input): input is FooChatMessage {
        if (!isObject(input)) {
            return false;
        }
        if (typeof input.messageType !== 'string') {
            return false;
        }
        switch (input.messageType) {
            case 'TEXT':
                return $$FooChatMessageText.validate(input);
            case 'IMAGE':
                return $$FooChatMessageImage.validate(input);
            case 'URL':
                return $$FooChatMessageUrl.validate(input);
            default:
                return false;
        }
    },
    fromJson(input): FooChatMessage {
        switch (input.messageType) {
            case 'TEXT':
                return $$FooChatMessageText.fromJson(input);
            case 'IMAGE':
                return $$FooChatMessageImage.fromJson(input);
            case 'URL':
                return $$FooChatMessageUrl.fromJson(input);
            default:
                return $$FooChatMessageText.new();
        }
    },
    fromJsonString(input): FooChatMessage {
        return $$FooChatMessage.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        switch (input.messageType) {
            case 'TEXT':
                return $$FooChatMessageText.toJsonString(input);
            case 'IMAGE':
                return $$FooChatMessageImage.toJsonString(input);
            case 'URL':
                return $$FooChatMessageUrl.toJsonString(input);
            default:
                throw new Error(
                    `Unhandled case "${(input as any).messageType}"`,
                );
        }
    },
    toUrlQueryString(input): string {
        switch (input.messageType) {
            case 'TEXT':
                return $$FooChatMessageText.toUrlQueryString(input);
            case 'IMAGE':
                return $$FooChatMessageImage.toUrlQueryString(input);
            case 'URL':
                return $$FooChatMessageUrl.toUrlQueryString(input);
            default:
                throw new Error('Unhandled case');
        }
    },
};
export interface FooChatMessageText {
    messageType: 'TEXT';
    id: string;
    channelId: string;
    userId: string;
    date: Date;
    text: string;
}
const $$FooChatMessageText: ArriModelValidator<FooChatMessageText> = {
    new(): FooChatMessageText {
        return {
            messageType: 'TEXT',
            id: '',
            channelId: '',
            userId: '',
            date: new Date(),
            text: '',
        };
    },
    validate(input): input is FooChatMessageText {
        return (
            isObject(input) &&
            input.messageType === 'TEXT' &&
            typeof input.id === 'string' &&
            typeof input.channelId === 'string' &&
            typeof input.userId === 'string' &&
            input.date instanceof Date &&
            typeof input.text === 'string'
        );
    },
    fromJson(input): FooChatMessageText {
        const _messageType = 'TEXT';
        let _id: string;
        if (typeof input.id === 'string') {
            _id = input.id;
        } else {
            _id = '';
        }
        let _channelId: string;
        if (typeof input.channelId === 'string') {
            _channelId = input.channelId;
        } else {
            _channelId = '';
        }
        let _userId: string;
        if (typeof input.userId === 'string') {
            _userId = input.userId;
        } else {
            _userId = '';
        }
        let _date: Date;
        if (typeof input.date === 'string') {
            _date = new Date(input.date);
        } else if (input.date instanceof Date) {
            _date = input.date;
        } else {
            _date = new Date();
        }
        let _text: string;
        if (typeof input.text === 'string') {
            _text = input.text;
        } else {
            _text = '';
        }
        return {
            messageType: _messageType,
            id: _id,
            channelId: _channelId,
            userId: _userId,
            date: _date,
            text: _text,
        };
    },
    fromJsonString(input): FooChatMessageText {
        return $$FooChatMessageText.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"messageType":"TEXT"';
        json += ',"id":';
        json += serializeString(input.id);
        json += ',"channelId":';
        json += serializeString(input.channelId);
        json += ',"userId":';
        json += serializeString(input.userId);
        json += ',"date":';
        json += `"${input.date.toISOString()}"`;
        json += ',"text":';
        json += serializeString(input.text);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push('messageType=TEXT');
        queryParts.push(`id=${input.id}`);
        queryParts.push(`channelId=${input.channelId}`);
        queryParts.push(`userId=${input.userId}`);
        queryParts.push(`date=${input.date.toISOString()}`);
        queryParts.push(`text=${input.text}`);
        return queryParts.join('&');
    },
};

export interface FooChatMessageImage {
    messageType: 'IMAGE';
    id: string;
    channelId: string;
    userId: string;
    date: Date;
    image: string;
}
const $$FooChatMessageImage: ArriModelValidator<FooChatMessageImage> = {
    new(): FooChatMessageImage {
        return {
            messageType: 'IMAGE',
            id: '',
            channelId: '',
            userId: '',
            date: new Date(),
            image: '',
        };
    },
    validate(input): input is FooChatMessageImage {
        return (
            isObject(input) &&
            input.messageType === 'IMAGE' &&
            typeof input.id === 'string' &&
            typeof input.channelId === 'string' &&
            typeof input.userId === 'string' &&
            input.date instanceof Date &&
            typeof input.image === 'string'
        );
    },
    fromJson(input): FooChatMessageImage {
        const _messageType = 'IMAGE';
        let _id: string;
        if (typeof input.id === 'string') {
            _id = input.id;
        } else {
            _id = '';
        }
        let _channelId: string;
        if (typeof input.channelId === 'string') {
            _channelId = input.channelId;
        } else {
            _channelId = '';
        }
        let _userId: string;
        if (typeof input.userId === 'string') {
            _userId = input.userId;
        } else {
            _userId = '';
        }
        let _date: Date;
        if (typeof input.date === 'string') {
            _date = new Date(input.date);
        } else if (input.date instanceof Date) {
            _date = input.date;
        } else {
            _date = new Date();
        }
        let _image: string;
        if (typeof input.image === 'string') {
            _image = input.image;
        } else {
            _image = '';
        }
        return {
            messageType: _messageType,
            id: _id,
            channelId: _channelId,
            userId: _userId,
            date: _date,
            image: _image,
        };
    },
    fromJsonString(input): FooChatMessageImage {
        return $$FooChatMessageImage.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"messageType":"IMAGE"';
        json += ',"id":';
        json += serializeString(input.id);
        json += ',"channelId":';
        json += serializeString(input.channelId);
        json += ',"userId":';
        json += serializeString(input.userId);
        json += ',"date":';
        json += `"${input.date.toISOString()}"`;
        json += ',"image":';
        json += serializeString(input.image);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push('messageType=IMAGE');
        queryParts.push(`id=${input.id}`);
        queryParts.push(`channelId=${input.channelId}`);
        queryParts.push(`userId=${input.userId}`);
        queryParts.push(`date=${input.date.toISOString()}`);
        queryParts.push(`image=${input.image}`);
        return queryParts.join('&');
    },
};

export interface FooChatMessageUrl {
    messageType: 'URL';
    id: string;
    channelId: string;
    userId: string;
    date: Date;
    url: string;
}
const $$FooChatMessageUrl: ArriModelValidator<FooChatMessageUrl> = {
    new(): FooChatMessageUrl {
        return {
            messageType: 'URL',
            id: '',
            channelId: '',
            userId: '',
            date: new Date(),
            url: '',
        };
    },
    validate(input): input is FooChatMessageUrl {
        return (
            isObject(input) &&
            input.messageType === 'URL' &&
            typeof input.id === 'string' &&
            typeof input.channelId === 'string' &&
            typeof input.userId === 'string' &&
            input.date instanceof Date &&
            typeof input.url === 'string'
        );
    },
    fromJson(input): FooChatMessageUrl {
        const _messageType = 'URL';
        let _id: string;
        if (typeof input.id === 'string') {
            _id = input.id;
        } else {
            _id = '';
        }
        let _channelId: string;
        if (typeof input.channelId === 'string') {
            _channelId = input.channelId;
        } else {
            _channelId = '';
        }
        let _userId: string;
        if (typeof input.userId === 'string') {
            _userId = input.userId;
        } else {
            _userId = '';
        }
        let _date: Date;
        if (typeof input.date === 'string') {
            _date = new Date(input.date);
        } else if (input.date instanceof Date) {
            _date = input.date;
        } else {
            _date = new Date();
        }
        let _url: string;
        if (typeof input.url === 'string') {
            _url = input.url;
        } else {
            _url = '';
        }
        return {
            messageType: _messageType,
            id: _id,
            channelId: _channelId,
            userId: _userId,
            date: _date,
            url: _url,
        };
    },
    fromJsonString(input): FooChatMessageUrl {
        return $$FooChatMessageUrl.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"messageType":"URL"';
        json += ',"id":';
        json += serializeString(input.id);
        json += ',"channelId":';
        json += serializeString(input.channelId);
        json += ',"userId":';
        json += serializeString(input.userId);
        json += ',"date":';
        json += `"${input.date.toISOString()}"`;
        json += ',"url":';
        json += serializeString(input.url);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push('messageType=URL');
        queryParts.push(`id=${input.id}`);
        queryParts.push(`channelId=${input.channelId}`);
        queryParts.push(`userId=${input.userId}`);
        queryParts.push(`date=${input.date.toISOString()}`);
        queryParts.push(`url=${input.url}`);
        return queryParts.join('&');
    },
};

export interface FooTestsStreamRetryWithNewCredentialsResponse {
    message: string;
}
export const $$FooTestsStreamRetryWithNewCredentialsResponse: ArriModelValidator<FooTestsStreamRetryWithNewCredentialsResponse> =
    {
        new(): FooTestsStreamRetryWithNewCredentialsResponse {
            return {
                message: '',
            };
        },
        validate(
            input,
        ): input is FooTestsStreamRetryWithNewCredentialsResponse {
            return isObject(input) && typeof input.message === 'string';
        },
        fromJson(input): FooTestsStreamRetryWithNewCredentialsResponse {
            let _message: string;
            if (typeof input.message === 'string') {
                _message = input.message;
            } else {
                _message = '';
            }
            return {
                message: _message,
            };
        },
        fromJsonString(input): FooTestsStreamRetryWithNewCredentialsResponse {
            return $$FooTestsStreamRetryWithNewCredentialsResponse.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"message":';
            json += serializeString(input.message);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`message=${input.message}`);
            return queryParts.join('&');
        },
    };

export interface FooUsersWatchUserParams {
    userId: string;
}
export const $$FooUsersWatchUserParams: ArriModelValidator<FooUsersWatchUserParams> =
    {
        new(): FooUsersWatchUserParams {
            return {
                userId: '',
            };
        },
        validate(input): input is FooUsersWatchUserParams {
            return isObject(input) && typeof input.userId === 'string';
        },
        fromJson(input): FooUsersWatchUserParams {
            let _userId: string;
            if (typeof input.userId === 'string') {
                _userId = input.userId;
            } else {
                _userId = '';
            }
            return {
                userId: _userId,
            };
        },
        fromJsonString(input): FooUsersWatchUserParams {
            return $$FooUsersWatchUserParams.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"userId":';
            json += serializeString(input.userId);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`userId=${input.userId}`);
            return queryParts.join('&');
        },
    };

export interface FooUsersWatchUserResponse {
    id: string;
    role: FooUsersWatchUserResponseRole;
    /**
     * A profile picture
     */
    photo: FooUserPhoto | null;
    createdAt: Date;
    numFollowers: number;
    settings: FooUserSettings;
    recentNotifications: FooUsersWatchUserResponseRecentNotificationsElement[];
    bookmarks: Record<string, FooUsersWatchUserResponseBookmarksValue>;
    metadata: Record<string, any>;
    randomList: any[];
    bio?: string;
}
export const $$FooUsersWatchUserResponse: ArriModelValidator<FooUsersWatchUserResponse> =
    {
        new(): FooUsersWatchUserResponse {
            return {
                id: '',
                role: $$FooUsersWatchUserResponseRole.new(),
                photo: null,
                createdAt: new Date(),
                numFollowers: 0,
                settings: $$FooUserSettings.new(),
                recentNotifications: [],
                bookmarks: {},
                metadata: {},
                randomList: [],
            };
        },
        validate(input): input is FooUsersWatchUserResponse {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                $$FooUsersWatchUserResponseRole.validate(input.role) &&
                ($$FooUserPhoto.validate(input.photo) ||
                    input.photo === null) &&
                input.createdAt instanceof Date &&
                typeof input.numFollowers === 'number' &&
                Number.isInteger(input.numFollowers) &&
                input.numFollowers >= INT32_MIN &&
                input.numFollowers <= INT32_MAX &&
                $$FooUserSettings.validate(input.settings) &&
                Array.isArray(input.recentNotifications) &&
                input.recentNotifications.every((_element) =>
                    $$FooUsersWatchUserResponseRecentNotificationsElement.validate(
                        _element,
                    ),
                ) &&
                isObject(input.bookmarks) &&
                Object.values(input.bookmarks).every((_value) =>
                    $$FooUsersWatchUserResponseBookmarksValue.validate(_value),
                ) &&
                isObject(input.metadata) &&
                Object.values(input.metadata).every((_value) => true) &&
                Array.isArray(input.randomList) &&
                input.randomList.every((_element) => true) &&
                (typeof input.bio === 'string' ||
                    typeof input.bio === 'undefined')
            );
        },
        fromJson(input): FooUsersWatchUserResponse {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _role: FooUsersWatchUserResponseRole;
            if (typeof input.role === 'string') {
                _role = $$FooUsersWatchUserResponseRole.fromSerialValue(
                    input.role,
                );
            } else {
                _role = $$FooUsersWatchUserResponseRole.new();
            }
            let _photo: FooUserPhoto | null;
            if (isObject(input.photo)) {
                _photo = $$FooUserPhoto.fromJson(input.photo);
            } else {
                _photo = null;
            }
            let _createdAt: Date;
            if (typeof input.createdAt === 'string') {
                _createdAt = new Date(input.createdAt);
            } else if (input.createdAt instanceof Date) {
                _createdAt = input.createdAt;
            } else {
                _createdAt = new Date();
            }
            let _numFollowers: number;
            if (
                typeof input.numFollowers === 'number' &&
                Number.isInteger(input.numFollowers) &&
                input.numFollowers >= INT32_MIN &&
                input.numFollowers <= INT32_MAX
            ) {
                _numFollowers = input.numFollowers;
            } else {
                _numFollowers = 0;
            }
            let _settings: FooUserSettings;
            if (isObject(input.settings)) {
                _settings = $$FooUserSettings.fromJson(input.settings);
            } else {
                _settings = $$FooUserSettings.new();
            }
            let _recentNotifications: FooUsersWatchUserResponseRecentNotificationsElement[];
            if (Array.isArray(input.recentNotifications)) {
                _recentNotifications = [];
                for (const _recentNotificationsEl of input.recentNotifications) {
                    let _recentNotificationsElValue: FooUsersWatchUserResponseRecentNotificationsElement;
                    if (isObject(_recentNotificationsEl)) {
                        _recentNotificationsElValue =
                            $$FooUsersWatchUserResponseRecentNotificationsElement.fromJson(
                                _recentNotificationsEl,
                            );
                    } else {
                        _recentNotificationsElValue =
                            $$FooUsersWatchUserResponseRecentNotificationsElement.new();
                    }
                    _recentNotifications.push(_recentNotificationsElValue);
                }
            } else {
                _recentNotifications = [];
            }
            let _bookmarks: Record<
                string,
                FooUsersWatchUserResponseBookmarksValue
            >;
            if (isObject(input.bookmarks)) {
                _bookmarks = {};
                for (const [_key, _value] of Object.entries(input.bookmarks)) {
                    let _bookmarksValue: FooUsersWatchUserResponseBookmarksValue;
                    if (isObject(_value)) {
                        _bookmarksValue =
                            $$FooUsersWatchUserResponseBookmarksValue.fromJson(
                                _value,
                            );
                    } else {
                        _bookmarksValue =
                            $$FooUsersWatchUserResponseBookmarksValue.new();
                    }
                    _bookmarks[_key] = _bookmarksValue;
                }
            } else {
                _bookmarks = {};
            }
            let _metadata: Record<string, any>;
            if (isObject(input.metadata)) {
                _metadata = {};
                for (const [_key, _value] of Object.entries(input.metadata)) {
                    let _metadataValue: any;
                    _metadataValue = _value;
                    _metadata[_key] = _metadataValue;
                }
            } else {
                _metadata = {};
            }
            let _randomList: any[];
            if (Array.isArray(input.randomList)) {
                _randomList = [];
                for (const _randomListEl of input.randomList) {
                    let _randomListElValue: any;
                    _randomListElValue = _randomListEl;
                    _randomList.push(_randomListElValue);
                }
            } else {
                _randomList = [];
            }
            let _bio: string | undefined;
            if (typeof input.bio !== 'undefined') {
                if (typeof input.bio === 'string') {
                    _bio = input.bio;
                } else {
                    _bio = '';
                }
            }
            return {
                id: _id,
                role: _role,
                photo: _photo,
                createdAt: _createdAt,
                numFollowers: _numFollowers,
                settings: _settings,
                recentNotifications: _recentNotifications,
                bookmarks: _bookmarks,
                metadata: _metadata,
                randomList: _randomList,
                bio: _bio,
            };
        },
        fromJsonString(input): FooUsersWatchUserResponse {
            return $$FooUsersWatchUserResponse.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"role":';
            json += `"${input.role}"`;
            json += ',"photo":';
            if (input.photo !== null) {
                json += $$FooUserPhoto.toJsonString(input.photo);
            } else {
                json += 'null';
            }
            json += ',"createdAt":';
            json += `"${input.createdAt.toISOString()}"`;
            json += ',"numFollowers":';
            json += `${input.numFollowers}`;
            json += ',"settings":';
            json += $$FooUserSettings.toJsonString(input.settings);
            json += ',"recentNotifications":';
            json += '[';
            for (let i = 0; i < input.recentNotifications.length; i++) {
                if (i !== 0) json += ',';
                const _inputRecentNotificationsEl =
                    input.recentNotifications[i];
                json +=
                    $$FooUsersWatchUserResponseRecentNotificationsElement.toJsonString(
                        _inputRecentNotificationsEl,
                    );
            }
            json += ']';
            json += ',"bookmarks":';
            json += '{';
            let _bookmarksPropertyCount = 0;
            for (const [_key, _value] of Object.entries(input.bookmarks)) {
                if (_bookmarksPropertyCount !== 0) {
                    json += ',';
                }
                json += `${serializeString(_key)}:`;
                json +=
                    $$FooUsersWatchUserResponseBookmarksValue.toJsonString(
                        _value,
                    );
                _bookmarksPropertyCount++;
            }
            json += '}';

            json += ',"metadata":';
            json += '{';
            let _metadataPropertyCount = 0;
            for (const [_key, _value] of Object.entries(input.metadata)) {
                if (_metadataPropertyCount !== 0) {
                    json += ',';
                }
                json += `${serializeString(_key)}:`;
                json += JSON.stringify(_value);
                _metadataPropertyCount++;
            }
            json += '}';

            json += ',"randomList":';
            json += '[';
            for (let i = 0; i < input.randomList.length; i++) {
                if (i !== 0) json += ',';
                const _inputRandomListEl = input.randomList[i];
                json += JSON.stringify(_inputRandomListEl);
            }
            json += ']';
            if (typeof input.bio !== 'undefined') {
                json += `,"bio":`;
                json += serializeString(input.bio);
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`role=${input.role}`);
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /UsersWatchUserResponse/photo.',
            );
            queryParts.push(`createdAt=${input.createdAt.toISOString()}`);
            queryParts.push(`numFollowers=${input.numFollowers}`);
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /UsersWatchUserResponse/settings.',
            );
            console.warn(
                '[WARNING] Cannot serialize arrays to query string. Skipping property at /UsersWatchUserResponse/recentNotifications.',
            );
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /UsersWatchUserResponse/bookmarks.',
            );
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /UsersWatchUserResponse/metadata.',
            );
            console.warn(
                '[WARNING] Cannot serialize arrays to query string. Skipping property at /UsersWatchUserResponse/randomList.',
            );
            if (typeof input.bio !== 'undefined') {
                queryParts.push(`bio=${input.bio}`);
            }
            return queryParts.join('&');
        },
    };

export type FooUsersWatchUserResponseRole =
    (typeof $$FooUsersWatchUserResponseRoleValues)[number];
const $$FooUsersWatchUserResponseRoleValues = ['standard', 'admin'] as const;
export const $$FooUsersWatchUserResponseRole: ArriEnumValidator<FooUsersWatchUserResponseRole> =
    {
        new(): FooUsersWatchUserResponseRole {
            return $$FooUsersWatchUserResponseRoleValues[0];
        },
        validate(input): input is UsersWatchUserResponseRole {
            return (
                typeof input === 'string' &&
                $$FooUsersWatchUserResponseRoleValues.includes(input as any)
            );
        },
        values: $$FooUsersWatchUserResponseRoleValues,
        fromSerialValue(input): FooUsersWatchUserResponseRole {
            if ($$FooUsersWatchUserResponseRoleValues.includes(input as any)) {
                return input as FooUsersWatchUserResponseRole;
            }
            if (
                $$FooUsersWatchUserResponseRoleValues.includes(
                    input.toLowerCase() as any,
                )
            ) {
                return input.toLowerCase() as FooUsersWatchUserResponseRole;
            }
            if (
                $$FooUsersWatchUserResponseRoleValues.includes(
                    input.toUpperCase() as any,
                )
            ) {
                return input.toUpperCase() as FooUsersWatchUserResponseRole;
            }
            return 'standard';
        },
    };

/**
 * A profile picture
 */
export interface FooUserPhoto {
    url: string;
    width: number;
    height: number;
    bytes: bigint;
    /**
     * When the photo was last updated in nanoseconds
     */
    nanoseconds: bigint;
}
export const $$FooUserPhoto: ArriModelValidator<FooUserPhoto> = {
    new(): FooUserPhoto {
        return {
            url: '',
            width: 0,
            height: 0,
            bytes: BigInt(0),
            nanoseconds: BigInt(0),
        };
    },
    validate(input): input is FooUserPhoto {
        return (
            isObject(input) &&
            typeof input.url === 'string' &&
            typeof input.width === 'number' &&
            typeof input.height === 'number' &&
            typeof input.bytes === 'bigint' &&
            input.bytes >= INT64_MIN &&
            input.bytes <= INT64_MAX &&
            typeof input.nanoseconds === 'bigint' &&
            input.nanoseconds >= BigInt(0) &&
            input.nanoseconds <= UINT64_MAX
        );
    },
    fromJson(input): FooUserPhoto {
        let _url: string;
        if (typeof input.url === 'string') {
            _url = input.url;
        } else {
            _url = '';
        }
        let _width: number;
        if (typeof input.width === 'number') {
            _width = input.width;
        } else {
            _width = 0;
        }
        let _height: number;
        if (typeof input.height === 'number') {
            _height = input.height;
        } else {
            _height = 0;
        }
        let _bytes: bigint;
        if (typeof input.bytes === 'string') {
            _bytes = BigInt(input.bytes);
        } else if (typeof input.bytes === 'bigint') {
            _bytes = input.bytes;
        } else {
            _bytes = BigInt(0);
        }
        let _nanoseconds: bigint;
        if (
            typeof input.nanoseconds === 'string' &&
            BigInt(input.nanoseconds) >= BigInt(0)
        ) {
            _nanoseconds = BigInt(input.nanoseconds);
        } else if (
            typeof input.nanoseconds === 'bigint' &&
            input.nanoseconds >= BigInt(0)
        ) {
            _nanoseconds = input.nanoseconds;
        } else {
            _nanoseconds = BigInt(0);
        }
        return {
            url: _url,
            width: _width,
            height: _height,
            bytes: _bytes,
            nanoseconds: _nanoseconds,
        };
    },
    fromJsonString(input): FooUserPhoto {
        return $$FooUserPhoto.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"url":';
        json += serializeString(input.url);
        json += ',"width":';
        json += `${input.width}`;
        json += ',"height":';
        json += `${input.height}`;
        json += ',"bytes":';
        json += `"${input.bytes}"`;
        json += ',"nanoseconds":';
        json += `"${input.nanoseconds}"`;
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`url=${input.url}`);
        queryParts.push(`width=${input.width}`);
        queryParts.push(`height=${input.height}`);
        queryParts.push(`bytes=${input.bytes}`);
        queryParts.push(`nanoseconds=${input.nanoseconds}`);
        return queryParts.join('&');
    },
};

export interface FooUserSettings {
    notificationsEnabled: boolean;
    preferredTheme: FooUserSettingsPreferredTheme;
}
export const $$FooUserSettings: ArriModelValidator<FooUserSettings> = {
    new(): FooUserSettings {
        return {
            notificationsEnabled: false,
            preferredTheme: $$FooUserSettingsPreferredTheme.new(),
        };
    },
    validate(input): input is FooUserSettings {
        return (
            isObject(input) &&
            typeof input.notificationsEnabled === 'boolean' &&
            $$FooUserSettingsPreferredTheme.validate(input.preferredTheme)
        );
    },
    fromJson(input): FooUserSettings {
        let _notificationsEnabled: boolean;
        if (typeof input.notificationsEnabled === 'boolean') {
            _notificationsEnabled = input.notificationsEnabled;
        } else {
            _notificationsEnabled = false;
        }
        let _preferredTheme: FooUserSettingsPreferredTheme;
        if (typeof input.preferredTheme === 'string') {
            _preferredTheme = $$FooUserSettingsPreferredTheme.fromSerialValue(
                input.preferredTheme,
            );
        } else {
            _preferredTheme = $$FooUserSettingsPreferredTheme.new();
        }
        return {
            notificationsEnabled: _notificationsEnabled,
            preferredTheme: _preferredTheme,
        };
    },
    fromJsonString(input): FooUserSettings {
        return $$FooUserSettings.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"notificationsEnabled":';
        json += `${input.notificationsEnabled}`;
        json += ',"preferredTheme":';
        json += `"${input.preferredTheme}"`;
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`notificationsEnabled=${input.notificationsEnabled}`);
        queryParts.push(`preferredTheme=${input.preferredTheme}`);
        return queryParts.join('&');
    },
};

export type FooUserSettingsPreferredTheme =
    (typeof $$FooUserSettingsPreferredThemeValues)[number];
const $$FooUserSettingsPreferredThemeValues = [
    'dark-mode',
    'light-mode',
    'system',
] as const;
export const $$FooUserSettingsPreferredTheme: ArriEnumValidator<FooUserSettingsPreferredTheme> =
    {
        new(): FooUserSettingsPreferredTheme {
            return $$FooUserSettingsPreferredThemeValues[0];
        },
        validate(input): input is UserSettingsPreferredTheme {
            return (
                typeof input === 'string' &&
                $$FooUserSettingsPreferredThemeValues.includes(input as any)
            );
        },
        values: $$FooUserSettingsPreferredThemeValues,
        fromSerialValue(input): FooUserSettingsPreferredTheme {
            if ($$FooUserSettingsPreferredThemeValues.includes(input as any)) {
                return input as FooUserSettingsPreferredTheme;
            }
            if (
                $$FooUserSettingsPreferredThemeValues.includes(
                    input.toLowerCase() as any,
                )
            ) {
                return input.toLowerCase() as FooUserSettingsPreferredTheme;
            }
            if (
                $$FooUserSettingsPreferredThemeValues.includes(
                    input.toUpperCase() as any,
                )
            ) {
                return input.toUpperCase() as FooUserSettingsPreferredTheme;
            }
            return 'dark-mode';
        },
    };

export type FooUsersWatchUserResponseRecentNotificationsElement =
    | FooUsersWatchUserResponseRecentNotificationsElementPostLike
    | FooUsersWatchUserResponseRecentNotificationsElementPostComment;
export const $$FooUsersWatchUserResponseRecentNotificationsElement: ArriModelValidator<FooUsersWatchUserResponseRecentNotificationsElement> =
    {
        new(): FooUsersWatchUserResponseRecentNotificationsElement {
            return $$FooUsersWatchUserResponseRecentNotificationsElementPostLike.new();
        },
        validate(
            input,
        ): input is FooUsersWatchUserResponseRecentNotificationsElement {
            if (!isObject(input)) {
                return false;
            }
            if (typeof input.notificationType !== 'string') {
                return false;
            }
            switch (input.notificationType) {
                case 'POST_LIKE':
                    return $$FooUsersWatchUserResponseRecentNotificationsElementPostLike.validate(
                        input,
                    );
                case 'POST_COMMENT':
                    return $$FooUsersWatchUserResponseRecentNotificationsElementPostComment.validate(
                        input,
                    );
                default:
                    return false;
            }
        },
        fromJson(input): FooUsersWatchUserResponseRecentNotificationsElement {
            switch (input.notificationType) {
                case 'POST_LIKE':
                    return $$FooUsersWatchUserResponseRecentNotificationsElementPostLike.fromJson(
                        input,
                    );
                case 'POST_COMMENT':
                    return $$FooUsersWatchUserResponseRecentNotificationsElementPostComment.fromJson(
                        input,
                    );
                default:
                    return $$FooUsersWatchUserResponseRecentNotificationsElementPostLike.new();
            }
        },
        fromJsonString(
            input,
        ): FooUsersWatchUserResponseRecentNotificationsElement {
            return $$FooUsersWatchUserResponseRecentNotificationsElement.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            switch (input.notificationType) {
                case 'POST_LIKE':
                    return $$FooUsersWatchUserResponseRecentNotificationsElementPostLike.toJsonString(
                        input,
                    );
                case 'POST_COMMENT':
                    return $$FooUsersWatchUserResponseRecentNotificationsElementPostComment.toJsonString(
                        input,
                    );
                default:
                    throw new Error(
                        `Unhandled case "${(input as any).notificationType}"`,
                    );
            }
        },
        toUrlQueryString(input): string {
            switch (input.notificationType) {
                case 'POST_LIKE':
                    return $$FooUsersWatchUserResponseRecentNotificationsElementPostLike.toUrlQueryString(
                        input,
                    );
                case 'POST_COMMENT':
                    return $$FooUsersWatchUserResponseRecentNotificationsElementPostComment.toUrlQueryString(
                        input,
                    );
                default:
                    throw new Error('Unhandled case');
            }
        },
    };
export interface FooUsersWatchUserResponseRecentNotificationsElementPostLike {
    notificationType: 'POST_LIKE';
    postId: string;
    userId: string;
}
const $$FooUsersWatchUserResponseRecentNotificationsElementPostLike: ArriModelValidator<FooUsersWatchUserResponseRecentNotificationsElementPostLike> =
    {
        new(): FooUsersWatchUserResponseRecentNotificationsElementPostLike {
            return {
                notificationType: 'POST_LIKE',
                postId: '',
                userId: '',
            };
        },
        validate(
            input,
        ): input is FooUsersWatchUserResponseRecentNotificationsElementPostLike {
            return (
                isObject(input) &&
                input.notificationType === 'POST_LIKE' &&
                typeof input.postId === 'string' &&
                typeof input.userId === 'string'
            );
        },
        fromJson(
            input,
        ): FooUsersWatchUserResponseRecentNotificationsElementPostLike {
            const _notificationType = 'POST_LIKE';
            let _postId: string;
            if (typeof input.postId === 'string') {
                _postId = input.postId;
            } else {
                _postId = '';
            }
            let _userId: string;
            if (typeof input.userId === 'string') {
                _userId = input.userId;
            } else {
                _userId = '';
            }
            return {
                notificationType: _notificationType,
                postId: _postId,
                userId: _userId,
            };
        },
        fromJsonString(
            input,
        ): FooUsersWatchUserResponseRecentNotificationsElementPostLike {
            return $$FooUsersWatchUserResponseRecentNotificationsElementPostLike.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"notificationType":"POST_LIKE"';
            json += ',"postId":';
            json += serializeString(input.postId);
            json += ',"userId":';
            json += serializeString(input.userId);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('notificationType=POST_LIKE');
            queryParts.push(`postId=${input.postId}`);
            queryParts.push(`userId=${input.userId}`);
            return queryParts.join('&');
        },
    };

export interface FooUsersWatchUserResponseRecentNotificationsElementPostComment {
    notificationType: 'POST_COMMENT';
    postId: string;
    userId: string;
    commentText: string;
}
const $$FooUsersWatchUserResponseRecentNotificationsElementPostComment: ArriModelValidator<FooUsersWatchUserResponseRecentNotificationsElementPostComment> =
    {
        new(): FooUsersWatchUserResponseRecentNotificationsElementPostComment {
            return {
                notificationType: 'POST_COMMENT',
                postId: '',
                userId: '',
                commentText: '',
            };
        },
        validate(
            input,
        ): input is FooUsersWatchUserResponseRecentNotificationsElementPostComment {
            return (
                isObject(input) &&
                input.notificationType === 'POST_COMMENT' &&
                typeof input.postId === 'string' &&
                typeof input.userId === 'string' &&
                typeof input.commentText === 'string'
            );
        },
        fromJson(
            input,
        ): FooUsersWatchUserResponseRecentNotificationsElementPostComment {
            const _notificationType = 'POST_COMMENT';
            let _postId: string;
            if (typeof input.postId === 'string') {
                _postId = input.postId;
            } else {
                _postId = '';
            }
            let _userId: string;
            if (typeof input.userId === 'string') {
                _userId = input.userId;
            } else {
                _userId = '';
            }
            let _commentText: string;
            if (typeof input.commentText === 'string') {
                _commentText = input.commentText;
            } else {
                _commentText = '';
            }
            return {
                notificationType: _notificationType,
                postId: _postId,
                userId: _userId,
                commentText: _commentText,
            };
        },
        fromJsonString(
            input,
        ): FooUsersWatchUserResponseRecentNotificationsElementPostComment {
            return $$FooUsersWatchUserResponseRecentNotificationsElementPostComment.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"notificationType":"POST_COMMENT"';
            json += ',"postId":';
            json += serializeString(input.postId);
            json += ',"userId":';
            json += serializeString(input.userId);
            json += ',"commentText":';
            json += serializeString(input.commentText);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('notificationType=POST_COMMENT');
            queryParts.push(`postId=${input.postId}`);
            queryParts.push(`userId=${input.userId}`);
            queryParts.push(`commentText=${input.commentText}`);
            return queryParts.join('&');
        },
    };

export interface FooUsersWatchUserResponseBookmarksValue {
    postId: string;
    userId: string;
}
export const $$FooUsersWatchUserResponseBookmarksValue: ArriModelValidator<FooUsersWatchUserResponseBookmarksValue> =
    {
        new(): FooUsersWatchUserResponseBookmarksValue {
            return {
                postId: '',
                userId: '',
            };
        },
        validate(input): input is FooUsersWatchUserResponseBookmarksValue {
            return (
                isObject(input) &&
                typeof input.postId === 'string' &&
                typeof input.userId === 'string'
            );
        },
        fromJson(input): FooUsersWatchUserResponseBookmarksValue {
            let _postId: string;
            if (typeof input.postId === 'string') {
                _postId = input.postId;
            } else {
                _postId = '';
            }
            let _userId: string;
            if (typeof input.userId === 'string') {
                _userId = input.userId;
            } else {
                _userId = '';
            }
            return {
                postId: _postId,
                userId: _userId,
            };
        },
        fromJsonString(input): FooUsersWatchUserResponseBookmarksValue {
            return $$FooUsersWatchUserResponseBookmarksValue.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"postId":';
            json += serializeString(input.postId);
            json += ',"userId":';
            json += serializeString(input.userId);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`postId=${input.postId}`);
            queryParts.push(`userId=${input.userId}`);
            return queryParts.join('&');
        },
    };
