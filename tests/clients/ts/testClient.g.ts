// This file was autogenerated by @arrirpc/codegen-ts. Do not modify directly.
// For more information visit https://github.com/modiimedia/arri

/* eslint-disable */
// @ts-nocheck
import {
    ArriEnumValidator,
    ArriModelValidator,
    UndefinedModelValidator,
    INT8_MAX,
    INT8_MIN,
    INT16_MAX,
    INT16_MIN,
    INT32_MAX,
    INT32_MIN,
    INT64_MAX,
    INT64_MIN,
    isObject,
    serializeString,
    UINT8_MAX,
    UINT16_MAX,
    UINT32_MAX,
    UINT64_MAX,
    type Fetch,
    type RpcDispatcher,
    type RpcDispatcherOptions,
    type RpcRequest,
    type RpcRequestValidator,
    HttpDispatcher,
    WsDispatcher,
    type EventStreamController,
    type EventStreamHooks,
    resolveDispatcherOptions,
    resolveTransport,
} from '@arrirpc/client';

export interface TestClientOptions
    extends Omit<RpcDispatcherOptions, 'signal'> {
    transport?: 'http' | 'ws';
    dispatchers?: Record<string, RpcDispatcher>;
    // HTTP options
    baseUrl: string;
    fetch?: Fetch;
    // WS options
    wsConnectionUrl: string;
}

export interface RpcOptions<T extends string> extends RpcDispatcherOptions {
    transport?: T;
}

export class TestClient {
    private readonly _dispatchers: Record<string, RpcDispatcher>;
    private readonly _options: RpcDispatcherOptions;
    private readonly _defaultTransport: string;
    tests: TestClientTestsService;
    users: TestClientUsersService;
    constructor(config: TestClientOptions) {
        this._options = {
            headers: config.headers,
            onError: config.onError,
            retry: config.retry,
            retryDelay: config.retryDelay,
            retryErrorCodes: config.retryErrorCodes,
            timeout: config.timeout,
        };
        this._defaultTransport = config.transport ?? 'http';
        if (!config.dispatchers) config.dispatchers = {};
        if (!config.dispatchers['http']) {
            config.dispatchers['http'] = new HttpDispatcher(config);
        }
        if (!config.dispatchers['ws']) {
            config.dispatchers['ws'] = new WsDispatcher(config);
        }
        this._dispatchers = config.dispatchers!;
        this.tests = new TestClientTestsService(config);
        this.users = new TestClientUsersService(config);
    }
}

export class TestClientTestsService {
    private readonly _dispatchers: Record<string, RpcDispatcher>;
    private readonly _options: RpcDispatcherOptions;
    private readonly _defaultTransport: string;

    constructor(config: TestClientOptions) {
        this._options = {
            headers: config.headers,
            onError: config.onError,
            retry: config.retry,
            retryDelay: config.retryDelay,
            retryErrorCodes: config.retryErrorCodes,
            timeout: config.timeout,
        };
        this._defaultTransport = config.transport ?? 'http';
        if (!config.dispatchers) config.dispatchers = {};
        if (!config.dispatchers['http']) {
            config.dispatchers['http'] = new HttpDispatcher(config);
        }
        if (!config.dispatchers['ws']) {
            config.dispatchers['ws'] = new WsDispatcher(config);
        }
        this._dispatchers = config.dispatchers!;
    }
    async emptyParamsGetRequest(
        options?: RpcOptions<'http'>,
    ): Promise<DefaultPayload> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<undefined> = {
            procedure: 'tests.emptyParamsGetRequest',
            path: '/rpcs/tests/empty-params-get-request',
            method: 'get',
            clientVersion: '10',
            data: undefined,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<undefined, DefaultPayload> = {
            params: UndefinedModelValidator,
            response: $$DefaultPayload,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<undefined, DefaultPayload>(
            req,
            validator,
            finalOptions,
        );
    }
    async emptyParamsPostRequest(
        options?: RpcOptions<'http'>,
    ): Promise<DefaultPayload> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<undefined> = {
            procedure: 'tests.emptyParamsPostRequest',
            path: '/rpcs/tests/empty-params-post-request',
            method: undefined,
            clientVersion: '10',
            data: undefined,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<undefined, DefaultPayload> = {
            params: UndefinedModelValidator,
            response: $$DefaultPayload,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<undefined, DefaultPayload>(
            req,
            validator,
            finalOptions,
        );
    }
    async emptyResponseGetRequest(
        params: DefaultPayload,
        options?: RpcOptions<'http'>,
    ): Promise<undefined> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<DefaultPayload> = {
            procedure: 'tests.emptyResponseGetRequest',
            path: '/rpcs/tests/empty-response-get-request',
            method: 'get',
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<DefaultPayload, undefined> = {
            params: $$DefaultPayload,
            response: UndefinedModelValidator,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<DefaultPayload, undefined>(
            req,
            validator,
            finalOptions,
        );
    }
    async emptyResponsePostRequest(
        params: DefaultPayload,
        options?: RpcOptions<'http'>,
    ): Promise<undefined> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<DefaultPayload> = {
            procedure: 'tests.emptyResponsePostRequest',
            path: '/rpcs/tests/empty-response-post-request',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<DefaultPayload, undefined> = {
            params: $$DefaultPayload,
            response: UndefinedModelValidator,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<DefaultPayload, undefined>(
            req,
            validator,
            finalOptions,
        );
    }
    /**
     * If the target language supports it. Generated code should mark this procedure as deprecated.
     * @deprecated
     */
    async deprecatedRpc(
        params: DeprecatedRpcParams,
        options?: RpcOptions<'http'>,
    ): Promise<undefined> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<DeprecatedRpcParams> = {
            procedure: 'tests.deprecatedRpc',
            path: '/rpcs/tests/deprecated-rpc',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<DeprecatedRpcParams, undefined> = {
            params: $$DeprecatedRpcParams,
            response: UndefinedModelValidator,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<DeprecatedRpcParams, undefined>(
            req,
            validator,
            finalOptions,
        );
    }
    async sendDiscriminatorWithEmptyObject(
        params: DiscriminatorWithEmptyObject,
        options?: RpcOptions<'http'>,
    ): Promise<DiscriminatorWithEmptyObject> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<DiscriminatorWithEmptyObject> = {
            procedure: 'tests.sendDiscriminatorWithEmptyObject',
            path: '/rpcs/tests/send-discriminator-with-empty-object',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<
            DiscriminatorWithEmptyObject,
            DiscriminatorWithEmptyObject
        > = {
            params: $$DiscriminatorWithEmptyObject,
            response: $$DiscriminatorWithEmptyObject,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<
            DiscriminatorWithEmptyObject,
            DiscriminatorWithEmptyObject
        >(req, validator, finalOptions);
    }
    async sendError(
        params: SendErrorParams,
        options?: RpcOptions<'http'>,
    ): Promise<undefined> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<SendErrorParams> = {
            procedure: 'tests.sendError',
            path: '/rpcs/tests/send-error',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<SendErrorParams, undefined> = {
            params: $$SendErrorParams,
            response: UndefinedModelValidator,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<SendErrorParams, undefined>(
            req,
            validator,
            finalOptions,
        );
    }
    async sendObject(
        params: ObjectWithEveryType,
        options?: RpcOptions<'http'>,
    ): Promise<ObjectWithEveryType> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<ObjectWithEveryType> = {
            procedure: 'tests.sendObject',
            path: '/rpcs/tests/send-object',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<
            ObjectWithEveryType,
            ObjectWithEveryType
        > = {
            params: $$ObjectWithEveryType,
            response: $$ObjectWithEveryType,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<ObjectWithEveryType, ObjectWithEveryType>(
            req,
            validator,
            finalOptions,
        );
    }
    async sendObjectWithNullableFields(
        params: ObjectWithEveryNullableType,
        options?: RpcOptions<'http'>,
    ): Promise<ObjectWithEveryNullableType> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<ObjectWithEveryNullableType> = {
            procedure: 'tests.sendObjectWithNullableFields',
            path: '/rpcs/tests/send-object-with-nullable-fields',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<
            ObjectWithEveryNullableType,
            ObjectWithEveryNullableType
        > = {
            params: $$ObjectWithEveryNullableType,
            response: $$ObjectWithEveryNullableType,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<
            ObjectWithEveryNullableType,
            ObjectWithEveryNullableType
        >(req, validator, finalOptions);
    }
    async sendObjectWithPascalCaseKeys(
        params: ObjectWithPascalCaseKeys,
        options?: RpcOptions<'http'>,
    ): Promise<ObjectWithPascalCaseKeys> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<ObjectWithPascalCaseKeys> = {
            procedure: 'tests.sendObjectWithPascalCaseKeys',
            path: '/rpcs/tests/send-object-with-pascal-case-keys',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<
            ObjectWithPascalCaseKeys,
            ObjectWithPascalCaseKeys
        > = {
            params: $$ObjectWithPascalCaseKeys,
            response: $$ObjectWithPascalCaseKeys,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<
            ObjectWithPascalCaseKeys,
            ObjectWithPascalCaseKeys
        >(req, validator, finalOptions);
    }
    async sendObjectWithSnakeCaseKeys(
        params: ObjectWithSnakeCaseKeys,
        options?: RpcOptions<'http'>,
    ): Promise<ObjectWithSnakeCaseKeys> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<ObjectWithSnakeCaseKeys> = {
            procedure: 'tests.sendObjectWithSnakeCaseKeys',
            path: '/rpcs/tests/send-object-with-snake-case-keys',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<
            ObjectWithSnakeCaseKeys,
            ObjectWithSnakeCaseKeys
        > = {
            params: $$ObjectWithSnakeCaseKeys,
            response: $$ObjectWithSnakeCaseKeys,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<
            ObjectWithSnakeCaseKeys,
            ObjectWithSnakeCaseKeys
        >(req, validator, finalOptions);
    }
    async sendPartialObject(
        params: ObjectWithEveryOptionalType,
        options?: RpcOptions<'http'>,
    ): Promise<ObjectWithEveryOptionalType> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<ObjectWithEveryOptionalType> = {
            procedure: 'tests.sendPartialObject',
            path: '/rpcs/tests/send-partial-object',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<
            ObjectWithEveryOptionalType,
            ObjectWithEveryOptionalType
        > = {
            params: $$ObjectWithEveryOptionalType,
            response: $$ObjectWithEveryOptionalType,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<
            ObjectWithEveryOptionalType,
            ObjectWithEveryOptionalType
        >(req, validator, finalOptions);
    }
    async sendRecursiveObject(
        params: RecursiveObject,
        options?: RpcOptions<'http'>,
    ): Promise<RecursiveObject> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<RecursiveObject> = {
            procedure: 'tests.sendRecursiveObject',
            path: '/rpcs/tests/send-recursive-object',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<RecursiveObject, RecursiveObject> =
            {
                params: $$RecursiveObject,
                response: $$RecursiveObject,
            };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<RecursiveObject, RecursiveObject>(
            req,
            validator,
            finalOptions,
        );
    }
    async sendRecursiveUnion(
        params: RecursiveUnion,
        options?: RpcOptions<'http'>,
    ): Promise<RecursiveUnion> {
        const finalOptions = resolveDispatcherOptions(options, this._options);
        const req: RpcRequest<RecursiveUnion> = {
            procedure: 'tests.sendRecursiveUnion',
            path: '/rpcs/tests/send-recursive-union',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: finalOptions.headers,
        };
        const validator: RpcRequestValidator<RecursiveUnion, RecursiveUnion> = {
            params: $$RecursiveUnion,
            response: $$RecursiveUnion,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            finalOptions.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleRpc<RecursiveUnion, RecursiveUnion>(
            req,
            validator,
            finalOptions,
        );
    }
    streamAutoReconnect(
        params: AutoReconnectParams,
        options?: EventStreamHooks<AutoReconnectResponse>,
    ): EventStreamController {
        const req: RpcRequest<AutoReconnectParams> = {
            procedure: 'tests.streamAutoReconnect',
            path: '/rpcs/tests/stream-auto-reconnect',
            method: undefined,
            clientVersion: '10',
            data: params,
            customHeaders: this._options.headers,
        };
        const validator: RpcRequestValidator<
            AutoReconnectParams,
            AutoReconnectResponse
        > = {
            params: $$AutoReconnectParams,
            response: $$AutoReconnectResponse,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            this._options.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleEventStreamRpc<
            AutoReconnectParams,
            AutoReconnectResponse
        >(req, validator, options ?? {});
    }
    /**
     * This route will always return an error. The client should automatically retry with exponential backoff.
     */
    streamConnectionErrorTest(
        params: StreamConnectionErrorTestParams,
        options?: EventStreamHooks<StreamConnectionErrorTestResponse>,
    ): EventStreamController {
        const req: RpcRequest<StreamConnectionErrorTestParams> = {
            procedure: 'tests.streamConnectionErrorTest',
            path: '/rpcs/tests/stream-connection-error-test',
            method: 'get',
            clientVersion: '10',
            data: params,
            customHeaders: this._options.headers,
        };
        const validator: RpcRequestValidator<
            StreamConnectionErrorTestParams,
            StreamConnectionErrorTestResponse
        > = {
            params: $$StreamConnectionErrorTestParams,
            response: $$StreamConnectionErrorTestResponse,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            this._options.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleEventStreamRpc<
            StreamConnectionErrorTestParams,
            StreamConnectionErrorTestResponse
        >(req, validator, options ?? {});
    }
    /**
     * Test to ensure that the client can handle receiving streams of large objects. When objects are large messages will sometimes get sent in chunks. Meaning you have to handle receiving a partial message
     */
    streamLargeObjects(
        options?: EventStreamHooks<StreamLargeObjectsResponse>,
    ): EventStreamController {
        const req: RpcRequest<undefined> = {
            procedure: 'tests.streamLargeObjects',
            path: '/rpcs/tests/stream-large-objects',
            method: 'get',
            clientVersion: '10',
            data: undefined,
            customHeaders: this._options.headers,
        };
        const validator: RpcRequestValidator<
            undefined,
            StreamLargeObjectsResponse
        > = {
            params: UndefinedModelValidator,
            response: $$StreamLargeObjectsResponse,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            this._options.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleEventStreamRpc<
            undefined,
            StreamLargeObjectsResponse
        >(req, validator, options ?? {});
    }
    streamMessages(
        params: ChatMessageParams,
        options?: EventStreamHooks<ChatMessage>,
    ): EventStreamController {
        const req: RpcRequest<ChatMessageParams> = {
            procedure: 'tests.streamMessages',
            path: '/rpcs/tests/stream-messages',
            method: 'get',
            clientVersion: '10',
            data: params,
            customHeaders: this._options.headers,
        };
        const validator: RpcRequestValidator<ChatMessageParams, ChatMessage> = {
            params: $$ChatMessageParams,
            response: $$ChatMessage,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            this._options.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleEventStreamRpc<ChatMessageParams, ChatMessage>(
            req,
            validator,
            options ?? {},
        );
    }
    streamRetryWithNewCredentials(
        options?: EventStreamHooks<TestsStreamRetryWithNewCredentialsResponse>,
    ): EventStreamController {
        const req: RpcRequest<undefined> = {
            procedure: 'tests.streamRetryWithNewCredentials',
            path: '/rpcs/tests/stream-retry-with-new-credentials',
            method: undefined,
            clientVersion: '10',
            data: undefined,
            customHeaders: this._options.headers,
        };
        const validator: RpcRequestValidator<
            undefined,
            TestsStreamRetryWithNewCredentialsResponse
        > = {
            params: UndefinedModelValidator,
            response: $$TestsStreamRetryWithNewCredentialsResponse,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            this._options.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleEventStreamRpc<
            undefined,
            TestsStreamRetryWithNewCredentialsResponse
        >(req, validator, options ?? {});
    }
    /**
     * When the client receives the 'done' event, it should close the connection and NOT reconnect
     */
    streamTenEventsThenEnd(
        options?: EventStreamHooks<ChatMessage>,
    ): EventStreamController {
        const req: RpcRequest<undefined> = {
            procedure: 'tests.streamTenEventsThenEnd',
            path: '/rpcs/tests/stream-ten-events-then-end',
            method: 'get',
            clientVersion: '10',
            data: undefined,
            customHeaders: this._options.headers,
        };
        const validator: RpcRequestValidator<undefined, ChatMessage> = {
            params: UndefinedModelValidator,
            response: $$ChatMessage,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            this._options.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleEventStreamRpc<undefined, ChatMessage>(
            req,
            validator,
            options ?? {},
        );
    }
}

export class TestClientUsersService {
    private readonly _dispatchers: Record<string, RpcDispatcher>;
    private readonly _options: RpcDispatcherOptions;
    private readonly _defaultTransport: string;

    constructor(config: TestClientOptions) {
        this._options = {
            headers: config.headers,
            onError: config.onError,
            retry: config.retry,
            retryDelay: config.retryDelay,
            retryErrorCodes: config.retryErrorCodes,
            timeout: config.timeout,
        };
        this._defaultTransport = config.transport ?? 'http';
        if (!config.dispatchers) config.dispatchers = {};
        if (!config.dispatchers['http']) {
            config.dispatchers['http'] = new HttpDispatcher(config);
        }
        if (!config.dispatchers['ws']) {
            config.dispatchers['ws'] = new WsDispatcher(config);
        }
        this._dispatchers = config.dispatchers!;
    }
    watchUser(
        params: UsersWatchUserParams,
        options?: EventStreamHooks<UsersWatchUserResponse>,
    ): EventStreamController {
        const req: RpcRequest<UsersWatchUserParams> = {
            procedure: 'users.watchUser',
            path: '/rpcs/users/watch-user',
            method: 'get',
            clientVersion: '10',
            data: params,
            customHeaders: this._options.headers,
        };
        const validator: RpcRequestValidator<
            UsersWatchUserParams,
            UsersWatchUserResponse
        > = {
            params: $$UsersWatchUserParams,
            response: $$UsersWatchUserResponse,
        };
        const transport = 'http';
        const dispatcher = this._dispatchers[transport];
        if (!dispatcher) {
            const err = new Error(
                `Missing dispatcher for transport "${transport}"`,
            );
            this._options.onError?.(req, err);
            throw err;
        }
        return dispatcher.handleEventStreamRpc<
            UsersWatchUserParams,
            UsersWatchUserResponse
        >(req, validator, options ?? {});
    }
}

export interface DefaultPayload {
    message: string;
}
export const $$DefaultPayload: ArriModelValidator<DefaultPayload> = {
    new(): DefaultPayload {
        return {
            message: '',
        };
    },
    validate(input): input is DefaultPayload {
        return isObject(input) && typeof input.message === 'string';
    },
    fromJson(input): DefaultPayload {
        let _message: string;
        if (typeof input.message === 'string') {
            _message = input.message;
        } else {
            _message = '';
        }
        return {
            message: _message,
        };
    },
    fromJsonString(input): DefaultPayload {
        return $$DefaultPayload.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"message":';
        json += serializeString(input.message);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`message=${input.message}`);
        return queryParts.join('&');
    },
};

export interface ManuallyAddedModel {
    hello: string;
}
export const $$ManuallyAddedModel: ArriModelValidator<ManuallyAddedModel> = {
    new(): ManuallyAddedModel {
        return {
            hello: '',
        };
    },
    validate(input): input is ManuallyAddedModel {
        return isObject(input) && typeof input.hello === 'string';
    },
    fromJson(input): ManuallyAddedModel {
        let _hello: string;
        if (typeof input.hello === 'string') {
            _hello = input.hello;
        } else {
            _hello = '';
        }
        return {
            hello: _hello,
        };
    },
    fromJsonString(input): ManuallyAddedModel {
        return $$ManuallyAddedModel.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"hello":';
        json += serializeString(input.hello);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`hello=${input.hello}`);
        return queryParts.join('&');
    },
};

/**
 * @deprecated
 */
export interface DeprecatedRpcParams {
    /**
     * @deprecated
     */
    deprecatedField: string;
}
export const $$DeprecatedRpcParams: ArriModelValidator<DeprecatedRpcParams> = {
    new(): DeprecatedRpcParams {
        return {
            deprecatedField: '',
        };
    },
    validate(input): input is DeprecatedRpcParams {
        return isObject(input) && typeof input.deprecatedField === 'string';
    },
    fromJson(input): DeprecatedRpcParams {
        let _deprecatedField: string;
        if (typeof input.deprecatedField === 'string') {
            _deprecatedField = input.deprecatedField;
        } else {
            _deprecatedField = '';
        }
        return {
            deprecatedField: _deprecatedField,
        };
    },
    fromJsonString(input): DeprecatedRpcParams {
        return $$DeprecatedRpcParams.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"deprecatedField":';
        json += serializeString(input.deprecatedField);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`deprecatedField=${input.deprecatedField}`);
        return queryParts.join('&');
    },
};

export type DiscriminatorWithEmptyObject =
    | DiscriminatorWithEmptyObjectEmpty
    | DiscriminatorWithEmptyObjectNotEmpty;
export const $$DiscriminatorWithEmptyObject: ArriModelValidator<DiscriminatorWithEmptyObject> =
    {
        new(): DiscriminatorWithEmptyObject {
            return $$DiscriminatorWithEmptyObjectEmpty.new();
        },
        validate(input): input is DiscriminatorWithEmptyObject {
            if (!isObject(input)) {
                return false;
            }
            if (typeof input.type !== 'string') {
                return false;
            }
            switch (input.type) {
                case 'EMPTY':
                    return $$DiscriminatorWithEmptyObjectEmpty.validate(input);
                case 'NOT_EMPTY':
                    return $$DiscriminatorWithEmptyObjectNotEmpty.validate(
                        input,
                    );
                default:
                    return false;
            }
        },
        fromJson(input): DiscriminatorWithEmptyObject {
            switch (input.type) {
                case 'EMPTY':
                    return $$DiscriminatorWithEmptyObjectEmpty.fromJson(input);
                case 'NOT_EMPTY':
                    return $$DiscriminatorWithEmptyObjectNotEmpty.fromJson(
                        input,
                    );
                default:
                    return $$DiscriminatorWithEmptyObjectEmpty.new();
            }
        },
        fromJsonString(input): DiscriminatorWithEmptyObject {
            return $$DiscriminatorWithEmptyObject.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            switch (input.type) {
                case 'EMPTY':
                    return $$DiscriminatorWithEmptyObjectEmpty.toJsonString(
                        input,
                    );
                case 'NOT_EMPTY':
                    return $$DiscriminatorWithEmptyObjectNotEmpty.toJsonString(
                        input,
                    );
                default:
                    throw new Error(`Unhandled case "${(input as any).type}"`);
            }
        },
        toUrlQueryString(input): string {
            switch (input.type) {
                case 'EMPTY':
                    return $$DiscriminatorWithEmptyObjectEmpty.toUrlQueryString(
                        input,
                    );
                case 'NOT_EMPTY':
                    return $$DiscriminatorWithEmptyObjectNotEmpty.toUrlQueryString(
                        input,
                    );
                default:
                    throw new Error('Unhandled case');
            }
        },
    };
export interface DiscriminatorWithEmptyObjectEmpty {
    type: 'EMPTY';
}
const $$DiscriminatorWithEmptyObjectEmpty: ArriModelValidator<DiscriminatorWithEmptyObjectEmpty> =
    {
        new(): DiscriminatorWithEmptyObjectEmpty {
            return {
                type: 'EMPTY',
            };
        },
        validate(input): input is DiscriminatorWithEmptyObjectEmpty {
            return isObject(input) && input.type === 'EMPTY';
        },
        fromJson(input): DiscriminatorWithEmptyObjectEmpty {
            const _type = 'EMPTY';
            return {
                type: _type,
            };
        },
        fromJsonString(input): DiscriminatorWithEmptyObjectEmpty {
            return $$DiscriminatorWithEmptyObjectEmpty.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"type":"EMPTY"';
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('type=EMPTY');
            return queryParts.join('&');
        },
    };

export interface DiscriminatorWithEmptyObjectNotEmpty {
    type: 'NOT_EMPTY';
    foo: string;
    bar: number;
    baz: boolean;
}
const $$DiscriminatorWithEmptyObjectNotEmpty: ArriModelValidator<DiscriminatorWithEmptyObjectNotEmpty> =
    {
        new(): DiscriminatorWithEmptyObjectNotEmpty {
            return {
                type: 'NOT_EMPTY',
                foo: '',
                bar: 0,
                baz: false,
            };
        },
        validate(input): input is DiscriminatorWithEmptyObjectNotEmpty {
            return (
                isObject(input) &&
                input.type === 'NOT_EMPTY' &&
                typeof input.foo === 'string' &&
                typeof input.bar === 'number' &&
                typeof input.baz === 'boolean'
            );
        },
        fromJson(input): DiscriminatorWithEmptyObjectNotEmpty {
            const _type = 'NOT_EMPTY';
            let _foo: string;
            if (typeof input.foo === 'string') {
                _foo = input.foo;
            } else {
                _foo = '';
            }
            let _bar: number;
            if (typeof input.bar === 'number') {
                _bar = input.bar;
            } else {
                _bar = 0;
            }
            let _baz: boolean;
            if (typeof input.baz === 'boolean') {
                _baz = input.baz;
            } else {
                _baz = false;
            }
            return {
                type: _type,
                foo: _foo,
                bar: _bar,
                baz: _baz,
            };
        },
        fromJsonString(input): DiscriminatorWithEmptyObjectNotEmpty {
            return $$DiscriminatorWithEmptyObjectNotEmpty.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"type":"NOT_EMPTY"';
            json += ',"foo":';
            json += serializeString(input.foo);
            json += ',"bar":';
            json += `${input.bar}`;
            json += ',"baz":';
            json += `${input.baz}`;
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('type=NOT_EMPTY');
            queryParts.push(`foo=${input.foo}`);
            queryParts.push(`bar=${input.bar}`);
            queryParts.push(`baz=${input.baz}`);
            return queryParts.join('&');
        },
    };

export interface SendErrorParams {
    code: number;
    message: string;
}
export const $$SendErrorParams: ArriModelValidator<SendErrorParams> = {
    new(): SendErrorParams {
        return {
            code: 0,
            message: '',
        };
    },
    validate(input): input is SendErrorParams {
        return (
            isObject(input) &&
            typeof input.code === 'number' &&
            Number.isInteger(input.code) &&
            input.code >= 0 &&
            input.code <= UINT16_MAX &&
            typeof input.message === 'string'
        );
    },
    fromJson(input): SendErrorParams {
        let _code: number;
        if (
            typeof input.code === 'number' &&
            Number.isInteger(input.code) &&
            input.code >= 0 &&
            input.code <= UINT16_MAX
        ) {
            _code = input.code;
        } else {
            _code = 0;
        }
        let _message: string;
        if (typeof input.message === 'string') {
            _message = input.message;
        } else {
            _message = '';
        }
        return {
            code: _code,
            message: _message,
        };
    },
    fromJsonString(input): SendErrorParams {
        return $$SendErrorParams.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"code":';
        json += `${input.code}`;
        json += ',"message":';
        json += serializeString(input.message);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`code=${input.code}`);
        queryParts.push(`message=${input.message}`);
        return queryParts.join('&');
    },
};

export interface ObjectWithEveryType {
    any: any;
    boolean: boolean;
    string: string;
    timestamp: Date;
    float32: number;
    float64: number;
    int8: number;
    uint8: number;
    int16: number;
    uint16: number;
    int32: number;
    uint32: number;
    int64: bigint;
    uint64: bigint;
    enumerator: ObjectWithEveryTypeEnumerator;
    array: boolean[];
    object: ObjectWithEveryTypeObject;
    record: Record<string, bigint>;
    discriminator: ObjectWithEveryTypeDiscriminator;
    nestedObject: ObjectWithEveryTypeNestedObject;
    nestedArray: ObjectWithEveryTypeNestedArrayElementElement[][];
}
export const $$ObjectWithEveryType: ArriModelValidator<ObjectWithEveryType> = {
    new(): ObjectWithEveryType {
        return {
            any: undefined,
            boolean: false,
            string: '',
            timestamp: new Date(),
            float32: 0,
            float64: 0,
            int8: 0,
            uint8: 0,
            int16: 0,
            uint16: 0,
            int32: 0,
            uint32: 0,
            int64: BigInt(0),
            uint64: BigInt(0),
            enumerator: $$ObjectWithEveryTypeEnumerator.new(),
            array: [],
            object: $$ObjectWithEveryTypeObject.new(),
            record: {},
            discriminator: $$ObjectWithEveryTypeDiscriminator.new(),
            nestedObject: $$ObjectWithEveryTypeNestedObject.new(),
            nestedArray: [],
        };
    },
    validate(input): input is ObjectWithEveryType {
        return (
            isObject(input) &&
            true &&
            typeof input.boolean === 'boolean' &&
            typeof input.string === 'string' &&
            input.timestamp instanceof Date &&
            typeof input.float32 === 'number' &&
            typeof input.float64 === 'number' &&
            typeof input.int8 === 'number' &&
            Number.isInteger(input.int8) &&
            input.int8 >= INT8_MIN &&
            input.int8 <= INT8_MAX &&
            typeof input.uint8 === 'number' &&
            Number.isInteger(input.uint8) &&
            input.uint8 >= 0 &&
            input.uint8 <= UINT8_MAX &&
            typeof input.int16 === 'number' &&
            Number.isInteger(input.int16) &&
            input.int16 >= INT16_MIN &&
            input.int16 <= INT16_MAX &&
            typeof input.uint16 === 'number' &&
            Number.isInteger(input.uint16) &&
            input.uint16 >= 0 &&
            input.uint16 <= UINT16_MAX &&
            typeof input.int32 === 'number' &&
            Number.isInteger(input.int32) &&
            input.int32 >= INT32_MIN &&
            input.int32 <= INT32_MAX &&
            typeof input.uint32 === 'number' &&
            Number.isInteger(input.uint32) &&
            input.uint32 >= 0 &&
            input.uint32 <= UINT32_MAX &&
            typeof input.int64 === 'bigint' &&
            input.int64 >= INT64_MIN &&
            input.int64 <= INT64_MAX &&
            typeof input.uint64 === 'bigint' &&
            input.uint64 >= BigInt(0) &&
            input.uint64 <= UINT64_MAX &&
            $$ObjectWithEveryTypeEnumerator.validate(input.enumerator) &&
            Array.isArray(input.array) &&
            input.array.every((_element) => typeof _element === 'boolean') &&
            $$ObjectWithEveryTypeObject.validate(input.object) &&
            isObject(input.record) &&
            Object.values(input.record).every(
                (_value) =>
                    typeof _value === 'bigint' &&
                    _value >= BigInt(0) &&
                    _value <= UINT64_MAX,
            ) &&
            $$ObjectWithEveryTypeDiscriminator.validate(input.discriminator) &&
            $$ObjectWithEveryTypeNestedObject.validate(input.nestedObject) &&
            Array.isArray(input.nestedArray) &&
            input.nestedArray.every(
                (_element) =>
                    Array.isArray(_element) &&
                    _element.every((_element) =>
                        $$ObjectWithEveryTypeNestedArrayElementElement.validate(
                            _element,
                        ),
                    ),
            )
        );
    },
    fromJson(input): ObjectWithEveryType {
        let _any: any;
        _any = input.any;
        let _boolean: boolean;
        if (typeof input.boolean === 'boolean') {
            _boolean = input.boolean;
        } else {
            _boolean = false;
        }
        let _string: string;
        if (typeof input.string === 'string') {
            _string = input.string;
        } else {
            _string = '';
        }
        let _timestamp: Date;
        if (typeof input.timestamp === 'string') {
            _timestamp = new Date(input.timestamp);
        } else if (input.timestamp instanceof Date) {
            _timestamp = input.timestamp;
        } else {
            _timestamp = new Date();
        }
        let _float32: number;
        if (typeof input.float32 === 'number') {
            _float32 = input.float32;
        } else {
            _float32 = 0;
        }
        let _float64: number;
        if (typeof input.float64 === 'number') {
            _float64 = input.float64;
        } else {
            _float64 = 0;
        }
        let _int8: number;
        if (
            typeof input.int8 === 'number' &&
            Number.isInteger(input.int8) &&
            input.int8 >= INT8_MIN &&
            input.int8 <= INT8_MAX
        ) {
            _int8 = input.int8;
        } else {
            _int8 = 0;
        }
        let _uint8: number;
        if (
            typeof input.uint8 === 'number' &&
            Number.isInteger(input.uint8) &&
            input.uint8 >= 0 &&
            input.uint8 <= UINT8_MAX
        ) {
            _uint8 = input.uint8;
        } else {
            _uint8 = 0;
        }
        let _int16: number;
        if (
            typeof input.int16 === 'number' &&
            Number.isInteger(input.int16) &&
            input.int16 >= INT16_MIN &&
            input.int16 <= INT16_MAX
        ) {
            _int16 = input.int16;
        } else {
            _int16 = 0;
        }
        let _uint16: number;
        if (
            typeof input.uint16 === 'number' &&
            Number.isInteger(input.uint16) &&
            input.uint16 >= 0 &&
            input.uint16 <= UINT16_MAX
        ) {
            _uint16 = input.uint16;
        } else {
            _uint16 = 0;
        }
        let _int32: number;
        if (
            typeof input.int32 === 'number' &&
            Number.isInteger(input.int32) &&
            input.int32 >= INT32_MIN &&
            input.int32 <= INT32_MAX
        ) {
            _int32 = input.int32;
        } else {
            _int32 = 0;
        }
        let _uint32: number;
        if (
            typeof input.uint32 === 'number' &&
            Number.isInteger(input.uint32) &&
            input.uint32 >= 0 &&
            input.uint32 <= UINT32_MAX
        ) {
            _uint32 = input.uint32;
        } else {
            _uint32 = 0;
        }
        let _int64: bigint;
        if (typeof input.int64 === 'string') {
            _int64 = BigInt(input.int64);
        } else if (typeof input.int64 === 'bigint') {
            _int64 = input.int64;
        } else {
            _int64 = BigInt(0);
        }
        let _uint64: bigint;
        if (
            typeof input.uint64 === 'string' &&
            BigInt(input.uint64) >= BigInt(0)
        ) {
            _uint64 = BigInt(input.uint64);
        } else if (
            typeof input.uint64 === 'bigint' &&
            input.uint64 >= BigInt(0)
        ) {
            _uint64 = input.uint64;
        } else {
            _uint64 = BigInt(0);
        }
        let _enumerator: ObjectWithEveryTypeEnumerator;
        if (typeof input.enumerator === 'string') {
            _enumerator = $$ObjectWithEveryTypeEnumerator.fromSerialValue(
                input.enumerator,
            );
        } else {
            _enumerator = $$ObjectWithEveryTypeEnumerator.new();
        }
        let _array: boolean[];
        if (Array.isArray(input.array)) {
            _array = [];
            for (const _arrayEl of input.array) {
                let _arrayElValue: boolean;
                if (typeof _arrayEl === 'boolean') {
                    _arrayElValue = _arrayEl;
                } else {
                    _arrayElValue = false;
                }
                _array.push(_arrayElValue);
            }
        } else {
            _array = [];
        }
        let _object: ObjectWithEveryTypeObject;
        if (isObject(input.object)) {
            _object = $$ObjectWithEveryTypeObject.fromJson(input.object);
        } else {
            _object = $$ObjectWithEveryTypeObject.new();
        }
        let _record: Record<string, bigint>;
        if (isObject(input.record)) {
            _record = {};
            for (const [_key, _value] of Object.entries(input.record)) {
                let _recordValue: bigint;
                if (typeof _value === 'string' && BigInt(_value) >= BigInt(0)) {
                    _recordValue = BigInt(_value);
                } else if (typeof _value === 'bigint' && _value >= BigInt(0)) {
                    _recordValue = _value;
                } else {
                    _recordValue = BigInt(0);
                }
                _record[_key] = _recordValue;
            }
        } else {
            _record = {};
        }
        let _discriminator: ObjectWithEveryTypeDiscriminator;
        if (isObject(input.discriminator)) {
            _discriminator = $$ObjectWithEveryTypeDiscriminator.fromJson(
                input.discriminator,
            );
        } else {
            _discriminator = $$ObjectWithEveryTypeDiscriminator.new();
        }
        let _nestedObject: ObjectWithEveryTypeNestedObject;
        if (isObject(input.nestedObject)) {
            _nestedObject = $$ObjectWithEveryTypeNestedObject.fromJson(
                input.nestedObject,
            );
        } else {
            _nestedObject = $$ObjectWithEveryTypeNestedObject.new();
        }
        let _nestedArray: ObjectWithEveryTypeNestedArrayElementElement[][];
        if (Array.isArray(input.nestedArray)) {
            _nestedArray = [];
            for (const _nestedArrayEl of input.nestedArray) {
                let _nestedArrayElValue: ObjectWithEveryTypeNestedArrayElementElement[];
                if (Array.isArray(_nestedArrayEl)) {
                    _nestedArrayElValue = [];
                    for (const _nestedArrayElValueEl of _nestedArrayEl) {
                        let _nestedArrayElValueElValue: ObjectWithEveryTypeNestedArrayElementElement;
                        if (isObject(_nestedArrayElValueEl)) {
                            _nestedArrayElValueElValue =
                                $$ObjectWithEveryTypeNestedArrayElementElement.fromJson(
                                    _nestedArrayElValueEl,
                                );
                        } else {
                            _nestedArrayElValueElValue =
                                $$ObjectWithEveryTypeNestedArrayElementElement.new();
                        }
                        _nestedArrayElValue.push(_nestedArrayElValueElValue);
                    }
                } else {
                    _nestedArrayElValue = [];
                }
                _nestedArray.push(_nestedArrayElValue);
            }
        } else {
            _nestedArray = [];
        }
        return {
            any: _any,
            boolean: _boolean,
            string: _string,
            timestamp: _timestamp,
            float32: _float32,
            float64: _float64,
            int8: _int8,
            uint8: _uint8,
            int16: _int16,
            uint16: _uint16,
            int32: _int32,
            uint32: _uint32,
            int64: _int64,
            uint64: _uint64,
            enumerator: _enumerator,
            array: _array,
            object: _object,
            record: _record,
            discriminator: _discriminator,
            nestedObject: _nestedObject,
            nestedArray: _nestedArray,
        };
    },
    fromJsonString(input): ObjectWithEveryType {
        return $$ObjectWithEveryType.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"any":';
        json += JSON.stringify(input.any);
        json += ',"boolean":';
        json += `${input.boolean}`;
        json += ',"string":';
        json += serializeString(input.string);
        json += ',"timestamp":';
        json += `"${input.timestamp.toISOString()}"`;
        json += ',"float32":';
        json += `${input.float32}`;
        json += ',"float64":';
        json += `${input.float64}`;
        json += ',"int8":';
        json += `${input.int8}`;
        json += ',"uint8":';
        json += `${input.uint8}`;
        json += ',"int16":';
        json += `${input.int16}`;
        json += ',"uint16":';
        json += `${input.uint16}`;
        json += ',"int32":';
        json += `${input.int32}`;
        json += ',"uint32":';
        json += `${input.uint32}`;
        json += ',"int64":';
        json += `"${input.int64}"`;
        json += ',"uint64":';
        json += `"${input.uint64}"`;
        json += ',"enumerator":';
        json += `"${input.enumerator}"`;
        json += ',"array":';
        json += '[';
        for (let i = 0; i < input.array.length; i++) {
            if (i !== 0) json += ',';
            const _inputArrayEl = input.array[i];
            json += `${_inputArrayEl}`;
        }
        json += ']';
        json += ',"object":';
        json += $$ObjectWithEveryTypeObject.toJsonString(input.object);
        json += ',"record":';
        json += '{';
        let _recordPropertyCount = 0;
        for (const [_key, _value] of Object.entries(input.record)) {
            if (_recordPropertyCount !== 0) {
                json += ',';
            }
            json += `${serializeString(_key)}:`;
            json += `"${_value}"`;
            _recordPropertyCount++;
        }
        json += '}';

        json += ',"discriminator":';
        json += $$ObjectWithEveryTypeDiscriminator.toJsonString(
            input.discriminator,
        );
        json += ',"nestedObject":';
        json += $$ObjectWithEveryTypeNestedObject.toJsonString(
            input.nestedObject,
        );
        json += ',"nestedArray":';
        json += '[';
        for (let i = 0; i < input.nestedArray.length; i++) {
            if (i !== 0) json += ',';
            const _inputNestedArrayEl = input.nestedArray[i];
            json += '[';
            for (let i = 0; i < _inputNestedArrayEl.length; i++) {
                if (i !== 0) json += ',';
                const _inputNestedArrayElEl = _inputNestedArrayEl[i];
                json +=
                    $$ObjectWithEveryTypeNestedArrayElementElement.toJsonString(
                        _inputNestedArrayElEl,
                    );
            }
            json += ']';
        }
        json += ']';
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        console.warn(
            "[WARNING] Cannot serialize any's to query string. Skipping property at /ObjectWithEveryType/any.",
        );
        queryParts.push(`boolean=${input.boolean}`);
        queryParts.push(`string=${input.string}`);
        queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
        queryParts.push(`float32=${input.float32}`);
        queryParts.push(`float64=${input.float64}`);
        queryParts.push(`int8=${input.int8}`);
        queryParts.push(`uint8=${input.uint8}`);
        queryParts.push(`int16=${input.int16}`);
        queryParts.push(`uint16=${input.uint16}`);
        queryParts.push(`int32=${input.int32}`);
        queryParts.push(`uint32=${input.uint32}`);
        queryParts.push(`int64=${input.int64}`);
        queryParts.push(`uint64=${input.uint64}`);
        queryParts.push(`enumerator=${input.enumerator}`);
        console.warn(
            '[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryType/array.',
        );
        console.warn(
            '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryType/object.',
        );
        console.warn(
            '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryType/record.',
        );
        console.warn(
            '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryType/discriminator.',
        );
        console.warn(
            '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryType/nestedObject.',
        );
        console.warn(
            '[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryType/nestedArray.',
        );
        return queryParts.join('&');
    },
};

export type ObjectWithEveryTypeEnumerator =
    (typeof $$ObjectWithEveryTypeEnumeratorValues)[number];
const $$ObjectWithEveryTypeEnumeratorValues = ['A', 'B', 'C'] as const;
export const $$ObjectWithEveryTypeEnumerator: ArriEnumValidator<ObjectWithEveryTypeEnumerator> =
    {
        new(): ObjectWithEveryTypeEnumerator {
            return $$ObjectWithEveryTypeEnumeratorValues[0];
        },
        validate(input): input is ObjectWithEveryTypeEnumerator {
            return (
                typeof input === 'string' &&
                $$ObjectWithEveryTypeEnumeratorValues.includes(input as any)
            );
        },
        values: $$ObjectWithEveryTypeEnumeratorValues,
        fromSerialValue(input): ObjectWithEveryTypeEnumerator {
            if ($$ObjectWithEveryTypeEnumeratorValues.includes(input as any)) {
                return input as ObjectWithEveryTypeEnumerator;
            }
            if (
                $$ObjectWithEveryTypeEnumeratorValues.includes(
                    input.toLowerCase() as any,
                )
            ) {
                return input.toLowerCase() as ObjectWithEveryTypeEnumerator;
            }
            if (
                $$ObjectWithEveryTypeEnumeratorValues.includes(
                    input.toUpperCase() as any,
                )
            ) {
                return input.toUpperCase() as ObjectWithEveryTypeEnumerator;
            }
            return 'A';
        },
    };

export interface ObjectWithEveryTypeObject {
    string: string;
    boolean: boolean;
    timestamp: Date;
}
export const $$ObjectWithEveryTypeObject: ArriModelValidator<ObjectWithEveryTypeObject> =
    {
        new(): ObjectWithEveryTypeObject {
            return {
                string: '',
                boolean: false,
                timestamp: new Date(),
            };
        },
        validate(input): input is ObjectWithEveryTypeObject {
            return (
                isObject(input) &&
                typeof input.string === 'string' &&
                typeof input.boolean === 'boolean' &&
                input.timestamp instanceof Date
            );
        },
        fromJson(input): ObjectWithEveryTypeObject {
            let _string: string;
            if (typeof input.string === 'string') {
                _string = input.string;
            } else {
                _string = '';
            }
            let _boolean: boolean;
            if (typeof input.boolean === 'boolean') {
                _boolean = input.boolean;
            } else {
                _boolean = false;
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            return {
                string: _string,
                boolean: _boolean,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): ObjectWithEveryTypeObject {
            return $$ObjectWithEveryTypeObject.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"string":';
            json += serializeString(input.string);
            json += ',"boolean":';
            json += `${input.boolean}`;
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`string=${input.string}`);
            queryParts.push(`boolean=${input.boolean}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            return queryParts.join('&');
        },
    };

export type ObjectWithEveryTypeDiscriminator =
    | ObjectWithEveryTypeDiscriminatorA
    | ObjectWithEveryTypeDiscriminatorB;
export const $$ObjectWithEveryTypeDiscriminator: ArriModelValidator<ObjectWithEveryTypeDiscriminator> =
    {
        new(): ObjectWithEveryTypeDiscriminator {
            return $$ObjectWithEveryTypeDiscriminatorA.new();
        },
        validate(input): input is ObjectWithEveryTypeDiscriminator {
            if (!isObject(input)) {
                return false;
            }
            if (typeof input.type !== 'string') {
                return false;
            }
            switch (input.type) {
                case 'A':
                    return $$ObjectWithEveryTypeDiscriminatorA.validate(input);
                case 'B':
                    return $$ObjectWithEveryTypeDiscriminatorB.validate(input);
                default:
                    return false;
            }
        },
        fromJson(input): ObjectWithEveryTypeDiscriminator {
            switch (input.type) {
                case 'A':
                    return $$ObjectWithEveryTypeDiscriminatorA.fromJson(input);
                case 'B':
                    return $$ObjectWithEveryTypeDiscriminatorB.fromJson(input);
                default:
                    return $$ObjectWithEveryTypeDiscriminatorA.new();
            }
        },
        fromJsonString(input): ObjectWithEveryTypeDiscriminator {
            return $$ObjectWithEveryTypeDiscriminator.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            switch (input.type) {
                case 'A':
                    return $$ObjectWithEveryTypeDiscriminatorA.toJsonString(
                        input,
                    );
                case 'B':
                    return $$ObjectWithEveryTypeDiscriminatorB.toJsonString(
                        input,
                    );
                default:
                    throw new Error(`Unhandled case "${(input as any).type}"`);
            }
        },
        toUrlQueryString(input): string {
            switch (input.type) {
                case 'A':
                    return $$ObjectWithEveryTypeDiscriminatorA.toUrlQueryString(
                        input,
                    );
                case 'B':
                    return $$ObjectWithEveryTypeDiscriminatorB.toUrlQueryString(
                        input,
                    );
                default:
                    throw new Error('Unhandled case');
            }
        },
    };
export interface ObjectWithEveryTypeDiscriminatorA {
    type: 'A';
    title: string;
}
const $$ObjectWithEveryTypeDiscriminatorA: ArriModelValidator<ObjectWithEveryTypeDiscriminatorA> =
    {
        new(): ObjectWithEveryTypeDiscriminatorA {
            return {
                type: 'A',
                title: '',
            };
        },
        validate(input): input is ObjectWithEveryTypeDiscriminatorA {
            return (
                isObject(input) &&
                input.type === 'A' &&
                typeof input.title === 'string'
            );
        },
        fromJson(input): ObjectWithEveryTypeDiscriminatorA {
            const _type = 'A';
            let _title: string;
            if (typeof input.title === 'string') {
                _title = input.title;
            } else {
                _title = '';
            }
            return {
                type: _type,
                title: _title,
            };
        },
        fromJsonString(input): ObjectWithEveryTypeDiscriminatorA {
            return $$ObjectWithEveryTypeDiscriminatorA.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"type":"A"';
            json += ',"title":';
            json += serializeString(input.title);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('type=A');
            queryParts.push(`title=${input.title}`);
            return queryParts.join('&');
        },
    };

export interface ObjectWithEveryTypeDiscriminatorB {
    type: 'B';
    title: string;
    description: string;
}
const $$ObjectWithEveryTypeDiscriminatorB: ArriModelValidator<ObjectWithEveryTypeDiscriminatorB> =
    {
        new(): ObjectWithEveryTypeDiscriminatorB {
            return {
                type: 'B',
                title: '',
                description: '',
            };
        },
        validate(input): input is ObjectWithEveryTypeDiscriminatorB {
            return (
                isObject(input) &&
                input.type === 'B' &&
                typeof input.title === 'string' &&
                typeof input.description === 'string'
            );
        },
        fromJson(input): ObjectWithEveryTypeDiscriminatorB {
            const _type = 'B';
            let _title: string;
            if (typeof input.title === 'string') {
                _title = input.title;
            } else {
                _title = '';
            }
            let _description: string;
            if (typeof input.description === 'string') {
                _description = input.description;
            } else {
                _description = '';
            }
            return {
                type: _type,
                title: _title,
                description: _description,
            };
        },
        fromJsonString(input): ObjectWithEveryTypeDiscriminatorB {
            return $$ObjectWithEveryTypeDiscriminatorB.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"type":"B"';
            json += ',"title":';
            json += serializeString(input.title);
            json += ',"description":';
            json += serializeString(input.description);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('type=B');
            queryParts.push(`title=${input.title}`);
            queryParts.push(`description=${input.description}`);
            return queryParts.join('&');
        },
    };

export interface ObjectWithEveryTypeNestedObject {
    id: string;
    timestamp: Date;
    data: ObjectWithEveryTypeNestedObjectData;
}
export const $$ObjectWithEveryTypeNestedObject: ArriModelValidator<ObjectWithEveryTypeNestedObject> =
    {
        new(): ObjectWithEveryTypeNestedObject {
            return {
                id: '',
                timestamp: new Date(),
                data: $$ObjectWithEveryTypeNestedObjectData.new(),
            };
        },
        validate(input): input is ObjectWithEveryTypeNestedObject {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                input.timestamp instanceof Date &&
                $$ObjectWithEveryTypeNestedObjectData.validate(input.data)
            );
        },
        fromJson(input): ObjectWithEveryTypeNestedObject {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            let _data: ObjectWithEveryTypeNestedObjectData;
            if (isObject(input.data)) {
                _data = $$ObjectWithEveryTypeNestedObjectData.fromJson(
                    input.data,
                );
            } else {
                _data = $$ObjectWithEveryTypeNestedObjectData.new();
            }
            return {
                id: _id,
                timestamp: _timestamp,
                data: _data,
            };
        },
        fromJsonString(input): ObjectWithEveryTypeNestedObject {
            return $$ObjectWithEveryTypeNestedObject.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += ',"data":';
            json += $$ObjectWithEveryTypeNestedObjectData.toJsonString(
                input.data,
            );
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryTypeNestedObject/data.',
            );
            return queryParts.join('&');
        },
    };

export interface ObjectWithEveryTypeNestedObjectData {
    id: string;
    timestamp: Date;
    data: ObjectWithEveryTypeNestedObjectDataData;
}
export const $$ObjectWithEveryTypeNestedObjectData: ArriModelValidator<ObjectWithEveryTypeNestedObjectData> =
    {
        new(): ObjectWithEveryTypeNestedObjectData {
            return {
                id: '',
                timestamp: new Date(),
                data: $$ObjectWithEveryTypeNestedObjectDataData.new(),
            };
        },
        validate(input): input is ObjectWithEveryTypeNestedObjectData {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                input.timestamp instanceof Date &&
                $$ObjectWithEveryTypeNestedObjectDataData.validate(input.data)
            );
        },
        fromJson(input): ObjectWithEveryTypeNestedObjectData {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            let _data: ObjectWithEveryTypeNestedObjectDataData;
            if (isObject(input.data)) {
                _data = $$ObjectWithEveryTypeNestedObjectDataData.fromJson(
                    input.data,
                );
            } else {
                _data = $$ObjectWithEveryTypeNestedObjectDataData.new();
            }
            return {
                id: _id,
                timestamp: _timestamp,
                data: _data,
            };
        },
        fromJsonString(input): ObjectWithEveryTypeNestedObjectData {
            return $$ObjectWithEveryTypeNestedObjectData.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += ',"data":';
            json += $$ObjectWithEveryTypeNestedObjectDataData.toJsonString(
                input.data,
            );
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryTypeNestedObjectData/data.',
            );
            return queryParts.join('&');
        },
    };

export interface ObjectWithEveryTypeNestedObjectDataData {
    id: string;
    timestamp: Date;
}
export const $$ObjectWithEveryTypeNestedObjectDataData: ArriModelValidator<ObjectWithEveryTypeNestedObjectDataData> =
    {
        new(): ObjectWithEveryTypeNestedObjectDataData {
            return {
                id: '',
                timestamp: new Date(),
            };
        },
        validate(input): input is ObjectWithEveryTypeNestedObjectDataData {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                input.timestamp instanceof Date
            );
        },
        fromJson(input): ObjectWithEveryTypeNestedObjectDataData {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            return {
                id: _id,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): ObjectWithEveryTypeNestedObjectDataData {
            return $$ObjectWithEveryTypeNestedObjectDataData.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            return queryParts.join('&');
        },
    };

export interface ObjectWithEveryTypeNestedArrayElementElement {
    id: string;
    timestamp: Date;
}
export const $$ObjectWithEveryTypeNestedArrayElementElement: ArriModelValidator<ObjectWithEveryTypeNestedArrayElementElement> =
    {
        new(): ObjectWithEveryTypeNestedArrayElementElement {
            return {
                id: '',
                timestamp: new Date(),
            };
        },
        validate(input): input is ObjectWithEveryTypeNestedArrayElementElement {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                input.timestamp instanceof Date
            );
        },
        fromJson(input): ObjectWithEveryTypeNestedArrayElementElement {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            return {
                id: _id,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): ObjectWithEveryTypeNestedArrayElementElement {
            return $$ObjectWithEveryTypeNestedArrayElementElement.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            return queryParts.join('&');
        },
    };

export interface ObjectWithEveryNullableType {
    any: any;
    boolean: boolean | null;
    string: string | null;
    timestamp: Date | null;
    float32: number | null;
    float64: number | null;
    int8: number | null;
    uint8: number | null;
    int16: number | null;
    uint16: number | null;
    int32: number | null;
    uint32: number | null;
    int64: bigint | null;
    uint64: bigint | null;
    enumerator: ObjectWithEveryNullableTypeEnumerator | null;
    array: (boolean | null)[] | null;
    object: ObjectWithEveryNullableTypeObject | null;
    record: Record<string, bigint | null> | null;
    discriminator: ObjectWithEveryNullableTypeDiscriminator | null;
    nestedObject: ObjectWithEveryNullableTypeNestedObject | null;
    nestedArray:
        | (
              | (ObjectWithEveryNullableTypeNestedArrayElementElement | null)[]
              | null
          )[]
        | null;
}
export const $$ObjectWithEveryNullableType: ArriModelValidator<ObjectWithEveryNullableType> =
    {
        new(): ObjectWithEveryNullableType {
            return {
                any: null,
                boolean: null,
                string: null,
                timestamp: null,
                float32: null,
                float64: null,
                int8: null,
                uint8: null,
                int16: null,
                uint16: null,
                int32: null,
                uint32: null,
                int64: null,
                uint64: null,
                enumerator: null,
                array: null,
                object: null,
                record: null,
                discriminator: null,
                nestedObject: null,
                nestedArray: null,
            };
        },
        validate(input): input is ObjectWithEveryNullableType {
            return (
                isObject(input) &&
                true &&
                (typeof input.boolean === 'boolean' ||
                    input.boolean === null) &&
                (typeof input.string === 'string' || input.string === null) &&
                (input.timestamp instanceof Date || input.timestamp === null) &&
                (typeof input.float32 === 'number' || input.float32 === null) &&
                (typeof input.float64 === 'number' || input.float64 === null) &&
                ((typeof input.int8 === 'number' &&
                    Number.isInteger(input.int8) &&
                    input.int8 >= INT8_MIN &&
                    input.int8 <= INT8_MAX) ||
                    input.int8 === null) &&
                ((typeof input.uint8 === 'number' &&
                    Number.isInteger(input.uint8) &&
                    input.uint8 >= 0 &&
                    input.uint8 <= UINT8_MAX) ||
                    input.uint8 === null) &&
                ((typeof input.int16 === 'number' &&
                    Number.isInteger(input.int16) &&
                    input.int16 >= INT16_MIN &&
                    input.int16 <= INT16_MAX) ||
                    input.int16 === null) &&
                ((typeof input.uint16 === 'number' &&
                    Number.isInteger(input.uint16) &&
                    input.uint16 >= 0 &&
                    input.uint16 <= UINT16_MAX) ||
                    input.uint16 === null) &&
                ((typeof input.int32 === 'number' &&
                    Number.isInteger(input.int32) &&
                    input.int32 >= INT32_MIN &&
                    input.int32 <= INT32_MAX) ||
                    input.int32 === null) &&
                ((typeof input.uint32 === 'number' &&
                    Number.isInteger(input.uint32) &&
                    input.uint32 >= 0 &&
                    input.uint32 <= UINT32_MAX) ||
                    input.uint32 === null) &&
                ((typeof input.int64 === 'bigint' &&
                    input.int64 >= INT64_MIN &&
                    input.int64 <= INT64_MAX) ||
                    input.int64 === null) &&
                ((typeof input.uint64 === 'bigint' &&
                    input.uint64 >= BigInt(0) &&
                    input.uint64 <= UINT64_MAX) ||
                    input.uint64 === null) &&
                ($$ObjectWithEveryNullableTypeEnumerator.validate(
                    input.enumerator,
                ) ||
                    input.enumerator === null) &&
                ((Array.isArray(input.array) &&
                    input.array.every(
                        (_element) =>
                            typeof _element === 'boolean' || _element === null,
                    )) ||
                    input.array === null) &&
                ($$ObjectWithEveryNullableTypeObject.validate(input.object) ||
                    input.object === null) &&
                ((isObject(input.record) &&
                    Object.values(input.record).every(
                        (_value) =>
                            (typeof _value === 'bigint' &&
                                _value >= BigInt(0) &&
                                _value <= UINT64_MAX) ||
                            _value === null,
                    )) ||
                    input.record === null) &&
                ($$ObjectWithEveryNullableTypeDiscriminator.validate(
                    input.discriminator,
                ) ||
                    input.discriminator === null) &&
                ($$ObjectWithEveryNullableTypeNestedObject.validate(
                    input.nestedObject,
                ) ||
                    input.nestedObject === null) &&
                ((Array.isArray(input.nestedArray) &&
                    input.nestedArray.every(
                        (_element) =>
                            (Array.isArray(_element) &&
                                _element.every(
                                    (_element) =>
                                        $$ObjectWithEveryNullableTypeNestedArrayElementElement.validate(
                                            _element,
                                        ) || _element === null,
                                )) ||
                            _element === null,
                    )) ||
                    input.nestedArray === null)
            );
        },
        fromJson(input): ObjectWithEveryNullableType {
            let _any: any;
            _any = input.any;
            let _boolean: boolean | null;
            if (typeof input.boolean === 'boolean') {
                _boolean = input.boolean;
            } else {
                _boolean = null;
            }
            let _string: string | null;
            if (typeof input.string === 'string') {
                _string = input.string;
            } else {
                _string = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            let _float32: number | null;
            if (typeof input.float32 === 'number') {
                _float32 = input.float32;
            } else {
                _float32 = null;
            }
            let _float64: number | null;
            if (typeof input.float64 === 'number') {
                _float64 = input.float64;
            } else {
                _float64 = null;
            }
            let _int8: number | null;
            if (
                typeof input.int8 === 'number' &&
                Number.isInteger(input.int8) &&
                input.int8 >= INT8_MIN &&
                input.int8 <= INT8_MAX
            ) {
                _int8 = input.int8;
            } else {
                _int8 = null;
            }
            let _uint8: number | null;
            if (
                typeof input.uint8 === 'number' &&
                Number.isInteger(input.uint8) &&
                input.uint8 >= 0 &&
                input.uint8 <= UINT8_MAX
            ) {
                _uint8 = input.uint8;
            } else {
                _uint8 = null;
            }
            let _int16: number | null;
            if (
                typeof input.int16 === 'number' &&
                Number.isInteger(input.int16) &&
                input.int16 >= INT16_MIN &&
                input.int16 <= INT16_MAX
            ) {
                _int16 = input.int16;
            } else {
                _int16 = null;
            }
            let _uint16: number | null;
            if (
                typeof input.uint16 === 'number' &&
                Number.isInteger(input.uint16) &&
                input.uint16 >= 0 &&
                input.uint16 <= UINT16_MAX
            ) {
                _uint16 = input.uint16;
            } else {
                _uint16 = null;
            }
            let _int32: number | null;
            if (
                typeof input.int32 === 'number' &&
                Number.isInteger(input.int32) &&
                input.int32 >= INT32_MIN &&
                input.int32 <= INT32_MAX
            ) {
                _int32 = input.int32;
            } else {
                _int32 = null;
            }
            let _uint32: number | null;
            if (
                typeof input.uint32 === 'number' &&
                Number.isInteger(input.uint32) &&
                input.uint32 >= 0 &&
                input.uint32 <= UINT32_MAX
            ) {
                _uint32 = input.uint32;
            } else {
                _uint32 = null;
            }
            let _int64: bigint | null;
            if (typeof input.int64 === 'string') {
                _int64 = BigInt(input.int64);
            } else if (typeof input.int64 === 'bigint') {
                _int64 = input.int64;
            } else {
                _int64 = null;
            }
            let _uint64: bigint | null;
            if (
                typeof input.uint64 === 'string' &&
                BigInt(input.uint64) >= BigInt(0)
            ) {
                _uint64 = BigInt(input.uint64);
            } else if (
                typeof input.uint64 === 'bigint' &&
                input.uint64 >= BigInt(0)
            ) {
                _uint64 = input.uint64;
            } else {
                _uint64 = null;
            }
            let _enumerator: ObjectWithEveryNullableTypeEnumerator | null;
            if (typeof input.enumerator === 'string') {
                _enumerator =
                    $$ObjectWithEveryNullableTypeEnumerator.fromSerialValue(
                        input.enumerator,
                    );
            } else {
                _enumerator = null;
            }
            let _array: (boolean | null)[] | null;
            if (Array.isArray(input.array)) {
                _array = [];
                for (const _arrayEl of input.array) {
                    let _arrayElValue: boolean | null;
                    if (typeof _arrayEl === 'boolean') {
                        _arrayElValue = _arrayEl;
                    } else {
                        _arrayElValue = null;
                    }
                    _array.push(_arrayElValue);
                }
            } else {
                _array = null;
            }
            let _object: ObjectWithEveryNullableTypeObject | null;
            if (isObject(input.object)) {
                _object = $$ObjectWithEveryNullableTypeObject.fromJson(
                    input.object,
                );
            } else {
                _object = null;
            }
            let _record: Record<string, bigint | null> | null;
            if (isObject(input.record)) {
                _record = {};
                for (const [_key, _value] of Object.entries(input.record)) {
                    let _recordValue: bigint | null;
                    if (
                        typeof _value === 'string' &&
                        BigInt(_value) >= BigInt(0)
                    ) {
                        _recordValue = BigInt(_value);
                    } else if (
                        typeof _value === 'bigint' &&
                        _value >= BigInt(0)
                    ) {
                        _recordValue = _value;
                    } else {
                        _recordValue = null;
                    }
                    _record[_key] = _recordValue;
                }
            } else {
                _record = null;
            }
            let _discriminator: ObjectWithEveryNullableTypeDiscriminator | null;
            if (isObject(input.discriminator)) {
                _discriminator =
                    $$ObjectWithEveryNullableTypeDiscriminator.fromJson(
                        input.discriminator,
                    );
            } else {
                _discriminator = null;
            }
            let _nestedObject: ObjectWithEveryNullableTypeNestedObject | null;
            if (isObject(input.nestedObject)) {
                _nestedObject =
                    $$ObjectWithEveryNullableTypeNestedObject.fromJson(
                        input.nestedObject,
                    );
            } else {
                _nestedObject = null;
            }
            let _nestedArray:
                | (
                      | (ObjectWithEveryNullableTypeNestedArrayElementElement | null)[]
                      | null
                  )[]
                | null;
            if (Array.isArray(input.nestedArray)) {
                _nestedArray = [];
                for (const _nestedArrayEl of input.nestedArray) {
                    let _nestedArrayElValue:
                        | (ObjectWithEveryNullableTypeNestedArrayElementElement | null)[]
                        | null;
                    if (Array.isArray(_nestedArrayEl)) {
                        _nestedArrayElValue = [];
                        for (const _nestedArrayElValueEl of _nestedArrayEl) {
                            let _nestedArrayElValueElValue: ObjectWithEveryNullableTypeNestedArrayElementElement | null;
                            if (isObject(_nestedArrayElValueEl)) {
                                _nestedArrayElValueElValue =
                                    $$ObjectWithEveryNullableTypeNestedArrayElementElement.fromJson(
                                        _nestedArrayElValueEl,
                                    );
                            } else {
                                _nestedArrayElValueElValue = null;
                            }
                            _nestedArrayElValue.push(
                                _nestedArrayElValueElValue,
                            );
                        }
                    } else {
                        _nestedArrayElValue = null;
                    }
                    _nestedArray.push(_nestedArrayElValue);
                }
            } else {
                _nestedArray = null;
            }
            return {
                any: _any,
                boolean: _boolean,
                string: _string,
                timestamp: _timestamp,
                float32: _float32,
                float64: _float64,
                int8: _int8,
                uint8: _uint8,
                int16: _int16,
                uint16: _uint16,
                int32: _int32,
                uint32: _uint32,
                int64: _int64,
                uint64: _uint64,
                enumerator: _enumerator,
                array: _array,
                object: _object,
                record: _record,
                discriminator: _discriminator,
                nestedObject: _nestedObject,
                nestedArray: _nestedArray,
            };
        },
        fromJsonString(input): ObjectWithEveryNullableType {
            return $$ObjectWithEveryNullableType.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"any":';
            json += JSON.stringify(input.any);
            json += ',"boolean":';
            json += `${input.boolean}`;
            json += ',"string":';
            if (typeof input.string === 'string') {
                json += serializeString(input.string);
            } else {
                json += 'null';
            }
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += 'null';
            }
            json += ',"float32":';
            json += `${input.float32}`;
            json += ',"float64":';
            json += `${input.float64}`;
            json += ',"int8":';
            json += `${input.int8}`;
            json += ',"uint8":';
            json += `${input.uint8}`;
            json += ',"int16":';
            json += `${input.int16}`;
            json += ',"uint16":';
            json += `${input.uint16}`;
            json += ',"int32":';
            json += `${input.int32}`;
            json += ',"uint32":';
            json += `${input.uint32}`;
            json += ',"int64":';
            if (typeof input.int64 === 'bigint') {
                json += `"${input.int64}"`;
            } else {
                json += 'null';
            }
            json += ',"uint64":';
            if (typeof input.uint64 === 'bigint') {
                json += `"${input.uint64}"`;
            } else {
                json += 'null';
            }
            json += ',"enumerator":';
            if (typeof input.enumerator === 'string') {
                json += `"${input.enumerator}"`;
            } else {
                json += 'null';
            }
            json += ',"array":';
            if (input.array !== null) {
                json += '[';
                for (let i = 0; i < input.array.length; i++) {
                    if (i !== 0) json += ',';
                    const _inputArrayEl = input.array[i];
                    json += `${_inputArrayEl}`;
                }
                json += ']';
            } else {
                json += 'null';
            }
            json += ',"object":';
            if (input.object !== null) {
                json += $$ObjectWithEveryNullableTypeObject.toJsonString(
                    input.object,
                );
            } else {
                json += 'null';
            }
            json += ',"record":';
            if (input.record !== null) {
                json += '{';
                let _recordPropertyCount = 0;
                for (const [_key, _value] of Object.entries(input.record)) {
                    if (_recordPropertyCount !== 0) {
                        json += ',';
                    }
                    json += `${serializeString(_key)}:`;
                    if (typeof _value === 'bigint') {
                        json += `"${_value}"`;
                    } else {
                        json += 'null';
                    }
                    _recordPropertyCount++;
                }
                json += '}';
            } else {
                json += 'null';
            }
            json += ',"discriminator":';
            if (input.discriminator != null) {
                json += $$ObjectWithEveryNullableTypeDiscriminator.toJsonString(
                    input.discriminator,
                );
            } else {
                json += 'null';
            }
            json += ',"nestedObject":';
            if (input.nestedObject !== null) {
                json += $$ObjectWithEveryNullableTypeNestedObject.toJsonString(
                    input.nestedObject,
                );
            } else {
                json += 'null';
            }
            json += ',"nestedArray":';
            if (input.nestedArray !== null) {
                json += '[';
                for (let i = 0; i < input.nestedArray.length; i++) {
                    if (i !== 0) json += ',';
                    const _inputNestedArrayEl = input.nestedArray[i];
                    if (_inputNestedArrayEl !== null) {
                        json += '[';
                        for (let i = 0; i < _inputNestedArrayEl.length; i++) {
                            if (i !== 0) json += ',';
                            const _inputNestedArrayElEl =
                                _inputNestedArrayEl[i];
                            if (_inputNestedArrayElEl !== null) {
                                json +=
                                    $$ObjectWithEveryNullableTypeNestedArrayElementElement.toJsonString(
                                        _inputNestedArrayElEl,
                                    );
                            } else {
                                json += 'null';
                            }
                        }
                        json += ']';
                    } else {
                        json += 'null';
                    }
                }
                json += ']';
            } else {
                json += 'null';
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            console.warn(
                "[WARNING] Cannot serialize any's to query string. Skipping property at /ObjectWithEveryNullableType/any.",
            );
            queryParts.push(`boolean=${input.boolean}`);
            queryParts.push(`string=${input.string}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            queryParts.push(`float32=${input.float32}`);
            queryParts.push(`float64=${input.float64}`);
            queryParts.push(`int8=${input.int8}`);
            queryParts.push(`uint8=${input.uint8}`);
            queryParts.push(`int16=${input.int16}`);
            queryParts.push(`uint16=${input.uint16}`);
            queryParts.push(`int32=${input.int32}`);
            queryParts.push(`uint32=${input.uint32}`);
            queryParts.push(`int64=${input.int64}`);
            queryParts.push(`uint64=${input.uint64}`);
            queryParts.push(`enumerator=${input.enumerator}`);
            console.warn(
                '[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryNullableType/array.',
            );
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryNullableType/object.',
            );
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryNullableType/record.',
            );
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryNullableType/discriminator.',
            );
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryNullableType/nestedObject.',
            );
            console.warn(
                '[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryNullableType/nestedArray.',
            );
            return queryParts.join('&');
        },
    };

export type ObjectWithEveryNullableTypeEnumerator =
    (typeof $$ObjectWithEveryNullableTypeEnumeratorValues)[number];
const $$ObjectWithEveryNullableTypeEnumeratorValues = ['A', 'B', 'C'] as const;
export const $$ObjectWithEveryNullableTypeEnumerator: ArriEnumValidator<ObjectWithEveryNullableTypeEnumerator> =
    {
        new(): ObjectWithEveryNullableTypeEnumerator {
            return $$ObjectWithEveryNullableTypeEnumeratorValues[0];
        },
        validate(input): input is ObjectWithEveryNullableTypeEnumerator {
            return (
                typeof input === 'string' &&
                $$ObjectWithEveryNullableTypeEnumeratorValues.includes(
                    input as any,
                )
            );
        },
        values: $$ObjectWithEveryNullableTypeEnumeratorValues,
        fromSerialValue(input): ObjectWithEveryNullableTypeEnumerator {
            if (
                $$ObjectWithEveryNullableTypeEnumeratorValues.includes(
                    input as any,
                )
            ) {
                return input as ObjectWithEveryNullableTypeEnumerator;
            }
            if (
                $$ObjectWithEveryNullableTypeEnumeratorValues.includes(
                    input.toLowerCase() as any,
                )
            ) {
                return input.toLowerCase() as ObjectWithEveryNullableTypeEnumerator;
            }
            if (
                $$ObjectWithEveryNullableTypeEnumeratorValues.includes(
                    input.toUpperCase() as any,
                )
            ) {
                return input.toUpperCase() as ObjectWithEveryNullableTypeEnumerator;
            }
            return 'A';
        },
    };

export interface ObjectWithEveryNullableTypeObject {
    string: string | null;
    boolean: boolean | null;
    timestamp: Date | null;
}
export const $$ObjectWithEveryNullableTypeObject: ArriModelValidator<ObjectWithEveryNullableTypeObject> =
    {
        new(): ObjectWithEveryNullableTypeObject {
            return {
                string: null,
                boolean: null,
                timestamp: null,
            };
        },
        validate(input): input is ObjectWithEveryNullableTypeObject {
            return (
                isObject(input) &&
                (typeof input.string === 'string' || input.string === null) &&
                (typeof input.boolean === 'boolean' ||
                    input.boolean === null) &&
                (input.timestamp instanceof Date || input.timestamp === null)
            );
        },
        fromJson(input): ObjectWithEveryNullableTypeObject {
            let _string: string | null;
            if (typeof input.string === 'string') {
                _string = input.string;
            } else {
                _string = null;
            }
            let _boolean: boolean | null;
            if (typeof input.boolean === 'boolean') {
                _boolean = input.boolean;
            } else {
                _boolean = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            return {
                string: _string,
                boolean: _boolean,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): ObjectWithEveryNullableTypeObject {
            return $$ObjectWithEveryNullableTypeObject.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"string":';
            if (typeof input.string === 'string') {
                json += serializeString(input.string);
            } else {
                json += 'null';
            }
            json += ',"boolean":';
            json += `${input.boolean}`;
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += 'null';
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`string=${input.string}`);
            queryParts.push(`boolean=${input.boolean}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            return queryParts.join('&');
        },
    };

export type ObjectWithEveryNullableTypeDiscriminator =
    | ObjectWithEveryNullableTypeDiscriminatorA
    | ObjectWithEveryNullableTypeDiscriminatorB;
export const $$ObjectWithEveryNullableTypeDiscriminator: ArriModelValidator<ObjectWithEveryNullableTypeDiscriminator> =
    {
        new(): ObjectWithEveryNullableTypeDiscriminator {
            return $$ObjectWithEveryNullableTypeDiscriminatorA.new();
        },
        validate(input): input is ObjectWithEveryNullableTypeDiscriminator {
            if (!isObject(input)) {
                return false;
            }
            if (typeof input.type !== 'string') {
                return false;
            }
            switch (input.type) {
                case 'A':
                    return $$ObjectWithEveryNullableTypeDiscriminatorA.validate(
                        input,
                    );
                case 'B':
                    return $$ObjectWithEveryNullableTypeDiscriminatorB.validate(
                        input,
                    );
                default:
                    return false;
            }
        },
        fromJson(input): ObjectWithEveryNullableTypeDiscriminator {
            switch (input.type) {
                case 'A':
                    return $$ObjectWithEveryNullableTypeDiscriminatorA.fromJson(
                        input,
                    );
                case 'B':
                    return $$ObjectWithEveryNullableTypeDiscriminatorB.fromJson(
                        input,
                    );
                default:
                    return $$ObjectWithEveryNullableTypeDiscriminatorA.new();
            }
        },
        fromJsonString(input): ObjectWithEveryNullableTypeDiscriminator {
            return $$ObjectWithEveryNullableTypeDiscriminator.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            switch (input.type) {
                case 'A':
                    return $$ObjectWithEveryNullableTypeDiscriminatorA.toJsonString(
                        input,
                    );
                case 'B':
                    return $$ObjectWithEveryNullableTypeDiscriminatorB.toJsonString(
                        input,
                    );
                default:
                    throw new Error(`Unhandled case "${(input as any).type}"`);
            }
        },
        toUrlQueryString(input): string {
            switch (input.type) {
                case 'A':
                    return $$ObjectWithEveryNullableTypeDiscriminatorA.toUrlQueryString(
                        input,
                    );
                case 'B':
                    return $$ObjectWithEveryNullableTypeDiscriminatorB.toUrlQueryString(
                        input,
                    );
                default:
                    throw new Error('Unhandled case');
            }
        },
    };
export interface ObjectWithEveryNullableTypeDiscriminatorA {
    type: 'A';
    title: string | null;
}
const $$ObjectWithEveryNullableTypeDiscriminatorA: ArriModelValidator<ObjectWithEveryNullableTypeDiscriminatorA> =
    {
        new(): ObjectWithEveryNullableTypeDiscriminatorA {
            return {
                type: 'A',
                title: null,
            };
        },
        validate(input): input is ObjectWithEveryNullableTypeDiscriminatorA {
            return (
                isObject(input) &&
                input.type === 'A' &&
                (typeof input.title === 'string' || input.title === null)
            );
        },
        fromJson(input): ObjectWithEveryNullableTypeDiscriminatorA {
            const _type = 'A';
            let _title: string | null;
            if (typeof input.title === 'string') {
                _title = input.title;
            } else {
                _title = null;
            }
            return {
                type: _type,
                title: _title,
            };
        },
        fromJsonString(input): ObjectWithEveryNullableTypeDiscriminatorA {
            return $$ObjectWithEveryNullableTypeDiscriminatorA.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"type":"A"';
            json += ',"title":';
            if (typeof input.title === 'string') {
                json += serializeString(input.title);
            } else {
                json += 'null';
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('type=A');
            queryParts.push(`title=${input.title}`);
            return queryParts.join('&');
        },
    };

export interface ObjectWithEveryNullableTypeDiscriminatorB {
    type: 'B';
    title: string | null;
    description: string | null;
}
const $$ObjectWithEveryNullableTypeDiscriminatorB: ArriModelValidator<ObjectWithEveryNullableTypeDiscriminatorB> =
    {
        new(): ObjectWithEveryNullableTypeDiscriminatorB {
            return {
                type: 'B',
                title: null,
                description: null,
            };
        },
        validate(input): input is ObjectWithEveryNullableTypeDiscriminatorB {
            return (
                isObject(input) &&
                input.type === 'B' &&
                (typeof input.title === 'string' || input.title === null) &&
                (typeof input.description === 'string' ||
                    input.description === null)
            );
        },
        fromJson(input): ObjectWithEveryNullableTypeDiscriminatorB {
            const _type = 'B';
            let _title: string | null;
            if (typeof input.title === 'string') {
                _title = input.title;
            } else {
                _title = null;
            }
            let _description: string | null;
            if (typeof input.description === 'string') {
                _description = input.description;
            } else {
                _description = null;
            }
            return {
                type: _type,
                title: _title,
                description: _description,
            };
        },
        fromJsonString(input): ObjectWithEveryNullableTypeDiscriminatorB {
            return $$ObjectWithEveryNullableTypeDiscriminatorB.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"type":"B"';
            json += ',"title":';
            if (typeof input.title === 'string') {
                json += serializeString(input.title);
            } else {
                json += 'null';
            }
            json += ',"description":';
            if (typeof input.description === 'string') {
                json += serializeString(input.description);
            } else {
                json += 'null';
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('type=B');
            queryParts.push(`title=${input.title}`);
            queryParts.push(`description=${input.description}`);
            return queryParts.join('&');
        },
    };

export interface ObjectWithEveryNullableTypeNestedObject {
    id: string | null;
    timestamp: Date | null;
    data: ObjectWithEveryNullableTypeNestedObjectData | null;
}
export const $$ObjectWithEveryNullableTypeNestedObject: ArriModelValidator<ObjectWithEveryNullableTypeNestedObject> =
    {
        new(): ObjectWithEveryNullableTypeNestedObject {
            return {
                id: null,
                timestamp: null,
                data: null,
            };
        },
        validate(input): input is ObjectWithEveryNullableTypeNestedObject {
            return (
                isObject(input) &&
                (typeof input.id === 'string' || input.id === null) &&
                (input.timestamp instanceof Date || input.timestamp === null) &&
                ($$ObjectWithEveryNullableTypeNestedObjectData.validate(
                    input.data,
                ) ||
                    input.data === null)
            );
        },
        fromJson(input): ObjectWithEveryNullableTypeNestedObject {
            let _id: string | null;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            let _data: ObjectWithEveryNullableTypeNestedObjectData | null;
            if (isObject(input.data)) {
                _data = $$ObjectWithEveryNullableTypeNestedObjectData.fromJson(
                    input.data,
                );
            } else {
                _data = null;
            }
            return {
                id: _id,
                timestamp: _timestamp,
                data: _data,
            };
        },
        fromJsonString(input): ObjectWithEveryNullableTypeNestedObject {
            return $$ObjectWithEveryNullableTypeNestedObject.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            if (typeof input.id === 'string') {
                json += serializeString(input.id);
            } else {
                json += 'null';
            }
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += 'null';
            }
            json += ',"data":';
            if (input.data !== null) {
                json +=
                    $$ObjectWithEveryNullableTypeNestedObjectData.toJsonString(
                        input.data,
                    );
            } else {
                json += 'null';
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryNullableTypeNestedObject/data.',
            );
            return queryParts.join('&');
        },
    };

export interface ObjectWithEveryNullableTypeNestedObjectData {
    id: string | null;
    timestamp: Date | null;
    data: ObjectWithEveryNullableTypeNestedObjectDataData | null;
}
export const $$ObjectWithEveryNullableTypeNestedObjectData: ArriModelValidator<ObjectWithEveryNullableTypeNestedObjectData> =
    {
        new(): ObjectWithEveryNullableTypeNestedObjectData {
            return {
                id: null,
                timestamp: null,
                data: null,
            };
        },
        validate(input): input is ObjectWithEveryNullableTypeNestedObjectData {
            return (
                isObject(input) &&
                (typeof input.id === 'string' || input.id === null) &&
                (input.timestamp instanceof Date || input.timestamp === null) &&
                ($$ObjectWithEveryNullableTypeNestedObjectDataData.validate(
                    input.data,
                ) ||
                    input.data === null)
            );
        },
        fromJson(input): ObjectWithEveryNullableTypeNestedObjectData {
            let _id: string | null;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            let _data: ObjectWithEveryNullableTypeNestedObjectDataData | null;
            if (isObject(input.data)) {
                _data =
                    $$ObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
                        input.data,
                    );
            } else {
                _data = null;
            }
            return {
                id: _id,
                timestamp: _timestamp,
                data: _data,
            };
        },
        fromJsonString(input): ObjectWithEveryNullableTypeNestedObjectData {
            return $$ObjectWithEveryNullableTypeNestedObjectData.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            if (typeof input.id === 'string') {
                json += serializeString(input.id);
            } else {
                json += 'null';
            }
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += 'null';
            }
            json += ',"data":';
            if (input.data !== null) {
                json +=
                    $$ObjectWithEveryNullableTypeNestedObjectDataData.toJsonString(
                        input.data,
                    );
            } else {
                json += 'null';
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryNullableTypeNestedObjectData/data.',
            );
            return queryParts.join('&');
        },
    };

export interface ObjectWithEveryNullableTypeNestedObjectDataData {
    id: string | null;
    timestamp: Date | null;
}
export const $$ObjectWithEveryNullableTypeNestedObjectDataData: ArriModelValidator<ObjectWithEveryNullableTypeNestedObjectDataData> =
    {
        new(): ObjectWithEveryNullableTypeNestedObjectDataData {
            return {
                id: null,
                timestamp: null,
            };
        },
        validate(
            input,
        ): input is ObjectWithEveryNullableTypeNestedObjectDataData {
            return (
                isObject(input) &&
                (typeof input.id === 'string' || input.id === null) &&
                (input.timestamp instanceof Date || input.timestamp === null)
            );
        },
        fromJson(input): ObjectWithEveryNullableTypeNestedObjectDataData {
            let _id: string | null;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            return {
                id: _id,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): ObjectWithEveryNullableTypeNestedObjectDataData {
            return $$ObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            if (typeof input.id === 'string') {
                json += serializeString(input.id);
            } else {
                json += 'null';
            }
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += 'null';
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            return queryParts.join('&');
        },
    };

export interface ObjectWithEveryNullableTypeNestedArrayElementElement {
    id: string | null;
    timestamp: Date | null;
}
export const $$ObjectWithEveryNullableTypeNestedArrayElementElement: ArriModelValidator<ObjectWithEveryNullableTypeNestedArrayElementElement> =
    {
        new(): ObjectWithEveryNullableTypeNestedArrayElementElement {
            return {
                id: null,
                timestamp: null,
            };
        },
        validate(
            input,
        ): input is ObjectWithEveryNullableTypeNestedArrayElementElement {
            return (
                isObject(input) &&
                (typeof input.id === 'string' || input.id === null) &&
                (input.timestamp instanceof Date || input.timestamp === null)
            );
        },
        fromJson(input): ObjectWithEveryNullableTypeNestedArrayElementElement {
            let _id: string | null;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = null;
            }
            let _timestamp: Date | null;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = null;
            }
            return {
                id: _id,
                timestamp: _timestamp,
            };
        },
        fromJsonString(
            input,
        ): ObjectWithEveryNullableTypeNestedArrayElementElement {
            return $$ObjectWithEveryNullableTypeNestedArrayElementElement.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            if (typeof input.id === 'string') {
                json += serializeString(input.id);
            } else {
                json += 'null';
            }
            json += ',"timestamp":';
            if (input.timestamp instanceof Date) {
                json += `"${input.timestamp.toISOString()}"`;
            } else {
                json += 'null';
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp?.toISOString()}`);
            return queryParts.join('&');
        },
    };

export interface ObjectWithPascalCaseKeys {
    createdAt: Date;
    displayName: string;
    phoneNumber: string | null;
    emailAddress?: string;
    isAdmin?: boolean;
}
export const $$ObjectWithPascalCaseKeys: ArriModelValidator<ObjectWithPascalCaseKeys> =
    {
        new(): ObjectWithPascalCaseKeys {
            return {
                createdAt: new Date(),
                displayName: '',
                phoneNumber: null,
            };
        },
        validate(input): input is ObjectWithPascalCaseKeys {
            return (
                isObject(input) &&
                input.createdAt instanceof Date &&
                typeof input.displayName === 'string' &&
                (typeof input.phoneNumber === 'string' ||
                    input.phoneNumber === null) &&
                (typeof input.emailAddress === 'string' ||
                    typeof input.emailAddress === 'undefined') &&
                (typeof input.isAdmin === 'boolean' ||
                    typeof input.isAdmin === 'undefined')
            );
        },
        fromJson(input): ObjectWithPascalCaseKeys {
            let _CreatedAt: Date;
            if (typeof input.CreatedAt === 'string') {
                _CreatedAt = new Date(input.CreatedAt);
            } else if (input.CreatedAt instanceof Date) {
                _CreatedAt = input.CreatedAt;
            } else {
                _CreatedAt = new Date();
            }
            let _DisplayName: string;
            if (typeof input.DisplayName === 'string') {
                _DisplayName = input.DisplayName;
            } else {
                _DisplayName = '';
            }
            let _PhoneNumber: string | null;
            if (typeof input.PhoneNumber === 'string') {
                _PhoneNumber = input.PhoneNumber;
            } else {
                _PhoneNumber = null;
            }
            let _EmailAddress: string | undefined;
            if (typeof input.EmailAddress !== 'undefined') {
                if (typeof input.EmailAddress === 'string') {
                    _EmailAddress = input.EmailAddress;
                } else {
                    _EmailAddress = '';
                }
            }
            let _IsAdmin: boolean | undefined;
            if (typeof input.IsAdmin !== 'undefined') {
                if (typeof input.IsAdmin === 'boolean') {
                    _IsAdmin = input.IsAdmin;
                } else {
                    _IsAdmin = false;
                }
            }
            return {
                createdAt: _CreatedAt,
                displayName: _DisplayName,
                phoneNumber: _PhoneNumber,
                emailAddress: _EmailAddress,
                isAdmin: _IsAdmin,
            };
        },
        fromJsonString(input): ObjectWithPascalCaseKeys {
            return $$ObjectWithPascalCaseKeys.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"CreatedAt":';
            json += `"${input.createdAt.toISOString()}"`;
            json += ',"DisplayName":';
            json += serializeString(input.displayName);
            json += ',"PhoneNumber":';
            if (typeof input.phoneNumber === 'string') {
                json += serializeString(input.phoneNumber);
            } else {
                json += 'null';
            }
            if (typeof input.emailAddress !== 'undefined') {
                json += `,"EmailAddress":`;
                json += serializeString(input.emailAddress);
            }
            if (typeof input.isAdmin !== 'undefined') {
                json += `,"IsAdmin":`;
                json += `${input.isAdmin}`;
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`CreatedAt=${input.createdAt.toISOString()}`);
            queryParts.push(`DisplayName=${input.displayName}`);
            queryParts.push(`PhoneNumber=${input.phoneNumber}`);
            if (typeof input.emailAddress !== 'undefined') {
                queryParts.push(`EmailAddress=${input.emailAddress}`);
            }
            if (typeof input.isAdmin !== 'undefined') {
                queryParts.push(`IsAdmin=${input.isAdmin}`);
            }
            return queryParts.join('&');
        },
    };

export interface ObjectWithSnakeCaseKeys {
    createdAt: Date;
    displayName: string;
    phoneNumber: string | null;
    emailAddress?: string;
    isAdmin?: boolean;
}
export const $$ObjectWithSnakeCaseKeys: ArriModelValidator<ObjectWithSnakeCaseKeys> =
    {
        new(): ObjectWithSnakeCaseKeys {
            return {
                createdAt: new Date(),
                displayName: '',
                phoneNumber: null,
            };
        },
        validate(input): input is ObjectWithSnakeCaseKeys {
            return (
                isObject(input) &&
                input.createdAt instanceof Date &&
                typeof input.displayName === 'string' &&
                (typeof input.phoneNumber === 'string' ||
                    input.phoneNumber === null) &&
                (typeof input.emailAddress === 'string' ||
                    typeof input.emailAddress === 'undefined') &&
                (typeof input.isAdmin === 'boolean' ||
                    typeof input.isAdmin === 'undefined')
            );
        },
        fromJson(input): ObjectWithSnakeCaseKeys {
            let _created_at: Date;
            if (typeof input.created_at === 'string') {
                _created_at = new Date(input.created_at);
            } else if (input.created_at instanceof Date) {
                _created_at = input.created_at;
            } else {
                _created_at = new Date();
            }
            let _display_name: string;
            if (typeof input.display_name === 'string') {
                _display_name = input.display_name;
            } else {
                _display_name = '';
            }
            let _phone_number: string | null;
            if (typeof input.phone_number === 'string') {
                _phone_number = input.phone_number;
            } else {
                _phone_number = null;
            }
            let _email_address: string | undefined;
            if (typeof input.email_address !== 'undefined') {
                if (typeof input.email_address === 'string') {
                    _email_address = input.email_address;
                } else {
                    _email_address = '';
                }
            }
            let _is_admin: boolean | undefined;
            if (typeof input.is_admin !== 'undefined') {
                if (typeof input.is_admin === 'boolean') {
                    _is_admin = input.is_admin;
                } else {
                    _is_admin = false;
                }
            }
            return {
                createdAt: _created_at,
                displayName: _display_name,
                phoneNumber: _phone_number,
                emailAddress: _email_address,
                isAdmin: _is_admin,
            };
        },
        fromJsonString(input): ObjectWithSnakeCaseKeys {
            return $$ObjectWithSnakeCaseKeys.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"created_at":';
            json += `"${input.createdAt.toISOString()}"`;
            json += ',"display_name":';
            json += serializeString(input.displayName);
            json += ',"phone_number":';
            if (typeof input.phoneNumber === 'string') {
                json += serializeString(input.phoneNumber);
            } else {
                json += 'null';
            }
            if (typeof input.emailAddress !== 'undefined') {
                json += `,"email_address":`;
                json += serializeString(input.emailAddress);
            }
            if (typeof input.isAdmin !== 'undefined') {
                json += `,"is_admin":`;
                json += `${input.isAdmin}`;
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`created_at=${input.createdAt.toISOString()}`);
            queryParts.push(`display_name=${input.displayName}`);
            queryParts.push(`phone_number=${input.phoneNumber}`);
            if (typeof input.emailAddress !== 'undefined') {
                queryParts.push(`email_address=${input.emailAddress}`);
            }
            if (typeof input.isAdmin !== 'undefined') {
                queryParts.push(`is_admin=${input.isAdmin}`);
            }
            return queryParts.join('&');
        },
    };

export interface ObjectWithEveryOptionalType {
    any?: any;
    boolean?: boolean;
    string?: string;
    timestamp?: Date;
    float32?: number;
    float64?: number;
    int8?: number;
    uint8?: number;
    int16?: number;
    uint16?: number;
    int32?: number;
    uint32?: number;
    int64?: bigint;
    uint64?: bigint;
    enumerator?: ObjectWithEveryOptionalTypeEnumerator;
    array?: boolean[];
    object?: ObjectWithEveryOptionalTypeObject;
    record?: Record<string, bigint>;
    discriminator?: ObjectWithEveryOptionalTypeDiscriminator;
    nestedObject?: ObjectWithEveryOptionalTypeNestedObject;
    nestedArray?: ObjectWithEveryOptionalTypeNestedArrayElementElement[][];
}
export const $$ObjectWithEveryOptionalType: ArriModelValidator<ObjectWithEveryOptionalType> =
    {
        new(): ObjectWithEveryOptionalType {
            return {};
        },
        validate(input): input is ObjectWithEveryOptionalType {
            return (
                isObject(input) &&
                (true || typeof input.any === 'undefined') &&
                (typeof input.boolean === 'boolean' ||
                    typeof input.boolean === 'undefined') &&
                (typeof input.string === 'string' ||
                    typeof input.string === 'undefined') &&
                (input.timestamp instanceof Date ||
                    typeof input.timestamp === 'undefined') &&
                (typeof input.float32 === 'number' ||
                    typeof input.float32 === 'undefined') &&
                (typeof input.float64 === 'number' ||
                    typeof input.float64 === 'undefined') &&
                ((typeof input.int8 === 'number' &&
                    Number.isInteger(input.int8) &&
                    input.int8 >= INT8_MIN &&
                    input.int8 <= INT8_MAX) ||
                    typeof input.int8 === 'undefined') &&
                ((typeof input.uint8 === 'number' &&
                    Number.isInteger(input.uint8) &&
                    input.uint8 >= 0 &&
                    input.uint8 <= UINT8_MAX) ||
                    typeof input.uint8 === 'undefined') &&
                ((typeof input.int16 === 'number' &&
                    Number.isInteger(input.int16) &&
                    input.int16 >= INT16_MIN &&
                    input.int16 <= INT16_MAX) ||
                    typeof input.int16 === 'undefined') &&
                ((typeof input.uint16 === 'number' &&
                    Number.isInteger(input.uint16) &&
                    input.uint16 >= 0 &&
                    input.uint16 <= UINT16_MAX) ||
                    typeof input.uint16 === 'undefined') &&
                ((typeof input.int32 === 'number' &&
                    Number.isInteger(input.int32) &&
                    input.int32 >= INT32_MIN &&
                    input.int32 <= INT32_MAX) ||
                    typeof input.int32 === 'undefined') &&
                ((typeof input.uint32 === 'number' &&
                    Number.isInteger(input.uint32) &&
                    input.uint32 >= 0 &&
                    input.uint32 <= UINT32_MAX) ||
                    typeof input.uint32 === 'undefined') &&
                ((typeof input.int64 === 'bigint' &&
                    input.int64 >= INT64_MIN &&
                    input.int64 <= INT64_MAX) ||
                    typeof input.int64 === 'undefined') &&
                ((typeof input.uint64 === 'bigint' &&
                    input.uint64 >= BigInt(0) &&
                    input.uint64 <= UINT64_MAX) ||
                    typeof input.uint64 === 'undefined') &&
                ($$ObjectWithEveryOptionalTypeEnumerator.validate(
                    input.enumerator,
                ) ||
                    typeof input.enumerator === 'undefined') &&
                ((Array.isArray(input.array) &&
                    input.array.every(
                        (_element) => typeof _element === 'boolean',
                    )) ||
                    typeof input.array === 'undefined') &&
                ($$ObjectWithEveryOptionalTypeObject.validate(input.object) ||
                    typeof input.object === 'undefined') &&
                ((isObject(input.record) &&
                    Object.values(input.record).every(
                        (_value) =>
                            typeof _value === 'bigint' &&
                            _value >= BigInt(0) &&
                            _value <= UINT64_MAX,
                    )) ||
                    typeof input.record === 'undefined') &&
                ($$ObjectWithEveryOptionalTypeDiscriminator.validate(
                    input.discriminator,
                ) ||
                    typeof input.discriminator === 'undefined') &&
                ($$ObjectWithEveryOptionalTypeNestedObject.validate(
                    input.nestedObject,
                ) ||
                    typeof input.nestedObject === 'undefined') &&
                ((Array.isArray(input.nestedArray) &&
                    input.nestedArray.every(
                        (_element) =>
                            Array.isArray(_element) &&
                            _element.every((_element) =>
                                $$ObjectWithEveryOptionalTypeNestedArrayElementElement.validate(
                                    _element,
                                ),
                            ),
                    )) ||
                    typeof input.nestedArray === 'undefined')
            );
        },
        fromJson(input): ObjectWithEveryOptionalType {
            let _any: any | undefined;
            if (typeof input.any !== 'undefined') {
                _any = input.any;
            }
            let _boolean: boolean | undefined;
            if (typeof input.boolean !== 'undefined') {
                if (typeof input.boolean === 'boolean') {
                    _boolean = input.boolean;
                } else {
                    _boolean = false;
                }
            }
            let _string: string | undefined;
            if (typeof input.string !== 'undefined') {
                if (typeof input.string === 'string') {
                    _string = input.string;
                } else {
                    _string = '';
                }
            }
            let _timestamp: Date | undefined;
            if (typeof input.timestamp !== 'undefined') {
                if (typeof input.timestamp === 'string') {
                    _timestamp = new Date(input.timestamp);
                } else if (input.timestamp instanceof Date) {
                    _timestamp = input.timestamp;
                } else {
                    _timestamp = new Date();
                }
            }
            let _float32: number | undefined;
            if (typeof input.float32 !== 'undefined') {
                if (typeof input.float32 === 'number') {
                    _float32 = input.float32;
                } else {
                    _float32 = 0;
                }
            }
            let _float64: number | undefined;
            if (typeof input.float64 !== 'undefined') {
                if (typeof input.float64 === 'number') {
                    _float64 = input.float64;
                } else {
                    _float64 = 0;
                }
            }
            let _int8: number | undefined;
            if (typeof input.int8 !== 'undefined') {
                if (
                    typeof input.int8 === 'number' &&
                    Number.isInteger(input.int8) &&
                    input.int8 >= INT8_MIN &&
                    input.int8 <= INT8_MAX
                ) {
                    _int8 = input.int8;
                } else {
                    _int8 = 0;
                }
            }
            let _uint8: number | undefined;
            if (typeof input.uint8 !== 'undefined') {
                if (
                    typeof input.uint8 === 'number' &&
                    Number.isInteger(input.uint8) &&
                    input.uint8 >= 0 &&
                    input.uint8 <= UINT8_MAX
                ) {
                    _uint8 = input.uint8;
                } else {
                    _uint8 = 0;
                }
            }
            let _int16: number | undefined;
            if (typeof input.int16 !== 'undefined') {
                if (
                    typeof input.int16 === 'number' &&
                    Number.isInteger(input.int16) &&
                    input.int16 >= INT16_MIN &&
                    input.int16 <= INT16_MAX
                ) {
                    _int16 = input.int16;
                } else {
                    _int16 = 0;
                }
            }
            let _uint16: number | undefined;
            if (typeof input.uint16 !== 'undefined') {
                if (
                    typeof input.uint16 === 'number' &&
                    Number.isInteger(input.uint16) &&
                    input.uint16 >= 0 &&
                    input.uint16 <= UINT16_MAX
                ) {
                    _uint16 = input.uint16;
                } else {
                    _uint16 = 0;
                }
            }
            let _int32: number | undefined;
            if (typeof input.int32 !== 'undefined') {
                if (
                    typeof input.int32 === 'number' &&
                    Number.isInteger(input.int32) &&
                    input.int32 >= INT32_MIN &&
                    input.int32 <= INT32_MAX
                ) {
                    _int32 = input.int32;
                } else {
                    _int32 = 0;
                }
            }
            let _uint32: number | undefined;
            if (typeof input.uint32 !== 'undefined') {
                if (
                    typeof input.uint32 === 'number' &&
                    Number.isInteger(input.uint32) &&
                    input.uint32 >= 0 &&
                    input.uint32 <= UINT32_MAX
                ) {
                    _uint32 = input.uint32;
                } else {
                    _uint32 = 0;
                }
            }
            let _int64: bigint | undefined;
            if (typeof input.int64 !== 'undefined') {
                if (typeof input.int64 === 'string') {
                    _int64 = BigInt(input.int64);
                } else if (typeof input.int64 === 'bigint') {
                    _int64 = input.int64;
                } else {
                    _int64 = BigInt(0);
                }
            }
            let _uint64: bigint | undefined;
            if (typeof input.uint64 !== 'undefined') {
                if (
                    typeof input.uint64 === 'string' &&
                    BigInt(input.uint64) >= BigInt(0)
                ) {
                    _uint64 = BigInt(input.uint64);
                } else if (
                    typeof input.uint64 === 'bigint' &&
                    input.uint64 >= BigInt(0)
                ) {
                    _uint64 = input.uint64;
                } else {
                    _uint64 = BigInt(0);
                }
            }
            let _enumerator: ObjectWithEveryOptionalTypeEnumerator | undefined;
            if (typeof input.enumerator !== 'undefined') {
                if (typeof input.enumerator === 'string') {
                    _enumerator =
                        $$ObjectWithEveryOptionalTypeEnumerator.fromSerialValue(
                            input.enumerator,
                        );
                } else {
                    _enumerator = $$ObjectWithEveryOptionalTypeEnumerator.new();
                }
            }
            let _array: boolean[] | undefined;
            if (typeof input.array !== 'undefined') {
                if (Array.isArray(input.array)) {
                    _array = [];
                    for (const _arrayEl of input.array) {
                        let _arrayElValue: boolean;
                        if (typeof _arrayEl === 'boolean') {
                            _arrayElValue = _arrayEl;
                        } else {
                            _arrayElValue = false;
                        }
                        _array.push(_arrayElValue);
                    }
                } else {
                    _array = [];
                }
            }
            let _object: ObjectWithEveryOptionalTypeObject | undefined;
            if (typeof input.object !== 'undefined') {
                if (isObject(input.object)) {
                    _object = $$ObjectWithEveryOptionalTypeObject.fromJson(
                        input.object,
                    );
                } else {
                    _object = $$ObjectWithEveryOptionalTypeObject.new();
                }
            }
            let _record: Record<string, bigint> | undefined;
            if (typeof input.record !== 'undefined') {
                if (isObject(input.record)) {
                    _record = {};
                    for (const [_key, _value] of Object.entries(input.record)) {
                        let _recordValue: bigint;
                        if (
                            typeof _value === 'string' &&
                            BigInt(_value) >= BigInt(0)
                        ) {
                            _recordValue = BigInt(_value);
                        } else if (
                            typeof _value === 'bigint' &&
                            _value >= BigInt(0)
                        ) {
                            _recordValue = _value;
                        } else {
                            _recordValue = BigInt(0);
                        }
                        _record[_key] = _recordValue;
                    }
                } else {
                    _record = {};
                }
            }
            let _discriminator:
                | ObjectWithEveryOptionalTypeDiscriminator
                | undefined;
            if (typeof input.discriminator !== 'undefined') {
                if (isObject(input.discriminator)) {
                    _discriminator =
                        $$ObjectWithEveryOptionalTypeDiscriminator.fromJson(
                            input.discriminator,
                        );
                } else {
                    _discriminator =
                        $$ObjectWithEveryOptionalTypeDiscriminator.new();
                }
            }
            let _nestedObject:
                | ObjectWithEveryOptionalTypeNestedObject
                | undefined;
            if (typeof input.nestedObject !== 'undefined') {
                if (isObject(input.nestedObject)) {
                    _nestedObject =
                        $$ObjectWithEveryOptionalTypeNestedObject.fromJson(
                            input.nestedObject,
                        );
                } else {
                    _nestedObject =
                        $$ObjectWithEveryOptionalTypeNestedObject.new();
                }
            }
            let _nestedArray:
                | ObjectWithEveryOptionalTypeNestedArrayElementElement[][]
                | undefined;
            if (typeof input.nestedArray !== 'undefined') {
                if (Array.isArray(input.nestedArray)) {
                    _nestedArray = [];
                    for (const _nestedArrayEl of input.nestedArray) {
                        let _nestedArrayElValue: ObjectWithEveryOptionalTypeNestedArrayElementElement[];
                        if (Array.isArray(_nestedArrayEl)) {
                            _nestedArrayElValue = [];
                            for (const _nestedArrayElValueEl of _nestedArrayEl) {
                                let _nestedArrayElValueElValue: ObjectWithEveryOptionalTypeNestedArrayElementElement;
                                if (isObject(_nestedArrayElValueEl)) {
                                    _nestedArrayElValueElValue =
                                        $$ObjectWithEveryOptionalTypeNestedArrayElementElement.fromJson(
                                            _nestedArrayElValueEl,
                                        );
                                } else {
                                    _nestedArrayElValueElValue =
                                        $$ObjectWithEveryOptionalTypeNestedArrayElementElement.new();
                                }
                                _nestedArrayElValue.push(
                                    _nestedArrayElValueElValue,
                                );
                            }
                        } else {
                            _nestedArrayElValue = [];
                        }
                        _nestedArray.push(_nestedArrayElValue);
                    }
                } else {
                    _nestedArray = [];
                }
            }
            return {
                any: _any,
                boolean: _boolean,
                string: _string,
                timestamp: _timestamp,
                float32: _float32,
                float64: _float64,
                int8: _int8,
                uint8: _uint8,
                int16: _int16,
                uint16: _uint16,
                int32: _int32,
                uint32: _uint32,
                int64: _int64,
                uint64: _uint64,
                enumerator: _enumerator,
                array: _array,
                object: _object,
                record: _record,
                discriminator: _discriminator,
                nestedObject: _nestedObject,
                nestedArray: _nestedArray,
            };
        },
        fromJsonString(input): ObjectWithEveryOptionalType {
            return $$ObjectWithEveryOptionalType.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            let _hasKey = false;
            if (typeof input.any !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"any":';
                json += JSON.stringify(input.any);
                _hasKey = true;
            }
            if (typeof input.boolean !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"boolean":';
                json += `${input.boolean}`;
                _hasKey = true;
            }
            if (typeof input.string !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"string":';
                json += serializeString(input.string);
                _hasKey = true;
            }
            if (typeof input.timestamp !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"timestamp":';
                json += `"${input.timestamp.toISOString()}"`;
                _hasKey = true;
            }
            if (typeof input.float32 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"float32":';
                json += `${input.float32}`;
                _hasKey = true;
            }
            if (typeof input.float64 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"float64":';
                json += `${input.float64}`;
                _hasKey = true;
            }
            if (typeof input.int8 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"int8":';
                json += `${input.int8}`;
                _hasKey = true;
            }
            if (typeof input.uint8 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"uint8":';
                json += `${input.uint8}`;
                _hasKey = true;
            }
            if (typeof input.int16 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"int16":';
                json += `${input.int16}`;
                _hasKey = true;
            }
            if (typeof input.uint16 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"uint16":';
                json += `${input.uint16}`;
                _hasKey = true;
            }
            if (typeof input.int32 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"int32":';
                json += `${input.int32}`;
                _hasKey = true;
            }
            if (typeof input.uint32 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"uint32":';
                json += `${input.uint32}`;
                _hasKey = true;
            }
            if (typeof input.int64 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"int64":';
                json += `"${input.int64}"`;
                _hasKey = true;
            }
            if (typeof input.uint64 !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"uint64":';
                json += `"${input.uint64}"`;
                _hasKey = true;
            }
            if (typeof input.enumerator !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"enumerator":';
                json += `"${input.enumerator}"`;
                _hasKey = true;
            }
            if (typeof input.array !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"array":';
                json += '[';
                for (let i = 0; i < input.array.length; i++) {
                    if (i !== 0) json += ',';
                    const _inputArrayEl = input.array[i];
                    json += `${_inputArrayEl}`;
                }
                json += ']';
                _hasKey = true;
            }
            if (typeof input.object !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"object":';
                json += $$ObjectWithEveryOptionalTypeObject.toJsonString(
                    input.object,
                );
                _hasKey = true;
            }
            if (typeof input.record !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"record":';
                json += '{';
                let _recordPropertyCount = 0;
                for (const [_key, _value] of Object.entries(input.record)) {
                    if (_recordPropertyCount !== 0) {
                        json += ',';
                    }
                    json += `${serializeString(_key)}:`;
                    json += `"${_value}"`;
                    _recordPropertyCount++;
                }
                json += '}';

                _hasKey = true;
            }
            if (typeof input.discriminator !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"discriminator":';
                json += $$ObjectWithEveryOptionalTypeDiscriminator.toJsonString(
                    input.discriminator,
                );
                _hasKey = true;
            }
            if (typeof input.nestedObject !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"nestedObject":';
                json += $$ObjectWithEveryOptionalTypeNestedObject.toJsonString(
                    input.nestedObject,
                );
                _hasKey = true;
            }
            if (typeof input.nestedArray !== 'undefined') {
                if (_hasKey) json += ',';
                json += '"nestedArray":';
                json += '[';
                for (let i = 0; i < input.nestedArray.length; i++) {
                    if (i !== 0) json += ',';
                    const _inputNestedArrayEl = input.nestedArray[i];
                    json += '[';
                    for (let i = 0; i < _inputNestedArrayEl.length; i++) {
                        if (i !== 0) json += ',';
                        const _inputNestedArrayElEl = _inputNestedArrayEl[i];
                        json +=
                            $$ObjectWithEveryOptionalTypeNestedArrayElementElement.toJsonString(
                                _inputNestedArrayElEl,
                            );
                    }
                    json += ']';
                }
                json += ']';
                _hasKey = true;
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            if (typeof input.any !== 'undefined') {
                console.warn(
                    "[WARNING] Cannot serialize any's to query string. Skipping property at /ObjectWithEveryOptionalType/any.",
                );
            }
            if (typeof input.boolean !== 'undefined') {
                queryParts.push(`boolean=${input.boolean}`);
            }
            if (typeof input.string !== 'undefined') {
                queryParts.push(`string=${input.string}`);
            }
            if (typeof input.timestamp !== 'undefined') {
                queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            }
            if (typeof input.float32 !== 'undefined') {
                queryParts.push(`float32=${input.float32}`);
            }
            if (typeof input.float64 !== 'undefined') {
                queryParts.push(`float64=${input.float64}`);
            }
            if (typeof input.int8 !== 'undefined') {
                queryParts.push(`int8=${input.int8}`);
            }
            if (typeof input.uint8 !== 'undefined') {
                queryParts.push(`uint8=${input.uint8}`);
            }
            if (typeof input.int16 !== 'undefined') {
                queryParts.push(`int16=${input.int16}`);
            }
            if (typeof input.uint16 !== 'undefined') {
                queryParts.push(`uint16=${input.uint16}`);
            }
            if (typeof input.int32 !== 'undefined') {
                queryParts.push(`int32=${input.int32}`);
            }
            if (typeof input.uint32 !== 'undefined') {
                queryParts.push(`uint32=${input.uint32}`);
            }
            if (typeof input.int64 !== 'undefined') {
                queryParts.push(`int64=${input.int64}`);
            }
            if (typeof input.uint64 !== 'undefined') {
                queryParts.push(`uint64=${input.uint64}`);
            }
            if (typeof input.enumerator !== 'undefined') {
                queryParts.push(`enumerator=${input.enumerator}`);
            }
            if (typeof input.array !== 'undefined') {
                console.warn(
                    '[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryOptionalType/array.',
                );
            }
            if (typeof input.object !== 'undefined') {
                console.warn(
                    '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryOptionalType/object.',
                );
            }
            if (typeof input.record !== 'undefined') {
                console.warn(
                    '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryOptionalType/record.',
                );
            }
            if (typeof input.discriminator !== 'undefined') {
                console.warn(
                    '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryOptionalType/discriminator.',
                );
            }
            if (typeof input.nestedObject !== 'undefined') {
                console.warn(
                    '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryOptionalType/nestedObject.',
                );
            }
            if (typeof input.nestedArray !== 'undefined') {
                console.warn(
                    '[WARNING] Cannot serialize arrays to query string. Skipping property at /ObjectWithEveryOptionalType/nestedArray.',
                );
            }
            return queryParts.join('&');
        },
    };

export type ObjectWithEveryOptionalTypeEnumerator =
    (typeof $$ObjectWithEveryOptionalTypeEnumeratorValues)[number];
const $$ObjectWithEveryOptionalTypeEnumeratorValues = ['A', 'B', 'C'] as const;
export const $$ObjectWithEveryOptionalTypeEnumerator: ArriEnumValidator<ObjectWithEveryOptionalTypeEnumerator> =
    {
        new(): ObjectWithEveryOptionalTypeEnumerator {
            return $$ObjectWithEveryOptionalTypeEnumeratorValues[0];
        },
        validate(input): input is ObjectWithEveryOptionalTypeEnumerator {
            return (
                typeof input === 'string' &&
                $$ObjectWithEveryOptionalTypeEnumeratorValues.includes(
                    input as any,
                )
            );
        },
        values: $$ObjectWithEveryOptionalTypeEnumeratorValues,
        fromSerialValue(input): ObjectWithEveryOptionalTypeEnumerator {
            if (
                $$ObjectWithEveryOptionalTypeEnumeratorValues.includes(
                    input as any,
                )
            ) {
                return input as ObjectWithEveryOptionalTypeEnumerator;
            }
            if (
                $$ObjectWithEveryOptionalTypeEnumeratorValues.includes(
                    input.toLowerCase() as any,
                )
            ) {
                return input.toLowerCase() as ObjectWithEveryOptionalTypeEnumerator;
            }
            if (
                $$ObjectWithEveryOptionalTypeEnumeratorValues.includes(
                    input.toUpperCase() as any,
                )
            ) {
                return input.toUpperCase() as ObjectWithEveryOptionalTypeEnumerator;
            }
            return 'A';
        },
    };

export interface ObjectWithEveryOptionalTypeObject {
    string: string;
    boolean: boolean;
    timestamp: Date;
}
export const $$ObjectWithEveryOptionalTypeObject: ArriModelValidator<ObjectWithEveryOptionalTypeObject> =
    {
        new(): ObjectWithEveryOptionalTypeObject {
            return {
                string: '',
                boolean: false,
                timestamp: new Date(),
            };
        },
        validate(input): input is ObjectWithEveryOptionalTypeObject {
            return (
                isObject(input) &&
                typeof input.string === 'string' &&
                typeof input.boolean === 'boolean' &&
                input.timestamp instanceof Date
            );
        },
        fromJson(input): ObjectWithEveryOptionalTypeObject {
            let _string: string;
            if (typeof input.string === 'string') {
                _string = input.string;
            } else {
                _string = '';
            }
            let _boolean: boolean;
            if (typeof input.boolean === 'boolean') {
                _boolean = input.boolean;
            } else {
                _boolean = false;
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            return {
                string: _string,
                boolean: _boolean,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): ObjectWithEveryOptionalTypeObject {
            return $$ObjectWithEveryOptionalTypeObject.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"string":';
            json += serializeString(input.string);
            json += ',"boolean":';
            json += `${input.boolean}`;
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`string=${input.string}`);
            queryParts.push(`boolean=${input.boolean}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            return queryParts.join('&');
        },
    };

export type ObjectWithEveryOptionalTypeDiscriminator =
    | ObjectWithEveryOptionalTypeDiscriminatorA
    | ObjectWithEveryOptionalTypeDiscriminatorB;
export const $$ObjectWithEveryOptionalTypeDiscriminator: ArriModelValidator<ObjectWithEveryOptionalTypeDiscriminator> =
    {
        new(): ObjectWithEveryOptionalTypeDiscriminator {
            return $$ObjectWithEveryOptionalTypeDiscriminatorA.new();
        },
        validate(input): input is ObjectWithEveryOptionalTypeDiscriminator {
            if (!isObject(input)) {
                return false;
            }
            if (typeof input.type !== 'string') {
                return false;
            }
            switch (input.type) {
                case 'A':
                    return $$ObjectWithEveryOptionalTypeDiscriminatorA.validate(
                        input,
                    );
                case 'B':
                    return $$ObjectWithEveryOptionalTypeDiscriminatorB.validate(
                        input,
                    );
                default:
                    return false;
            }
        },
        fromJson(input): ObjectWithEveryOptionalTypeDiscriminator {
            switch (input.type) {
                case 'A':
                    return $$ObjectWithEveryOptionalTypeDiscriminatorA.fromJson(
                        input,
                    );
                case 'B':
                    return $$ObjectWithEveryOptionalTypeDiscriminatorB.fromJson(
                        input,
                    );
                default:
                    return $$ObjectWithEveryOptionalTypeDiscriminatorA.new();
            }
        },
        fromJsonString(input): ObjectWithEveryOptionalTypeDiscriminator {
            return $$ObjectWithEveryOptionalTypeDiscriminator.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            switch (input.type) {
                case 'A':
                    return $$ObjectWithEveryOptionalTypeDiscriminatorA.toJsonString(
                        input,
                    );
                case 'B':
                    return $$ObjectWithEveryOptionalTypeDiscriminatorB.toJsonString(
                        input,
                    );
                default:
                    throw new Error(`Unhandled case "${(input as any).type}"`);
            }
        },
        toUrlQueryString(input): string {
            switch (input.type) {
                case 'A':
                    return $$ObjectWithEveryOptionalTypeDiscriminatorA.toUrlQueryString(
                        input,
                    );
                case 'B':
                    return $$ObjectWithEveryOptionalTypeDiscriminatorB.toUrlQueryString(
                        input,
                    );
                default:
                    throw new Error('Unhandled case');
            }
        },
    };
export interface ObjectWithEveryOptionalTypeDiscriminatorA {
    type: 'A';
    title: string;
}
const $$ObjectWithEveryOptionalTypeDiscriminatorA: ArriModelValidator<ObjectWithEveryOptionalTypeDiscriminatorA> =
    {
        new(): ObjectWithEveryOptionalTypeDiscriminatorA {
            return {
                type: 'A',
                title: '',
            };
        },
        validate(input): input is ObjectWithEveryOptionalTypeDiscriminatorA {
            return (
                isObject(input) &&
                input.type === 'A' &&
                typeof input.title === 'string'
            );
        },
        fromJson(input): ObjectWithEveryOptionalTypeDiscriminatorA {
            const _type = 'A';
            let _title: string;
            if (typeof input.title === 'string') {
                _title = input.title;
            } else {
                _title = '';
            }
            return {
                type: _type,
                title: _title,
            };
        },
        fromJsonString(input): ObjectWithEveryOptionalTypeDiscriminatorA {
            return $$ObjectWithEveryOptionalTypeDiscriminatorA.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"type":"A"';
            json += ',"title":';
            json += serializeString(input.title);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('type=A');
            queryParts.push(`title=${input.title}`);
            return queryParts.join('&');
        },
    };

export interface ObjectWithEveryOptionalTypeDiscriminatorB {
    type: 'B';
    title: string;
    description: string;
}
const $$ObjectWithEveryOptionalTypeDiscriminatorB: ArriModelValidator<ObjectWithEveryOptionalTypeDiscriminatorB> =
    {
        new(): ObjectWithEveryOptionalTypeDiscriminatorB {
            return {
                type: 'B',
                title: '',
                description: '',
            };
        },
        validate(input): input is ObjectWithEveryOptionalTypeDiscriminatorB {
            return (
                isObject(input) &&
                input.type === 'B' &&
                typeof input.title === 'string' &&
                typeof input.description === 'string'
            );
        },
        fromJson(input): ObjectWithEveryOptionalTypeDiscriminatorB {
            const _type = 'B';
            let _title: string;
            if (typeof input.title === 'string') {
                _title = input.title;
            } else {
                _title = '';
            }
            let _description: string;
            if (typeof input.description === 'string') {
                _description = input.description;
            } else {
                _description = '';
            }
            return {
                type: _type,
                title: _title,
                description: _description,
            };
        },
        fromJsonString(input): ObjectWithEveryOptionalTypeDiscriminatorB {
            return $$ObjectWithEveryOptionalTypeDiscriminatorB.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"type":"B"';
            json += ',"title":';
            json += serializeString(input.title);
            json += ',"description":';
            json += serializeString(input.description);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('type=B');
            queryParts.push(`title=${input.title}`);
            queryParts.push(`description=${input.description}`);
            return queryParts.join('&');
        },
    };

export interface ObjectWithEveryOptionalTypeNestedObject {
    id: string;
    timestamp: Date;
    data: ObjectWithEveryOptionalTypeNestedObjectData;
}
export const $$ObjectWithEveryOptionalTypeNestedObject: ArriModelValidator<ObjectWithEveryOptionalTypeNestedObject> =
    {
        new(): ObjectWithEveryOptionalTypeNestedObject {
            return {
                id: '',
                timestamp: new Date(),
                data: $$ObjectWithEveryOptionalTypeNestedObjectData.new(),
            };
        },
        validate(input): input is ObjectWithEveryOptionalTypeNestedObject {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                input.timestamp instanceof Date &&
                $$ObjectWithEveryOptionalTypeNestedObjectData.validate(
                    input.data,
                )
            );
        },
        fromJson(input): ObjectWithEveryOptionalTypeNestedObject {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            let _data: ObjectWithEveryOptionalTypeNestedObjectData;
            if (isObject(input.data)) {
                _data = $$ObjectWithEveryOptionalTypeNestedObjectData.fromJson(
                    input.data,
                );
            } else {
                _data = $$ObjectWithEveryOptionalTypeNestedObjectData.new();
            }
            return {
                id: _id,
                timestamp: _timestamp,
                data: _data,
            };
        },
        fromJsonString(input): ObjectWithEveryOptionalTypeNestedObject {
            return $$ObjectWithEveryOptionalTypeNestedObject.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += ',"data":';
            json += $$ObjectWithEveryOptionalTypeNestedObjectData.toJsonString(
                input.data,
            );
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryOptionalTypeNestedObject/data.',
            );
            return queryParts.join('&');
        },
    };

export interface ObjectWithEveryOptionalTypeNestedObjectData {
    id: string;
    timestamp: Date;
    data: ObjectWithEveryOptionalTypeNestedObjectDataData;
}
export const $$ObjectWithEveryOptionalTypeNestedObjectData: ArriModelValidator<ObjectWithEveryOptionalTypeNestedObjectData> =
    {
        new(): ObjectWithEveryOptionalTypeNestedObjectData {
            return {
                id: '',
                timestamp: new Date(),
                data: $$ObjectWithEveryOptionalTypeNestedObjectDataData.new(),
            };
        },
        validate(input): input is ObjectWithEveryOptionalTypeNestedObjectData {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                input.timestamp instanceof Date &&
                $$ObjectWithEveryOptionalTypeNestedObjectDataData.validate(
                    input.data,
                )
            );
        },
        fromJson(input): ObjectWithEveryOptionalTypeNestedObjectData {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            let _data: ObjectWithEveryOptionalTypeNestedObjectDataData;
            if (isObject(input.data)) {
                _data =
                    $$ObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
                        input.data,
                    );
            } else {
                _data = $$ObjectWithEveryOptionalTypeNestedObjectDataData.new();
            }
            return {
                id: _id,
                timestamp: _timestamp,
                data: _data,
            };
        },
        fromJsonString(input): ObjectWithEveryOptionalTypeNestedObjectData {
            return $$ObjectWithEveryOptionalTypeNestedObjectData.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += ',"data":';
            json +=
                $$ObjectWithEveryOptionalTypeNestedObjectDataData.toJsonString(
                    input.data,
                );
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /ObjectWithEveryOptionalTypeNestedObjectData/data.',
            );
            return queryParts.join('&');
        },
    };

export interface ObjectWithEveryOptionalTypeNestedObjectDataData {
    id: string;
    timestamp: Date;
}
export const $$ObjectWithEveryOptionalTypeNestedObjectDataData: ArriModelValidator<ObjectWithEveryOptionalTypeNestedObjectDataData> =
    {
        new(): ObjectWithEveryOptionalTypeNestedObjectDataData {
            return {
                id: '',
                timestamp: new Date(),
            };
        },
        validate(
            input,
        ): input is ObjectWithEveryOptionalTypeNestedObjectDataData {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                input.timestamp instanceof Date
            );
        },
        fromJson(input): ObjectWithEveryOptionalTypeNestedObjectDataData {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            return {
                id: _id,
                timestamp: _timestamp,
            };
        },
        fromJsonString(input): ObjectWithEveryOptionalTypeNestedObjectDataData {
            return $$ObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            return queryParts.join('&');
        },
    };

export interface ObjectWithEveryOptionalTypeNestedArrayElementElement {
    id: string;
    timestamp: Date;
}
export const $$ObjectWithEveryOptionalTypeNestedArrayElementElement: ArriModelValidator<ObjectWithEveryOptionalTypeNestedArrayElementElement> =
    {
        new(): ObjectWithEveryOptionalTypeNestedArrayElementElement {
            return {
                id: '',
                timestamp: new Date(),
            };
        },
        validate(
            input,
        ): input is ObjectWithEveryOptionalTypeNestedArrayElementElement {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                input.timestamp instanceof Date
            );
        },
        fromJson(input): ObjectWithEveryOptionalTypeNestedArrayElementElement {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _timestamp: Date;
            if (typeof input.timestamp === 'string') {
                _timestamp = new Date(input.timestamp);
            } else if (input.timestamp instanceof Date) {
                _timestamp = input.timestamp;
            } else {
                _timestamp = new Date();
            }
            return {
                id: _id,
                timestamp: _timestamp,
            };
        },
        fromJsonString(
            input,
        ): ObjectWithEveryOptionalTypeNestedArrayElementElement {
            return $$ObjectWithEveryOptionalTypeNestedArrayElementElement.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"timestamp":';
            json += `"${input.timestamp.toISOString()}"`;
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`timestamp=${input.timestamp.toISOString()}`);
            return queryParts.join('&');
        },
    };

export interface RecursiveObject {
    left: RecursiveObject | null;
    right: RecursiveObject | null;
    value: string;
}
export const $$RecursiveObject: ArriModelValidator<RecursiveObject> = {
    new(): RecursiveObject {
        return {
            left: null,
            right: null,
            value: '',
        };
    },
    validate(input): input is RecursiveObject {
        return (
            isObject(input) &&
            ($$RecursiveObject.validate(input.left) || input.left === null) &&
            ($$RecursiveObject.validate(input.right) || input.right === null) &&
            typeof input.value === 'string'
        );
    },
    fromJson(input): RecursiveObject {
        let _left: RecursiveObject | null;
        if (isObject(input.left)) {
            _left = $$RecursiveObject.fromJson(input.left);
        } else {
            _left = null;
        }
        let _right: RecursiveObject | null;
        if (isObject(input.right)) {
            _right = $$RecursiveObject.fromJson(input.right);
        } else {
            _right = null;
        }
        let _value: string;
        if (typeof input.value === 'string') {
            _value = input.value;
        } else {
            _value = '';
        }
        return {
            left: _left,
            right: _right,
            value: _value,
        };
    },
    fromJsonString(input): RecursiveObject {
        return $$RecursiveObject.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"left":';
        if (input.left !== null) {
            json += $$RecursiveObject.toJsonString(input.left);
        } else {
            json += 'null';
        }
        json += ',"right":';
        if (input.right !== null) {
            json += $$RecursiveObject.toJsonString(input.right);
        } else {
            json += 'null';
        }
        json += ',"value":';
        json += serializeString(input.value);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        console.warn(
            '[WARNING] Nested objects cannot be serialized to query string. Ignoring property at /RecursiveObject/left.',
        );
        console.warn(
            '[WARNING] Nested objects cannot be serialized to query string. Ignoring property at /RecursiveObject/right.',
        );
        queryParts.push(`value=${input.value}`);
        return queryParts.join('&');
    },
};

export type RecursiveUnion =
    | RecursiveUnionChild
    | RecursiveUnionChildren
    | RecursiveUnionText
    | RecursiveUnionShape;
export const $$RecursiveUnion: ArriModelValidator<RecursiveUnion> = {
    new(): RecursiveUnion {
        return $$RecursiveUnionChild.new();
    },
    validate(input): input is RecursiveUnion {
        if (!isObject(input)) {
            return false;
        }
        if (typeof input.type !== 'string') {
            return false;
        }
        switch (input.type) {
            case 'CHILD':
                return $$RecursiveUnionChild.validate(input);
            case 'CHILDREN':
                return $$RecursiveUnionChildren.validate(input);
            case 'TEXT':
                return $$RecursiveUnionText.validate(input);
            case 'SHAPE':
                return $$RecursiveUnionShape.validate(input);
            default:
                return false;
        }
    },
    fromJson(input): RecursiveUnion {
        switch (input.type) {
            case 'CHILD':
                return $$RecursiveUnionChild.fromJson(input);
            case 'CHILDREN':
                return $$RecursiveUnionChildren.fromJson(input);
            case 'TEXT':
                return $$RecursiveUnionText.fromJson(input);
            case 'SHAPE':
                return $$RecursiveUnionShape.fromJson(input);
            default:
                return $$RecursiveUnionChild.new();
        }
    },
    fromJsonString(input): RecursiveUnion {
        return $$RecursiveUnion.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        switch (input.type) {
            case 'CHILD':
                return $$RecursiveUnionChild.toJsonString(input);
            case 'CHILDREN':
                return $$RecursiveUnionChildren.toJsonString(input);
            case 'TEXT':
                return $$RecursiveUnionText.toJsonString(input);
            case 'SHAPE':
                return $$RecursiveUnionShape.toJsonString(input);
            default:
                throw new Error(`Unhandled case "${(input as any).type}"`);
        }
    },
    toUrlQueryString(input): string {
        switch (input.type) {
            case 'CHILD':
                return $$RecursiveUnionChild.toUrlQueryString(input);
            case 'CHILDREN':
                return $$RecursiveUnionChildren.toUrlQueryString(input);
            case 'TEXT':
                return $$RecursiveUnionText.toUrlQueryString(input);
            case 'SHAPE':
                return $$RecursiveUnionShape.toUrlQueryString(input);
            default:
                throw new Error('Unhandled case');
        }
    },
};
/**
 * Child node
 */
export interface RecursiveUnionChild {
    type: 'CHILD';
    data: RecursiveUnion;
}
const $$RecursiveUnionChild: ArriModelValidator<RecursiveUnionChild> = {
    new(): RecursiveUnionChild {
        return {
            type: 'CHILD',
            data: RecursiveUnion.new(),
        };
    },
    validate(input): input is RecursiveUnionChild {
        return (
            isObject(input) &&
            input.type === 'CHILD' &&
            $$RecursiveUnion.validate(input.data)
        );
    },
    fromJson(input): RecursiveUnionChild {
        const _type = 'CHILD';
        let _data: RecursiveUnion;
        if (isObject(input.data)) {
            _data = $$RecursiveUnion.fromJson(input.data);
        } else {
            _data = RecursiveUnion.new();
        }
        return {
            type: _type,
            data: _data,
        };
    },
    fromJsonString(input): RecursiveUnionChild {
        return $$RecursiveUnionChild.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"type":"CHILD"';
        json += ',"data":';
        json += $$RecursiveUnion.toJsonString(input.data);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push('type=CHILD');
        console.warn(
            '[WARNING] Nested objects cannot be serialized to query string. Ignoring property at /RecursiveUnionChild/data.',
        );
        return queryParts.join('&');
    },
};

/**
 * List of children node
 */
export interface RecursiveUnionChildren {
    type: 'CHILDREN';
    data: RecursiveUnion[];
}
const $$RecursiveUnionChildren: ArriModelValidator<RecursiveUnionChildren> = {
    new(): RecursiveUnionChildren {
        return {
            type: 'CHILDREN',
            data: [],
        };
    },
    validate(input): input is RecursiveUnionChildren {
        return (
            isObject(input) &&
            input.type === 'CHILDREN' &&
            Array.isArray(input.data) &&
            input.data.every((_element) => $$RecursiveUnion.validate(_element))
        );
    },
    fromJson(input): RecursiveUnionChildren {
        const _type = 'CHILDREN';
        let _data: RecursiveUnion[];
        if (Array.isArray(input.data)) {
            _data = [];
            for (const _dataEl of input.data) {
                let _dataElValue: RecursiveUnion;
                if (isObject(_dataEl)) {
                    _dataElValue = $$RecursiveUnion.fromJson(_dataEl);
                } else {
                    _dataElValue = RecursiveUnion.new();
                }
                _data.push(_dataElValue);
            }
        } else {
            _data = [];
        }
        return {
            type: _type,
            data: _data,
        };
    },
    fromJsonString(input): RecursiveUnionChildren {
        return $$RecursiveUnionChildren.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"type":"CHILDREN"';
        json += ',"data":';
        json += '[';
        for (let i = 0; i < input.data.length; i++) {
            if (i !== 0) json += ',';
            const _inputDataEl = input.data[i];
            json += $$RecursiveUnion.toJsonString(_inputDataEl);
        }
        json += ']';
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push('type=CHILDREN');
        console.warn(
            '[WARNING] Cannot serialize arrays to query string. Skipping property at /RecursiveUnionChildren/data.',
        );
        return queryParts.join('&');
    },
};

/**
 * Text node
 */
export interface RecursiveUnionText {
    type: 'TEXT';
    data: string;
}
const $$RecursiveUnionText: ArriModelValidator<RecursiveUnionText> = {
    new(): RecursiveUnionText {
        return {
            type: 'TEXT',
            data: '',
        };
    },
    validate(input): input is RecursiveUnionText {
        return (
            isObject(input) &&
            input.type === 'TEXT' &&
            typeof input.data === 'string'
        );
    },
    fromJson(input): RecursiveUnionText {
        const _type = 'TEXT';
        let _data: string;
        if (typeof input.data === 'string') {
            _data = input.data;
        } else {
            _data = '';
        }
        return {
            type: _type,
            data: _data,
        };
    },
    fromJsonString(input): RecursiveUnionText {
        return $$RecursiveUnionText.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"type":"TEXT"';
        json += ',"data":';
        json += serializeString(input.data);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push('type=TEXT');
        queryParts.push(`data=${input.data}`);
        return queryParts.join('&');
    },
};

/**
 * Shape node
 */
export interface RecursiveUnionShape {
    type: 'SHAPE';
    data: RecursiveUnionShapeData;
}
const $$RecursiveUnionShape: ArriModelValidator<RecursiveUnionShape> = {
    new(): RecursiveUnionShape {
        return {
            type: 'SHAPE',
            data: $$RecursiveUnionShapeData.new(),
        };
    },
    validate(input): input is RecursiveUnionShape {
        return (
            isObject(input) &&
            input.type === 'SHAPE' &&
            $$RecursiveUnionShapeData.validate(input.data)
        );
    },
    fromJson(input): RecursiveUnionShape {
        const _type = 'SHAPE';
        let _data: RecursiveUnionShapeData;
        if (isObject(input.data)) {
            _data = $$RecursiveUnionShapeData.fromJson(input.data);
        } else {
            _data = $$RecursiveUnionShapeData.new();
        }
        return {
            type: _type,
            data: _data,
        };
    },
    fromJsonString(input): RecursiveUnionShape {
        return $$RecursiveUnionShape.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"type":"SHAPE"';
        json += ',"data":';
        json += $$RecursiveUnionShapeData.toJsonString(input.data);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push('type=SHAPE');
        console.warn(
            '[WARNING] Cannot serialize nested objects to query string. Skipping property at /RecursiveUnionShape/data.',
        );
        return queryParts.join('&');
    },
};

export interface RecursiveUnionShapeData {
    width: number;
    height: number;
    color: string;
}
export const $$RecursiveUnionShapeData: ArriModelValidator<RecursiveUnionShapeData> =
    {
        new(): RecursiveUnionShapeData {
            return {
                width: 0,
                height: 0,
                color: '',
            };
        },
        validate(input): input is RecursiveUnionShapeData {
            return (
                isObject(input) &&
                typeof input.width === 'number' &&
                typeof input.height === 'number' &&
                typeof input.color === 'string'
            );
        },
        fromJson(input): RecursiveUnionShapeData {
            let _width: number;
            if (typeof input.width === 'number') {
                _width = input.width;
            } else {
                _width = 0;
            }
            let _height: number;
            if (typeof input.height === 'number') {
                _height = input.height;
            } else {
                _height = 0;
            }
            let _color: string;
            if (typeof input.color === 'string') {
                _color = input.color;
            } else {
                _color = '';
            }
            return {
                width: _width,
                height: _height,
                color: _color,
            };
        },
        fromJsonString(input): RecursiveUnionShapeData {
            return $$RecursiveUnionShapeData.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"width":';
            json += `${input.width}`;
            json += ',"height":';
            json += `${input.height}`;
            json += ',"color":';
            json += serializeString(input.color);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`width=${input.width}`);
            queryParts.push(`height=${input.height}`);
            queryParts.push(`color=${input.color}`);
            return queryParts.join('&');
        },
    };

export interface AutoReconnectParams {
    messageCount: number;
}
export const $$AutoReconnectParams: ArriModelValidator<AutoReconnectParams> = {
    new(): AutoReconnectParams {
        return {
            messageCount: 0,
        };
    },
    validate(input): input is AutoReconnectParams {
        return (
            isObject(input) &&
            typeof input.messageCount === 'number' &&
            Number.isInteger(input.messageCount) &&
            input.messageCount >= 0 &&
            input.messageCount <= UINT8_MAX
        );
    },
    fromJson(input): AutoReconnectParams {
        let _messageCount: number;
        if (
            typeof input.messageCount === 'number' &&
            Number.isInteger(input.messageCount) &&
            input.messageCount >= 0 &&
            input.messageCount <= UINT8_MAX
        ) {
            _messageCount = input.messageCount;
        } else {
            _messageCount = 0;
        }
        return {
            messageCount: _messageCount,
        };
    },
    fromJsonString(input): AutoReconnectParams {
        return $$AutoReconnectParams.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"messageCount":';
        json += `${input.messageCount}`;
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`messageCount=${input.messageCount}`);
        return queryParts.join('&');
    },
};

export interface AutoReconnectResponse {
    count: number;
    message: string;
}
export const $$AutoReconnectResponse: ArriModelValidator<AutoReconnectResponse> =
    {
        new(): AutoReconnectResponse {
            return {
                count: 0,
                message: '',
            };
        },
        validate(input): input is AutoReconnectResponse {
            return (
                isObject(input) &&
                typeof input.count === 'number' &&
                Number.isInteger(input.count) &&
                input.count >= 0 &&
                input.count <= UINT8_MAX &&
                typeof input.message === 'string'
            );
        },
        fromJson(input): AutoReconnectResponse {
            let _count: number;
            if (
                typeof input.count === 'number' &&
                Number.isInteger(input.count) &&
                input.count >= 0 &&
                input.count <= UINT8_MAX
            ) {
                _count = input.count;
            } else {
                _count = 0;
            }
            let _message: string;
            if (typeof input.message === 'string') {
                _message = input.message;
            } else {
                _message = '';
            }
            return {
                count: _count,
                message: _message,
            };
        },
        fromJsonString(input): AutoReconnectResponse {
            return $$AutoReconnectResponse.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"count":';
            json += `${input.count}`;
            json += ',"message":';
            json += serializeString(input.message);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`count=${input.count}`);
            queryParts.push(`message=${input.message}`);
            return queryParts.join('&');
        },
    };

export interface StreamConnectionErrorTestParams {
    statusCode: number;
    statusMessage: string;
}
export const $$StreamConnectionErrorTestParams: ArriModelValidator<StreamConnectionErrorTestParams> =
    {
        new(): StreamConnectionErrorTestParams {
            return {
                statusCode: 0,
                statusMessage: '',
            };
        },
        validate(input): input is StreamConnectionErrorTestParams {
            return (
                isObject(input) &&
                typeof input.statusCode === 'number' &&
                Number.isInteger(input.statusCode) &&
                input.statusCode >= INT32_MIN &&
                input.statusCode <= INT32_MAX &&
                typeof input.statusMessage === 'string'
            );
        },
        fromJson(input): StreamConnectionErrorTestParams {
            let _statusCode: number;
            if (
                typeof input.statusCode === 'number' &&
                Number.isInteger(input.statusCode) &&
                input.statusCode >= INT32_MIN &&
                input.statusCode <= INT32_MAX
            ) {
                _statusCode = input.statusCode;
            } else {
                _statusCode = 0;
            }
            let _statusMessage: string;
            if (typeof input.statusMessage === 'string') {
                _statusMessage = input.statusMessage;
            } else {
                _statusMessage = '';
            }
            return {
                statusCode: _statusCode,
                statusMessage: _statusMessage,
            };
        },
        fromJsonString(input): StreamConnectionErrorTestParams {
            return $$StreamConnectionErrorTestParams.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"statusCode":';
            json += `${input.statusCode}`;
            json += ',"statusMessage":';
            json += serializeString(input.statusMessage);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`statusCode=${input.statusCode}`);
            queryParts.push(`statusMessage=${input.statusMessage}`);
            return queryParts.join('&');
        },
    };

export interface StreamConnectionErrorTestResponse {
    message: string;
}
export const $$StreamConnectionErrorTestResponse: ArriModelValidator<StreamConnectionErrorTestResponse> =
    {
        new(): StreamConnectionErrorTestResponse {
            return {
                message: '',
            };
        },
        validate(input): input is StreamConnectionErrorTestResponse {
            return isObject(input) && typeof input.message === 'string';
        },
        fromJson(input): StreamConnectionErrorTestResponse {
            let _message: string;
            if (typeof input.message === 'string') {
                _message = input.message;
            } else {
                _message = '';
            }
            return {
                message: _message,
            };
        },
        fromJsonString(input): StreamConnectionErrorTestResponse {
            return $$StreamConnectionErrorTestResponse.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"message":';
            json += serializeString(input.message);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`message=${input.message}`);
            return queryParts.join('&');
        },
    };

export interface StreamLargeObjectsResponse {
    numbers: number[];
    objects: StreamLargeObjectsResponseObjectsElement[];
}
export const $$StreamLargeObjectsResponse: ArriModelValidator<StreamLargeObjectsResponse> =
    {
        new(): StreamLargeObjectsResponse {
            return {
                numbers: [],
                objects: [],
            };
        },
        validate(input): input is StreamLargeObjectsResponse {
            return (
                isObject(input) &&
                Array.isArray(input.numbers) &&
                input.numbers.every(
                    (_element) => typeof _element === 'number',
                ) &&
                Array.isArray(input.objects) &&
                input.objects.every((_element) =>
                    $$StreamLargeObjectsResponseObjectsElement.validate(
                        _element,
                    ),
                )
            );
        },
        fromJson(input): StreamLargeObjectsResponse {
            let _numbers: number[];
            if (Array.isArray(input.numbers)) {
                _numbers = [];
                for (const _numbersEl of input.numbers) {
                    let _numbersElValue: number;
                    if (typeof _numbersEl === 'number') {
                        _numbersElValue = _numbersEl;
                    } else {
                        _numbersElValue = 0;
                    }
                    _numbers.push(_numbersElValue);
                }
            } else {
                _numbers = [];
            }
            let _objects: StreamLargeObjectsResponseObjectsElement[];
            if (Array.isArray(input.objects)) {
                _objects = [];
                for (const _objectsEl of input.objects) {
                    let _objectsElValue: StreamLargeObjectsResponseObjectsElement;
                    if (isObject(_objectsEl)) {
                        _objectsElValue =
                            $$StreamLargeObjectsResponseObjectsElement.fromJson(
                                _objectsEl,
                            );
                    } else {
                        _objectsElValue =
                            $$StreamLargeObjectsResponseObjectsElement.new();
                    }
                    _objects.push(_objectsElValue);
                }
            } else {
                _objects = [];
            }
            return {
                numbers: _numbers,
                objects: _objects,
            };
        },
        fromJsonString(input): StreamLargeObjectsResponse {
            return $$StreamLargeObjectsResponse.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"numbers":';
            json += '[';
            for (let i = 0; i < input.numbers.length; i++) {
                if (i !== 0) json += ',';
                const _inputNumbersEl = input.numbers[i];
                json += `${_inputNumbersEl}`;
            }
            json += ']';
            json += ',"objects":';
            json += '[';
            for (let i = 0; i < input.objects.length; i++) {
                if (i !== 0) json += ',';
                const _inputObjectsEl = input.objects[i];
                json +=
                    $$StreamLargeObjectsResponseObjectsElement.toJsonString(
                        _inputObjectsEl,
                    );
            }
            json += ']';
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            console.warn(
                '[WARNING] Cannot serialize arrays to query string. Skipping property at /StreamLargeObjectsResponse/numbers.',
            );
            console.warn(
                '[WARNING] Cannot serialize arrays to query string. Skipping property at /StreamLargeObjectsResponse/objects.',
            );
            return queryParts.join('&');
        },
    };

export interface StreamLargeObjectsResponseObjectsElement {
    id: string;
    name: string;
    email: string;
}
export const $$StreamLargeObjectsResponseObjectsElement: ArriModelValidator<StreamLargeObjectsResponseObjectsElement> =
    {
        new(): StreamLargeObjectsResponseObjectsElement {
            return {
                id: '',
                name: '',
                email: '',
            };
        },
        validate(input): input is StreamLargeObjectsResponseObjectsElement {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                typeof input.name === 'string' &&
                typeof input.email === 'string'
            );
        },
        fromJson(input): StreamLargeObjectsResponseObjectsElement {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _name: string;
            if (typeof input.name === 'string') {
                _name = input.name;
            } else {
                _name = '';
            }
            let _email: string;
            if (typeof input.email === 'string') {
                _email = input.email;
            } else {
                _email = '';
            }
            return {
                id: _id,
                name: _name,
                email: _email,
            };
        },
        fromJsonString(input): StreamLargeObjectsResponseObjectsElement {
            return $$StreamLargeObjectsResponseObjectsElement.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"name":';
            json += serializeString(input.name);
            json += ',"email":';
            json += serializeString(input.email);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`name=${input.name}`);
            queryParts.push(`email=${input.email}`);
            return queryParts.join('&');
        },
    };

export interface ChatMessageParams {
    channelId: string;
}
export const $$ChatMessageParams: ArriModelValidator<ChatMessageParams> = {
    new(): ChatMessageParams {
        return {
            channelId: '',
        };
    },
    validate(input): input is ChatMessageParams {
        return isObject(input) && typeof input.channelId === 'string';
    },
    fromJson(input): ChatMessageParams {
        let _channelId: string;
        if (typeof input.channelId === 'string') {
            _channelId = input.channelId;
        } else {
            _channelId = '';
        }
        return {
            channelId: _channelId,
        };
    },
    fromJsonString(input): ChatMessageParams {
        return $$ChatMessageParams.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"channelId":';
        json += serializeString(input.channelId);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`channelId=${input.channelId}`);
        return queryParts.join('&');
    },
};

export type ChatMessage = ChatMessageText | ChatMessageImage | ChatMessageUrl;
export const $$ChatMessage: ArriModelValidator<ChatMessage> = {
    new(): ChatMessage {
        return $$ChatMessageText.new();
    },
    validate(input): input is ChatMessage {
        if (!isObject(input)) {
            return false;
        }
        if (typeof input.messageType !== 'string') {
            return false;
        }
        switch (input.messageType) {
            case 'TEXT':
                return $$ChatMessageText.validate(input);
            case 'IMAGE':
                return $$ChatMessageImage.validate(input);
            case 'URL':
                return $$ChatMessageUrl.validate(input);
            default:
                return false;
        }
    },
    fromJson(input): ChatMessage {
        switch (input.messageType) {
            case 'TEXT':
                return $$ChatMessageText.fromJson(input);
            case 'IMAGE':
                return $$ChatMessageImage.fromJson(input);
            case 'URL':
                return $$ChatMessageUrl.fromJson(input);
            default:
                return $$ChatMessageText.new();
        }
    },
    fromJsonString(input): ChatMessage {
        return $$ChatMessage.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        switch (input.messageType) {
            case 'TEXT':
                return $$ChatMessageText.toJsonString(input);
            case 'IMAGE':
                return $$ChatMessageImage.toJsonString(input);
            case 'URL':
                return $$ChatMessageUrl.toJsonString(input);
            default:
                throw new Error(
                    `Unhandled case "${(input as any).messageType}"`,
                );
        }
    },
    toUrlQueryString(input): string {
        switch (input.messageType) {
            case 'TEXT':
                return $$ChatMessageText.toUrlQueryString(input);
            case 'IMAGE':
                return $$ChatMessageImage.toUrlQueryString(input);
            case 'URL':
                return $$ChatMessageUrl.toUrlQueryString(input);
            default:
                throw new Error('Unhandled case');
        }
    },
};
export interface ChatMessageText {
    messageType: 'TEXT';
    id: string;
    channelId: string;
    userId: string;
    date: Date;
    text: string;
}
const $$ChatMessageText: ArriModelValidator<ChatMessageText> = {
    new(): ChatMessageText {
        return {
            messageType: 'TEXT',
            id: '',
            channelId: '',
            userId: '',
            date: new Date(),
            text: '',
        };
    },
    validate(input): input is ChatMessageText {
        return (
            isObject(input) &&
            input.messageType === 'TEXT' &&
            typeof input.id === 'string' &&
            typeof input.channelId === 'string' &&
            typeof input.userId === 'string' &&
            input.date instanceof Date &&
            typeof input.text === 'string'
        );
    },
    fromJson(input): ChatMessageText {
        const _messageType = 'TEXT';
        let _id: string;
        if (typeof input.id === 'string') {
            _id = input.id;
        } else {
            _id = '';
        }
        let _channelId: string;
        if (typeof input.channelId === 'string') {
            _channelId = input.channelId;
        } else {
            _channelId = '';
        }
        let _userId: string;
        if (typeof input.userId === 'string') {
            _userId = input.userId;
        } else {
            _userId = '';
        }
        let _date: Date;
        if (typeof input.date === 'string') {
            _date = new Date(input.date);
        } else if (input.date instanceof Date) {
            _date = input.date;
        } else {
            _date = new Date();
        }
        let _text: string;
        if (typeof input.text === 'string') {
            _text = input.text;
        } else {
            _text = '';
        }
        return {
            messageType: _messageType,
            id: _id,
            channelId: _channelId,
            userId: _userId,
            date: _date,
            text: _text,
        };
    },
    fromJsonString(input): ChatMessageText {
        return $$ChatMessageText.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"messageType":"TEXT"';
        json += ',"id":';
        json += serializeString(input.id);
        json += ',"channelId":';
        json += serializeString(input.channelId);
        json += ',"userId":';
        json += serializeString(input.userId);
        json += ',"date":';
        json += `"${input.date.toISOString()}"`;
        json += ',"text":';
        json += serializeString(input.text);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push('messageType=TEXT');
        queryParts.push(`id=${input.id}`);
        queryParts.push(`channelId=${input.channelId}`);
        queryParts.push(`userId=${input.userId}`);
        queryParts.push(`date=${input.date.toISOString()}`);
        queryParts.push(`text=${input.text}`);
        return queryParts.join('&');
    },
};

export interface ChatMessageImage {
    messageType: 'IMAGE';
    id: string;
    channelId: string;
    userId: string;
    date: Date;
    image: string;
}
const $$ChatMessageImage: ArriModelValidator<ChatMessageImage> = {
    new(): ChatMessageImage {
        return {
            messageType: 'IMAGE',
            id: '',
            channelId: '',
            userId: '',
            date: new Date(),
            image: '',
        };
    },
    validate(input): input is ChatMessageImage {
        return (
            isObject(input) &&
            input.messageType === 'IMAGE' &&
            typeof input.id === 'string' &&
            typeof input.channelId === 'string' &&
            typeof input.userId === 'string' &&
            input.date instanceof Date &&
            typeof input.image === 'string'
        );
    },
    fromJson(input): ChatMessageImage {
        const _messageType = 'IMAGE';
        let _id: string;
        if (typeof input.id === 'string') {
            _id = input.id;
        } else {
            _id = '';
        }
        let _channelId: string;
        if (typeof input.channelId === 'string') {
            _channelId = input.channelId;
        } else {
            _channelId = '';
        }
        let _userId: string;
        if (typeof input.userId === 'string') {
            _userId = input.userId;
        } else {
            _userId = '';
        }
        let _date: Date;
        if (typeof input.date === 'string') {
            _date = new Date(input.date);
        } else if (input.date instanceof Date) {
            _date = input.date;
        } else {
            _date = new Date();
        }
        let _image: string;
        if (typeof input.image === 'string') {
            _image = input.image;
        } else {
            _image = '';
        }
        return {
            messageType: _messageType,
            id: _id,
            channelId: _channelId,
            userId: _userId,
            date: _date,
            image: _image,
        };
    },
    fromJsonString(input): ChatMessageImage {
        return $$ChatMessageImage.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"messageType":"IMAGE"';
        json += ',"id":';
        json += serializeString(input.id);
        json += ',"channelId":';
        json += serializeString(input.channelId);
        json += ',"userId":';
        json += serializeString(input.userId);
        json += ',"date":';
        json += `"${input.date.toISOString()}"`;
        json += ',"image":';
        json += serializeString(input.image);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push('messageType=IMAGE');
        queryParts.push(`id=${input.id}`);
        queryParts.push(`channelId=${input.channelId}`);
        queryParts.push(`userId=${input.userId}`);
        queryParts.push(`date=${input.date.toISOString()}`);
        queryParts.push(`image=${input.image}`);
        return queryParts.join('&');
    },
};

export interface ChatMessageUrl {
    messageType: 'URL';
    id: string;
    channelId: string;
    userId: string;
    date: Date;
    url: string;
}
const $$ChatMessageUrl: ArriModelValidator<ChatMessageUrl> = {
    new(): ChatMessageUrl {
        return {
            messageType: 'URL',
            id: '',
            channelId: '',
            userId: '',
            date: new Date(),
            url: '',
        };
    },
    validate(input): input is ChatMessageUrl {
        return (
            isObject(input) &&
            input.messageType === 'URL' &&
            typeof input.id === 'string' &&
            typeof input.channelId === 'string' &&
            typeof input.userId === 'string' &&
            input.date instanceof Date &&
            typeof input.url === 'string'
        );
    },
    fromJson(input): ChatMessageUrl {
        const _messageType = 'URL';
        let _id: string;
        if (typeof input.id === 'string') {
            _id = input.id;
        } else {
            _id = '';
        }
        let _channelId: string;
        if (typeof input.channelId === 'string') {
            _channelId = input.channelId;
        } else {
            _channelId = '';
        }
        let _userId: string;
        if (typeof input.userId === 'string') {
            _userId = input.userId;
        } else {
            _userId = '';
        }
        let _date: Date;
        if (typeof input.date === 'string') {
            _date = new Date(input.date);
        } else if (input.date instanceof Date) {
            _date = input.date;
        } else {
            _date = new Date();
        }
        let _url: string;
        if (typeof input.url === 'string') {
            _url = input.url;
        } else {
            _url = '';
        }
        return {
            messageType: _messageType,
            id: _id,
            channelId: _channelId,
            userId: _userId,
            date: _date,
            url: _url,
        };
    },
    fromJsonString(input): ChatMessageUrl {
        return $$ChatMessageUrl.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"messageType":"URL"';
        json += ',"id":';
        json += serializeString(input.id);
        json += ',"channelId":';
        json += serializeString(input.channelId);
        json += ',"userId":';
        json += serializeString(input.userId);
        json += ',"date":';
        json += `"${input.date.toISOString()}"`;
        json += ',"url":';
        json += serializeString(input.url);
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push('messageType=URL');
        queryParts.push(`id=${input.id}`);
        queryParts.push(`channelId=${input.channelId}`);
        queryParts.push(`userId=${input.userId}`);
        queryParts.push(`date=${input.date.toISOString()}`);
        queryParts.push(`url=${input.url}`);
        return queryParts.join('&');
    },
};

export interface TestsStreamRetryWithNewCredentialsResponse {
    message: string;
}
export const $$TestsStreamRetryWithNewCredentialsResponse: ArriModelValidator<TestsStreamRetryWithNewCredentialsResponse> =
    {
        new(): TestsStreamRetryWithNewCredentialsResponse {
            return {
                message: '',
            };
        },
        validate(input): input is TestsStreamRetryWithNewCredentialsResponse {
            return isObject(input) && typeof input.message === 'string';
        },
        fromJson(input): TestsStreamRetryWithNewCredentialsResponse {
            let _message: string;
            if (typeof input.message === 'string') {
                _message = input.message;
            } else {
                _message = '';
            }
            return {
                message: _message,
            };
        },
        fromJsonString(input): TestsStreamRetryWithNewCredentialsResponse {
            return $$TestsStreamRetryWithNewCredentialsResponse.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"message":';
            json += serializeString(input.message);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`message=${input.message}`);
            return queryParts.join('&');
        },
    };

export interface UsersWatchUserParams {
    userId: string;
}
export const $$UsersWatchUserParams: ArriModelValidator<UsersWatchUserParams> =
    {
        new(): UsersWatchUserParams {
            return {
                userId: '',
            };
        },
        validate(input): input is UsersWatchUserParams {
            return isObject(input) && typeof input.userId === 'string';
        },
        fromJson(input): UsersWatchUserParams {
            let _userId: string;
            if (typeof input.userId === 'string') {
                _userId = input.userId;
            } else {
                _userId = '';
            }
            return {
                userId: _userId,
            };
        },
        fromJsonString(input): UsersWatchUserParams {
            return $$UsersWatchUserParams.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"userId":';
            json += serializeString(input.userId);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`userId=${input.userId}`);
            return queryParts.join('&');
        },
    };

export interface UsersWatchUserResponse {
    id: string;
    role: UsersWatchUserResponseRole;
    /**
     * A profile picture
     */
    photo: UserPhoto | null;
    createdAt: Date;
    numFollowers: number;
    settings: UserSettings;
    recentNotifications: UsersWatchUserResponseRecentNotificationsElement[];
    bookmarks: Record<string, UsersWatchUserResponseBookmarksValue>;
    metadata: Record<string, any>;
    randomList: any[];
    bio?: string;
}
export const $$UsersWatchUserResponse: ArriModelValidator<UsersWatchUserResponse> =
    {
        new(): UsersWatchUserResponse {
            return {
                id: '',
                role: $$UsersWatchUserResponseRole.new(),
                photo: null,
                createdAt: new Date(),
                numFollowers: 0,
                settings: $$UserSettings.new(),
                recentNotifications: [],
                bookmarks: {},
                metadata: {},
                randomList: [],
            };
        },
        validate(input): input is UsersWatchUserResponse {
            return (
                isObject(input) &&
                typeof input.id === 'string' &&
                $$UsersWatchUserResponseRole.validate(input.role) &&
                ($$UserPhoto.validate(input.photo) || input.photo === null) &&
                input.createdAt instanceof Date &&
                typeof input.numFollowers === 'number' &&
                Number.isInteger(input.numFollowers) &&
                input.numFollowers >= INT32_MIN &&
                input.numFollowers <= INT32_MAX &&
                $$UserSettings.validate(input.settings) &&
                Array.isArray(input.recentNotifications) &&
                input.recentNotifications.every((_element) =>
                    $$UsersWatchUserResponseRecentNotificationsElement.validate(
                        _element,
                    ),
                ) &&
                isObject(input.bookmarks) &&
                Object.values(input.bookmarks).every((_value) =>
                    $$UsersWatchUserResponseBookmarksValue.validate(_value),
                ) &&
                isObject(input.metadata) &&
                Object.values(input.metadata).every((_value) => true) &&
                Array.isArray(input.randomList) &&
                input.randomList.every((_element) => true) &&
                (typeof input.bio === 'string' ||
                    typeof input.bio === 'undefined')
            );
        },
        fromJson(input): UsersWatchUserResponse {
            let _id: string;
            if (typeof input.id === 'string') {
                _id = input.id;
            } else {
                _id = '';
            }
            let _role: UsersWatchUserResponseRole;
            if (typeof input.role === 'string') {
                _role = $$UsersWatchUserResponseRole.fromSerialValue(
                    input.role,
                );
            } else {
                _role = $$UsersWatchUserResponseRole.new();
            }
            let _photo: UserPhoto | null;
            if (isObject(input.photo)) {
                _photo = $$UserPhoto.fromJson(input.photo);
            } else {
                _photo = null;
            }
            let _createdAt: Date;
            if (typeof input.createdAt === 'string') {
                _createdAt = new Date(input.createdAt);
            } else if (input.createdAt instanceof Date) {
                _createdAt = input.createdAt;
            } else {
                _createdAt = new Date();
            }
            let _numFollowers: number;
            if (
                typeof input.numFollowers === 'number' &&
                Number.isInteger(input.numFollowers) &&
                input.numFollowers >= INT32_MIN &&
                input.numFollowers <= INT32_MAX
            ) {
                _numFollowers = input.numFollowers;
            } else {
                _numFollowers = 0;
            }
            let _settings: UserSettings;
            if (isObject(input.settings)) {
                _settings = $$UserSettings.fromJson(input.settings);
            } else {
                _settings = $$UserSettings.new();
            }
            let _recentNotifications: UsersWatchUserResponseRecentNotificationsElement[];
            if (Array.isArray(input.recentNotifications)) {
                _recentNotifications = [];
                for (const _recentNotificationsEl of input.recentNotifications) {
                    let _recentNotificationsElValue: UsersWatchUserResponseRecentNotificationsElement;
                    if (isObject(_recentNotificationsEl)) {
                        _recentNotificationsElValue =
                            $$UsersWatchUserResponseRecentNotificationsElement.fromJson(
                                _recentNotificationsEl,
                            );
                    } else {
                        _recentNotificationsElValue =
                            $$UsersWatchUserResponseRecentNotificationsElement.new();
                    }
                    _recentNotifications.push(_recentNotificationsElValue);
                }
            } else {
                _recentNotifications = [];
            }
            let _bookmarks: Record<
                string,
                UsersWatchUserResponseBookmarksValue
            >;
            if (isObject(input.bookmarks)) {
                _bookmarks = {};
                for (const [_key, _value] of Object.entries(input.bookmarks)) {
                    let _bookmarksValue: UsersWatchUserResponseBookmarksValue;
                    if (isObject(_value)) {
                        _bookmarksValue =
                            $$UsersWatchUserResponseBookmarksValue.fromJson(
                                _value,
                            );
                    } else {
                        _bookmarksValue =
                            $$UsersWatchUserResponseBookmarksValue.new();
                    }
                    _bookmarks[_key] = _bookmarksValue;
                }
            } else {
                _bookmarks = {};
            }
            let _metadata: Record<string, any>;
            if (isObject(input.metadata)) {
                _metadata = {};
                for (const [_key, _value] of Object.entries(input.metadata)) {
                    let _metadataValue: any;
                    _metadataValue = _value;
                    _metadata[_key] = _metadataValue;
                }
            } else {
                _metadata = {};
            }
            let _randomList: any[];
            if (Array.isArray(input.randomList)) {
                _randomList = [];
                for (const _randomListEl of input.randomList) {
                    let _randomListElValue: any;
                    _randomListElValue = _randomListEl;
                    _randomList.push(_randomListElValue);
                }
            } else {
                _randomList = [];
            }
            let _bio: string | undefined;
            if (typeof input.bio !== 'undefined') {
                if (typeof input.bio === 'string') {
                    _bio = input.bio;
                } else {
                    _bio = '';
                }
            }
            return {
                id: _id,
                role: _role,
                photo: _photo,
                createdAt: _createdAt,
                numFollowers: _numFollowers,
                settings: _settings,
                recentNotifications: _recentNotifications,
                bookmarks: _bookmarks,
                metadata: _metadata,
                randomList: _randomList,
                bio: _bio,
            };
        },
        fromJsonString(input): UsersWatchUserResponse {
            return $$UsersWatchUserResponse.fromJson(JSON.parse(input));
        },
        toJsonString(input): string {
            let json = '{';
            json += '"id":';
            json += serializeString(input.id);
            json += ',"role":';
            json += `"${input.role}"`;
            json += ',"photo":';
            if (input.photo !== null) {
                json += $$UserPhoto.toJsonString(input.photo);
            } else {
                json += 'null';
            }
            json += ',"createdAt":';
            json += `"${input.createdAt.toISOString()}"`;
            json += ',"numFollowers":';
            json += `${input.numFollowers}`;
            json += ',"settings":';
            json += $$UserSettings.toJsonString(input.settings);
            json += ',"recentNotifications":';
            json += '[';
            for (let i = 0; i < input.recentNotifications.length; i++) {
                if (i !== 0) json += ',';
                const _inputRecentNotificationsEl =
                    input.recentNotifications[i];
                json +=
                    $$UsersWatchUserResponseRecentNotificationsElement.toJsonString(
                        _inputRecentNotificationsEl,
                    );
            }
            json += ']';
            json += ',"bookmarks":';
            json += '{';
            let _bookmarksPropertyCount = 0;
            for (const [_key, _value] of Object.entries(input.bookmarks)) {
                if (_bookmarksPropertyCount !== 0) {
                    json += ',';
                }
                json += `${serializeString(_key)}:`;
                json +=
                    $$UsersWatchUserResponseBookmarksValue.toJsonString(_value);
                _bookmarksPropertyCount++;
            }
            json += '}';

            json += ',"metadata":';
            json += '{';
            let _metadataPropertyCount = 0;
            for (const [_key, _value] of Object.entries(input.metadata)) {
                if (_metadataPropertyCount !== 0) {
                    json += ',';
                }
                json += `${serializeString(_key)}:`;
                json += JSON.stringify(_value);
                _metadataPropertyCount++;
            }
            json += '}';

            json += ',"randomList":';
            json += '[';
            for (let i = 0; i < input.randomList.length; i++) {
                if (i !== 0) json += ',';
                const _inputRandomListEl = input.randomList[i];
                json += JSON.stringify(_inputRandomListEl);
            }
            json += ']';
            if (typeof input.bio !== 'undefined') {
                json += `,"bio":`;
                json += serializeString(input.bio);
            }
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`id=${input.id}`);
            queryParts.push(`role=${input.role}`);
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /UsersWatchUserResponse/photo.',
            );
            queryParts.push(`createdAt=${input.createdAt.toISOString()}`);
            queryParts.push(`numFollowers=${input.numFollowers}`);
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /UsersWatchUserResponse/settings.',
            );
            console.warn(
                '[WARNING] Cannot serialize arrays to query string. Skipping property at /UsersWatchUserResponse/recentNotifications.',
            );
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /UsersWatchUserResponse/bookmarks.',
            );
            console.warn(
                '[WARNING] Cannot serialize nested objects to query string. Skipping property at /UsersWatchUserResponse/metadata.',
            );
            console.warn(
                '[WARNING] Cannot serialize arrays to query string. Skipping property at /UsersWatchUserResponse/randomList.',
            );
            if (typeof input.bio !== 'undefined') {
                queryParts.push(`bio=${input.bio}`);
            }
            return queryParts.join('&');
        },
    };

export type UsersWatchUserResponseRole =
    (typeof $$UsersWatchUserResponseRoleValues)[number];
const $$UsersWatchUserResponseRoleValues = ['standard', 'admin'] as const;
export const $$UsersWatchUserResponseRole: ArriEnumValidator<UsersWatchUserResponseRole> =
    {
        new(): UsersWatchUserResponseRole {
            return $$UsersWatchUserResponseRoleValues[0];
        },
        validate(input): input is UsersWatchUserResponseRole {
            return (
                typeof input === 'string' &&
                $$UsersWatchUserResponseRoleValues.includes(input as any)
            );
        },
        values: $$UsersWatchUserResponseRoleValues,
        fromSerialValue(input): UsersWatchUserResponseRole {
            if ($$UsersWatchUserResponseRoleValues.includes(input as any)) {
                return input as UsersWatchUserResponseRole;
            }
            if (
                $$UsersWatchUserResponseRoleValues.includes(
                    input.toLowerCase() as any,
                )
            ) {
                return input.toLowerCase() as UsersWatchUserResponseRole;
            }
            if (
                $$UsersWatchUserResponseRoleValues.includes(
                    input.toUpperCase() as any,
                )
            ) {
                return input.toUpperCase() as UsersWatchUserResponseRole;
            }
            return 'standard';
        },
    };

/**
 * A profile picture
 */
export interface UserPhoto {
    url: string;
    width: number;
    height: number;
    bytes: bigint;
    /**
     * When the photo was last updated in nanoseconds
     */
    nanoseconds: bigint;
}
export const $$UserPhoto: ArriModelValidator<UserPhoto> = {
    new(): UserPhoto {
        return {
            url: '',
            width: 0,
            height: 0,
            bytes: BigInt(0),
            nanoseconds: BigInt(0),
        };
    },
    validate(input): input is UserPhoto {
        return (
            isObject(input) &&
            typeof input.url === 'string' &&
            typeof input.width === 'number' &&
            typeof input.height === 'number' &&
            typeof input.bytes === 'bigint' &&
            input.bytes >= INT64_MIN &&
            input.bytes <= INT64_MAX &&
            typeof input.nanoseconds === 'bigint' &&
            input.nanoseconds >= BigInt(0) &&
            input.nanoseconds <= UINT64_MAX
        );
    },
    fromJson(input): UserPhoto {
        let _url: string;
        if (typeof input.url === 'string') {
            _url = input.url;
        } else {
            _url = '';
        }
        let _width: number;
        if (typeof input.width === 'number') {
            _width = input.width;
        } else {
            _width = 0;
        }
        let _height: number;
        if (typeof input.height === 'number') {
            _height = input.height;
        } else {
            _height = 0;
        }
        let _bytes: bigint;
        if (typeof input.bytes === 'string') {
            _bytes = BigInt(input.bytes);
        } else if (typeof input.bytes === 'bigint') {
            _bytes = input.bytes;
        } else {
            _bytes = BigInt(0);
        }
        let _nanoseconds: bigint;
        if (
            typeof input.nanoseconds === 'string' &&
            BigInt(input.nanoseconds) >= BigInt(0)
        ) {
            _nanoseconds = BigInt(input.nanoseconds);
        } else if (
            typeof input.nanoseconds === 'bigint' &&
            input.nanoseconds >= BigInt(0)
        ) {
            _nanoseconds = input.nanoseconds;
        } else {
            _nanoseconds = BigInt(0);
        }
        return {
            url: _url,
            width: _width,
            height: _height,
            bytes: _bytes,
            nanoseconds: _nanoseconds,
        };
    },
    fromJsonString(input): UserPhoto {
        return $$UserPhoto.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"url":';
        json += serializeString(input.url);
        json += ',"width":';
        json += `${input.width}`;
        json += ',"height":';
        json += `${input.height}`;
        json += ',"bytes":';
        json += `"${input.bytes}"`;
        json += ',"nanoseconds":';
        json += `"${input.nanoseconds}"`;
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`url=${input.url}`);
        queryParts.push(`width=${input.width}`);
        queryParts.push(`height=${input.height}`);
        queryParts.push(`bytes=${input.bytes}`);
        queryParts.push(`nanoseconds=${input.nanoseconds}`);
        return queryParts.join('&');
    },
};

export interface UserSettings {
    notificationsEnabled: boolean;
    preferredTheme: UserSettingsPreferredTheme;
}
export const $$UserSettings: ArriModelValidator<UserSettings> = {
    new(): UserSettings {
        return {
            notificationsEnabled: false,
            preferredTheme: $$UserSettingsPreferredTheme.new(),
        };
    },
    validate(input): input is UserSettings {
        return (
            isObject(input) &&
            typeof input.notificationsEnabled === 'boolean' &&
            $$UserSettingsPreferredTheme.validate(input.preferredTheme)
        );
    },
    fromJson(input): UserSettings {
        let _notificationsEnabled: boolean;
        if (typeof input.notificationsEnabled === 'boolean') {
            _notificationsEnabled = input.notificationsEnabled;
        } else {
            _notificationsEnabled = false;
        }
        let _preferredTheme: UserSettingsPreferredTheme;
        if (typeof input.preferredTheme === 'string') {
            _preferredTheme = $$UserSettingsPreferredTheme.fromSerialValue(
                input.preferredTheme,
            );
        } else {
            _preferredTheme = $$UserSettingsPreferredTheme.new();
        }
        return {
            notificationsEnabled: _notificationsEnabled,
            preferredTheme: _preferredTheme,
        };
    },
    fromJsonString(input): UserSettings {
        return $$UserSettings.fromJson(JSON.parse(input));
    },
    toJsonString(input): string {
        let json = '{';
        json += '"notificationsEnabled":';
        json += `${input.notificationsEnabled}`;
        json += ',"preferredTheme":';
        json += `"${input.preferredTheme}"`;
        json += '}';
        return json;
    },
    toUrlQueryString(input): string {
        const queryParts: string[] = [];
        queryParts.push(`notificationsEnabled=${input.notificationsEnabled}`);
        queryParts.push(`preferredTheme=${input.preferredTheme}`);
        return queryParts.join('&');
    },
};

export type UserSettingsPreferredTheme =
    (typeof $$UserSettingsPreferredThemeValues)[number];
const $$UserSettingsPreferredThemeValues = [
    'dark-mode',
    'light-mode',
    'system',
] as const;
export const $$UserSettingsPreferredTheme: ArriEnumValidator<UserSettingsPreferredTheme> =
    {
        new(): UserSettingsPreferredTheme {
            return $$UserSettingsPreferredThemeValues[0];
        },
        validate(input): input is UserSettingsPreferredTheme {
            return (
                typeof input === 'string' &&
                $$UserSettingsPreferredThemeValues.includes(input as any)
            );
        },
        values: $$UserSettingsPreferredThemeValues,
        fromSerialValue(input): UserSettingsPreferredTheme {
            if ($$UserSettingsPreferredThemeValues.includes(input as any)) {
                return input as UserSettingsPreferredTheme;
            }
            if (
                $$UserSettingsPreferredThemeValues.includes(
                    input.toLowerCase() as any,
                )
            ) {
                return input.toLowerCase() as UserSettingsPreferredTheme;
            }
            if (
                $$UserSettingsPreferredThemeValues.includes(
                    input.toUpperCase() as any,
                )
            ) {
                return input.toUpperCase() as UserSettingsPreferredTheme;
            }
            return 'dark-mode';
        },
    };

export type UsersWatchUserResponseRecentNotificationsElement =
    | UsersWatchUserResponseRecentNotificationsElementPostLike
    | UsersWatchUserResponseRecentNotificationsElementPostComment;
export const $$UsersWatchUserResponseRecentNotificationsElement: ArriModelValidator<UsersWatchUserResponseRecentNotificationsElement> =
    {
        new(): UsersWatchUserResponseRecentNotificationsElement {
            return $$UsersWatchUserResponseRecentNotificationsElementPostLike.new();
        },
        validate(
            input,
        ): input is UsersWatchUserResponseRecentNotificationsElement {
            if (!isObject(input)) {
                return false;
            }
            if (typeof input.notificationType !== 'string') {
                return false;
            }
            switch (input.notificationType) {
                case 'POST_LIKE':
                    return $$UsersWatchUserResponseRecentNotificationsElementPostLike.validate(
                        input,
                    );
                case 'POST_COMMENT':
                    return $$UsersWatchUserResponseRecentNotificationsElementPostComment.validate(
                        input,
                    );
                default:
                    return false;
            }
        },
        fromJson(input): UsersWatchUserResponseRecentNotificationsElement {
            switch (input.notificationType) {
                case 'POST_LIKE':
                    return $$UsersWatchUserResponseRecentNotificationsElementPostLike.fromJson(
                        input,
                    );
                case 'POST_COMMENT':
                    return $$UsersWatchUserResponseRecentNotificationsElementPostComment.fromJson(
                        input,
                    );
                default:
                    return $$UsersWatchUserResponseRecentNotificationsElementPostLike.new();
            }
        },
        fromJsonString(
            input,
        ): UsersWatchUserResponseRecentNotificationsElement {
            return $$UsersWatchUserResponseRecentNotificationsElement.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            switch (input.notificationType) {
                case 'POST_LIKE':
                    return $$UsersWatchUserResponseRecentNotificationsElementPostLike.toJsonString(
                        input,
                    );
                case 'POST_COMMENT':
                    return $$UsersWatchUserResponseRecentNotificationsElementPostComment.toJsonString(
                        input,
                    );
                default:
                    throw new Error(
                        `Unhandled case "${(input as any).notificationType}"`,
                    );
            }
        },
        toUrlQueryString(input): string {
            switch (input.notificationType) {
                case 'POST_LIKE':
                    return $$UsersWatchUserResponseRecentNotificationsElementPostLike.toUrlQueryString(
                        input,
                    );
                case 'POST_COMMENT':
                    return $$UsersWatchUserResponseRecentNotificationsElementPostComment.toUrlQueryString(
                        input,
                    );
                default:
                    throw new Error('Unhandled case');
            }
        },
    };
export interface UsersWatchUserResponseRecentNotificationsElementPostLike {
    notificationType: 'POST_LIKE';
    postId: string;
    userId: string;
}
const $$UsersWatchUserResponseRecentNotificationsElementPostLike: ArriModelValidator<UsersWatchUserResponseRecentNotificationsElementPostLike> =
    {
        new(): UsersWatchUserResponseRecentNotificationsElementPostLike {
            return {
                notificationType: 'POST_LIKE',
                postId: '',
                userId: '',
            };
        },
        validate(
            input,
        ): input is UsersWatchUserResponseRecentNotificationsElementPostLike {
            return (
                isObject(input) &&
                input.notificationType === 'POST_LIKE' &&
                typeof input.postId === 'string' &&
                typeof input.userId === 'string'
            );
        },
        fromJson(
            input,
        ): UsersWatchUserResponseRecentNotificationsElementPostLike {
            const _notificationType = 'POST_LIKE';
            let _postId: string;
            if (typeof input.postId === 'string') {
                _postId = input.postId;
            } else {
                _postId = '';
            }
            let _userId: string;
            if (typeof input.userId === 'string') {
                _userId = input.userId;
            } else {
                _userId = '';
            }
            return {
                notificationType: _notificationType,
                postId: _postId,
                userId: _userId,
            };
        },
        fromJsonString(
            input,
        ): UsersWatchUserResponseRecentNotificationsElementPostLike {
            return $$UsersWatchUserResponseRecentNotificationsElementPostLike.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"notificationType":"POST_LIKE"';
            json += ',"postId":';
            json += serializeString(input.postId);
            json += ',"userId":';
            json += serializeString(input.userId);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('notificationType=POST_LIKE');
            queryParts.push(`postId=${input.postId}`);
            queryParts.push(`userId=${input.userId}`);
            return queryParts.join('&');
        },
    };

export interface UsersWatchUserResponseRecentNotificationsElementPostComment {
    notificationType: 'POST_COMMENT';
    postId: string;
    userId: string;
    commentText: string;
}
const $$UsersWatchUserResponseRecentNotificationsElementPostComment: ArriModelValidator<UsersWatchUserResponseRecentNotificationsElementPostComment> =
    {
        new(): UsersWatchUserResponseRecentNotificationsElementPostComment {
            return {
                notificationType: 'POST_COMMENT',
                postId: '',
                userId: '',
                commentText: '',
            };
        },
        validate(
            input,
        ): input is UsersWatchUserResponseRecentNotificationsElementPostComment {
            return (
                isObject(input) &&
                input.notificationType === 'POST_COMMENT' &&
                typeof input.postId === 'string' &&
                typeof input.userId === 'string' &&
                typeof input.commentText === 'string'
            );
        },
        fromJson(
            input,
        ): UsersWatchUserResponseRecentNotificationsElementPostComment {
            const _notificationType = 'POST_COMMENT';
            let _postId: string;
            if (typeof input.postId === 'string') {
                _postId = input.postId;
            } else {
                _postId = '';
            }
            let _userId: string;
            if (typeof input.userId === 'string') {
                _userId = input.userId;
            } else {
                _userId = '';
            }
            let _commentText: string;
            if (typeof input.commentText === 'string') {
                _commentText = input.commentText;
            } else {
                _commentText = '';
            }
            return {
                notificationType: _notificationType,
                postId: _postId,
                userId: _userId,
                commentText: _commentText,
            };
        },
        fromJsonString(
            input,
        ): UsersWatchUserResponseRecentNotificationsElementPostComment {
            return $$UsersWatchUserResponseRecentNotificationsElementPostComment.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"notificationType":"POST_COMMENT"';
            json += ',"postId":';
            json += serializeString(input.postId);
            json += ',"userId":';
            json += serializeString(input.userId);
            json += ',"commentText":';
            json += serializeString(input.commentText);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push('notificationType=POST_COMMENT');
            queryParts.push(`postId=${input.postId}`);
            queryParts.push(`userId=${input.userId}`);
            queryParts.push(`commentText=${input.commentText}`);
            return queryParts.join('&');
        },
    };

export interface UsersWatchUserResponseBookmarksValue {
    postId: string;
    userId: string;
}
export const $$UsersWatchUserResponseBookmarksValue: ArriModelValidator<UsersWatchUserResponseBookmarksValue> =
    {
        new(): UsersWatchUserResponseBookmarksValue {
            return {
                postId: '',
                userId: '',
            };
        },
        validate(input): input is UsersWatchUserResponseBookmarksValue {
            return (
                isObject(input) &&
                typeof input.postId === 'string' &&
                typeof input.userId === 'string'
            );
        },
        fromJson(input): UsersWatchUserResponseBookmarksValue {
            let _postId: string;
            if (typeof input.postId === 'string') {
                _postId = input.postId;
            } else {
                _postId = '';
            }
            let _userId: string;
            if (typeof input.userId === 'string') {
                _userId = input.userId;
            } else {
                _userId = '';
            }
            return {
                postId: _postId,
                userId: _userId,
            };
        },
        fromJsonString(input): UsersWatchUserResponseBookmarksValue {
            return $$UsersWatchUserResponseBookmarksValue.fromJson(
                JSON.parse(input),
            );
        },
        toJsonString(input): string {
            let json = '{';
            json += '"postId":';
            json += serializeString(input.postId);
            json += ',"userId":';
            json += serializeString(input.userId);
            json += '}';
            return json;
        },
        toUrlQueryString(input): string {
            const queryParts: string[] = [];
            queryParts.push(`postId=${input.postId}`);
            queryParts.push(`userId=${input.userId}`);
            return queryParts.join('&');
        },
    };
