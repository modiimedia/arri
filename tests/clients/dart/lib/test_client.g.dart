// this file was autogenerated by arri
// ignore_for_file: type=lint, unused_field, unnecessary_cast
import 'dart:async';
import 'dart:convert';
import 'package:arri_client/arri_client.dart';
import 'package:http/http.dart' as http;

class TestClient {
  final String _baseUrl;
  final String _wsConnectionUrl;

  final http.Client Function()? _createHttpClient;
  final String? _clientVersion = "10";
  final FutureOr<Map<String, String>> Function()? _headers;
  final OnErrorHook? _onError;
  final int? _retry;
  final Duration? _retryDelay;
  final double? _heartbeatTimeoutMultiplier;
  final Duration? _timeout;
  final String _defaultTransport;
  late final Map<String, Dispatcher> _dispatchers;

  TestClient({
    required String baseUrl,
    required String wsConnectionUrl,
    http.Client Function()? createHttpClient,
    FutureOr<Map<String, String>> Function()? headers,
    OnErrorHook? onError,
    int? retry,
    Duration? retryDelay,
    double? heartbeatTimeoutMultiplier,
    Duration? timeout,
    String? defaultTransport,
    Map<String, Dispatcher>? dispatchers,
  })  : _baseUrl = baseUrl,
        _wsConnectionUrl = wsConnectionUrl,
        _createHttpClient = createHttpClient,
        _headers = headers,
        _onError = onError,
        _retry = retry,
        _retryDelay = retryDelay,
        _heartbeatTimeoutMultiplier = heartbeatTimeoutMultiplier,
        _timeout = timeout,
        _defaultTransport = defaultTransport ?? "http" {
    _dispatchers = dispatchers ?? {};
    if (_dispatchers["http"] == null) {
      _dispatchers["http"] = HttpDispatcher(
        baseUrl: baseUrl,
        createHttpClient: _createHttpClient,
      );
    }
    if (_dispatchers["ws"] == null) {
      _dispatchers["ws"] = WsDispatcher(
        connectionUrl: _wsConnectionUrl,
        heartbeatTimeoutMultiplier: _heartbeatTimeoutMultiplier,
      );
    }
  }

  TestClientTestsService get tests => TestClientTestsService(
        baseUrl: _baseUrl,
        wsConnectionUrl: _wsConnectionUrl,
        headers: _headers,
        createHttpClient: _createHttpClient,
        onError: _onError,
        heartbeatTimeoutMultiplier: _heartbeatTimeoutMultiplier,
        timeout: _timeout,
        dispatchers: _dispatchers,
      );
}

class TestClientTestsService {
  final String _baseUrl;
  final String _wsConnectionUrl;

  final http.Client Function()? _createHttpClient;
  final String? _clientVersion = "10";
  final FutureOr<Map<String, String>> Function()? _headers;
  final OnErrorHook? _onError;
  final int? _retry;
  final Duration? _retryDelay;
  final double? _heartbeatTimeoutMultiplier;
  final Duration? _timeout;
  final String _defaultTransport;
  late final Map<String, Dispatcher> _dispatchers;

  TestClientTestsService({
    required String baseUrl,
    required String wsConnectionUrl,
    http.Client Function()? createHttpClient,
    FutureOr<Map<String, String>> Function()? headers,
    OnErrorHook? onError,
    int? retry,
    Duration? retryDelay,
    double? heartbeatTimeoutMultiplier,
    Duration? timeout,
    String? defaultTransport,
    Map<String, Dispatcher>? dispatchers,
  })  : _baseUrl = baseUrl,
        _wsConnectionUrl = wsConnectionUrl,
        _createHttpClient = createHttpClient,
        _headers = headers,
        _onError = onError,
        _retry = retry,
        _retryDelay = retryDelay,
        _heartbeatTimeoutMultiplier = heartbeatTimeoutMultiplier,
        _timeout = timeout,
        _defaultTransport = defaultTransport ?? "http" {
    _dispatchers = dispatchers ?? {};
    if (_dispatchers["http"] == null) {
      _dispatchers["http"] = HttpDispatcher(
        baseUrl: baseUrl,
        createHttpClient: _createHttpClient,
      );
    }
  }

  Future<DefaultPayload> emptyParamsGetRequest({
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "tests.emptyParamsGetRequest",
        path: "/rpcs/tests/empty-params-get-request",
        reqId: getRequestId(),
        method: HttpMethod.get,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: null,
      ),
      responseDecoder: (input) => DefaultPayload.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<DefaultPayload> emptyParamsPostRequest({
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "tests.emptyParamsPostRequest",
        path: "/rpcs/tests/empty-params-post-request",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: null,
      ),
      responseDecoder: (input) => DefaultPayload.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<void> emptyResponseGetRequest(
    DefaultPayload params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "tests.emptyResponseGetRequest",
        path: "/rpcs/tests/empty-response-get-request",
        reqId: getRequestId(),
        method: HttpMethod.get,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (_) => {},
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<void> emptyResponsePostRequest(
    DefaultPayload params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "tests.emptyResponsePostRequest",
        path: "/rpcs/tests/empty-response-post-request",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (_) => {},
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  /// If the target language supports it. Generated code should mark this procedure as deprecated.
  @deprecated
  Future<void> deprecatedRpc(
    DeprecatedRpcParams params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "tests.deprecatedRpc",
        path: "/rpcs/tests/deprecated-rpc",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (_) => {},
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<DiscriminatorWithEmptyObject> sendDiscriminatorWithEmptyObject(
    DiscriminatorWithEmptyObject params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "tests.sendDiscriminatorWithEmptyObject",
        path: "/rpcs/tests/send-discriminator-with-empty-object",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (input) =>
          DiscriminatorWithEmptyObject.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<void> sendError(
    SendErrorParams params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "tests.sendError",
        path: "/rpcs/tests/send-error",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (_) => {},
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<ObjectWithEveryType> sendObject(
    ObjectWithEveryType params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "tests.sendObject",
        path: "/rpcs/tests/send-object",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (input) => ObjectWithEveryType.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<ObjectWithEveryNullableType> sendObjectWithNullableFields(
    ObjectWithEveryNullableType params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "tests.sendObjectWithNullableFields",
        path: "/rpcs/tests/send-object-with-nullable-fields",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (input) =>
          ObjectWithEveryNullableType.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<ObjectWithPascalCaseKeys> sendObjectWithPascalCaseKeys(
    ObjectWithPascalCaseKeys params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "tests.sendObjectWithPascalCaseKeys",
        path: "/rpcs/tests/send-object-with-pascal-case-keys",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (input) =>
          ObjectWithPascalCaseKeys.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<ObjectWithSnakeCaseKeys> sendObjectWithSnakeCaseKeys(
    ObjectWithSnakeCaseKeys params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "tests.sendObjectWithSnakeCaseKeys",
        path: "/rpcs/tests/send-object-with-snake-case-keys",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (input) => ObjectWithSnakeCaseKeys.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<ObjectWithEveryOptionalType> sendPartialObject(
    ObjectWithEveryOptionalType params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "tests.sendPartialObject",
        path: "/rpcs/tests/send-partial-object",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (input) =>
          ObjectWithEveryOptionalType.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<RecursiveObject> sendRecursiveObject(
    RecursiveObject params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "tests.sendRecursiveObject",
        path: "/rpcs/tests/send-recursive-object",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (input) => RecursiveObject.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<RecursiveUnion> sendRecursiveUnion(
    RecursiveUnion params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "tests.sendRecursiveUnion",
        path: "/rpcs/tests/send-recursive-union",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (input) => RecursiveUnion.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }
}

class ManuallyAddedModel implements ArriModel {
  /// FOO
  final String hello;
  const ManuallyAddedModel({
    required this.hello,
  });

  factory ManuallyAddedModel.empty() {
    return ManuallyAddedModel(
      hello: "",
    );
  }

  factory ManuallyAddedModel.fromJson(Map<String, dynamic> _input_) {
    final hello = typeFromDynamic<String>(_input_["hello"], "");
    return ManuallyAddedModel(
      hello: hello,
    );
  }

  factory ManuallyAddedModel.fromJsonString(String input) {
    return ManuallyAddedModel.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "hello": hello,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("hello=$hello");
    return _queryParts_.join("&");
  }

  ManuallyAddedModel copyWith({
    String? hello,
  }) {
    return ManuallyAddedModel(
      hello: hello ?? this.hello,
    );
  }

  @override
  List<Object?> get props => [
        hello,
      ];

  @override
  bool operator ==(Object other) {
    return other is ManuallyAddedModel && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ManuallyAddedModel ${toJsonString()}";
  }
}

class DefaultPayload implements ArriModel {
  final String message;
  const DefaultPayload({
    required this.message,
  });

  factory DefaultPayload.empty() {
    return DefaultPayload(
      message: "",
    );
  }

  factory DefaultPayload.fromJson(Map<String, dynamic> _input_) {
    final message = typeFromDynamic<String>(_input_["message"], "");
    return DefaultPayload(
      message: message,
    );
  }

  factory DefaultPayload.fromJsonString(String input) {
    return DefaultPayload.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "message": message,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("message=$message");
    return _queryParts_.join("&");
  }

  DefaultPayload copyWith({
    String? message,
  }) {
    return DefaultPayload(
      message: message ?? this.message,
    );
  }

  @override
  List<Object?> get props => [
        message,
      ];

  @override
  bool operator ==(Object other) {
    return other is DefaultPayload && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "DefaultPayload ${toJsonString()}";
  }
}

@deprecated
class DeprecatedRpcParams implements ArriModel {
  @deprecated
  final String deprecatedField;
  const DeprecatedRpcParams({
    required this.deprecatedField,
  });

  factory DeprecatedRpcParams.empty() {
    return DeprecatedRpcParams(
      deprecatedField: "",
    );
  }

  factory DeprecatedRpcParams.fromJson(Map<String, dynamic> _input_) {
    final deprecatedField =
        typeFromDynamic<String>(_input_["deprecatedField"], "");
    return DeprecatedRpcParams(
      deprecatedField: deprecatedField,
    );
  }

  factory DeprecatedRpcParams.fromJsonString(String input) {
    return DeprecatedRpcParams.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "deprecatedField": deprecatedField,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("deprecatedField=$deprecatedField");
    return _queryParts_.join("&");
  }

  DeprecatedRpcParams copyWith({
    String? deprecatedField,
  }) {
    return DeprecatedRpcParams(
      deprecatedField: deprecatedField ?? this.deprecatedField,
    );
  }

  @override
  List<Object?> get props => [
        deprecatedField,
      ];

  @override
  bool operator ==(Object other) {
    return other is DeprecatedRpcParams && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "DeprecatedRpcParams ${toJsonString()}";
  }
}

sealed class DiscriminatorWithEmptyObject implements ArriModel {
  String get type;
  const DiscriminatorWithEmptyObject();

  factory DiscriminatorWithEmptyObject.empty() {
    return DiscriminatorWithEmptyObjectEmpty.empty();
  }

  factory DiscriminatorWithEmptyObject.fromJson(Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "EMPTY":
        return DiscriminatorWithEmptyObjectEmpty.fromJson(_input_);
      case "NOT_EMPTY":
        return DiscriminatorWithEmptyObjectNotEmpty.fromJson(_input_);
      default:
        return DiscriminatorWithEmptyObject.empty();
    }
  }

  factory DiscriminatorWithEmptyObject.fromJsonString(String input) {
    return DiscriminatorWithEmptyObject.fromJson(json.decode(input));
  }
}

class DiscriminatorWithEmptyObjectEmpty
    implements DiscriminatorWithEmptyObject {
  const DiscriminatorWithEmptyObjectEmpty();

  @override
  String get type => "EMPTY";

  factory DiscriminatorWithEmptyObjectEmpty.empty() {
    return DiscriminatorWithEmptyObjectEmpty();
  }

  factory DiscriminatorWithEmptyObjectEmpty.fromJson(
      Map<String, dynamic> _input_) {
    return DiscriminatorWithEmptyObjectEmpty();
  }

  factory DiscriminatorWithEmptyObjectEmpty.fromJsonString(String input) {
    return DiscriminatorWithEmptyObjectEmpty.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    return _queryParts_.join("&");
  }

  DiscriminatorWithEmptyObjectEmpty copyWith() {
    return DiscriminatorWithEmptyObjectEmpty();
  }

  @override
  List<Object?> get props => [];

  @override
  bool operator ==(Object other) {
    return other is DiscriminatorWithEmptyObjectEmpty &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "DiscriminatorWithEmptyObjectEmpty ${toJsonString()}";
  }
}

class DiscriminatorWithEmptyObjectNotEmpty
    implements DiscriminatorWithEmptyObject {
  final String foo;
  final double bar;
  final bool baz;
  const DiscriminatorWithEmptyObjectNotEmpty({
    required this.foo,
    required this.bar,
    required this.baz,
  });

  @override
  String get type => "NOT_EMPTY";

  factory DiscriminatorWithEmptyObjectNotEmpty.empty() {
    return DiscriminatorWithEmptyObjectNotEmpty(
      foo: "",
      bar: 0.0,
      baz: false,
    );
  }

  factory DiscriminatorWithEmptyObjectNotEmpty.fromJson(
      Map<String, dynamic> _input_) {
    final foo = typeFromDynamic<String>(_input_["foo"], "");
    final bar = doubleFromDynamic(_input_["bar"], 0.0);
    final baz = typeFromDynamic<bool>(_input_["baz"], false);
    return DiscriminatorWithEmptyObjectNotEmpty(
      foo: foo,
      bar: bar,
      baz: baz,
    );
  }

  factory DiscriminatorWithEmptyObjectNotEmpty.fromJsonString(String input) {
    return DiscriminatorWithEmptyObjectNotEmpty.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "foo": foo,
      "bar": bar,
      "baz": baz,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("foo=$foo");
    _queryParts_.add("bar=$bar");
    _queryParts_.add("baz=$baz");
    return _queryParts_.join("&");
  }

  DiscriminatorWithEmptyObjectNotEmpty copyWith({
    String? foo,
    double? bar,
    bool? baz,
  }) {
    return DiscriminatorWithEmptyObjectNotEmpty(
      foo: foo ?? this.foo,
      bar: bar ?? this.bar,
      baz: baz ?? this.baz,
    );
  }

  @override
  List<Object?> get props => [
        foo,
        bar,
        baz,
      ];

  @override
  bool operator ==(Object other) {
    return other is DiscriminatorWithEmptyObjectNotEmpty &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "DiscriminatorWithEmptyObjectNotEmpty ${toJsonString()}";
  }
}

class SendErrorParams implements ArriModel {
  final int code;
  final String message;
  const SendErrorParams({
    required this.code,
    required this.message,
  });

  factory SendErrorParams.empty() {
    return SendErrorParams(
      code: 0,
      message: "",
    );
  }

  factory SendErrorParams.fromJson(Map<String, dynamic> _input_) {
    final code = intFromDynamic(_input_["code"], 0);
    final message = typeFromDynamic<String>(_input_["message"], "");
    return SendErrorParams(
      code: code,
      message: message,
    );
  }

  factory SendErrorParams.fromJsonString(String input) {
    return SendErrorParams.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "code": code,
      "message": message,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("code=$code");
    _queryParts_.add("message=$message");
    return _queryParts_.join("&");
  }

  SendErrorParams copyWith({
    int? code,
    String? message,
  }) {
    return SendErrorParams(
      code: code ?? this.code,
      message: message ?? this.message,
    );
  }

  @override
  List<Object?> get props => [
        code,
        message,
      ];

  @override
  bool operator ==(Object other) {
    return other is SendErrorParams && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "SendErrorParams ${toJsonString()}";
  }
}

class ObjectWithEveryType implements ArriModel {
  final dynamic any;
  final bool boolean;
  final String string;
  final DateTime timestamp;
  final double float32;
  final double float64;
  final int int8;
  final int uint8;
  final int int16;
  final int uint16;
  final int int32;
  final int uint32;
  final BigInt int64;
  final BigInt uint64;
  final ObjectWithEveryTypeEnumerator enumerator;
  final List<bool> array;
  final ObjectWithEveryTypeObject object;
  final Map<String, BigInt> record;
  final ObjectWithEveryTypeDiscriminator discriminator;
  final ObjectWithEveryTypeNestedObject nestedObject;
  final List<List<ObjectWithEveryTypeNestedArrayElementElement>> nestedArray;
  const ObjectWithEveryType({
    required this.any,
    required this.boolean,
    required this.string,
    required this.timestamp,
    required this.float32,
    required this.float64,
    required this.int8,
    required this.uint8,
    required this.int16,
    required this.uint16,
    required this.int32,
    required this.uint32,
    required this.int64,
    required this.uint64,
    required this.enumerator,
    required this.array,
    required this.object,
    required this.record,
    required this.discriminator,
    required this.nestedObject,
    required this.nestedArray,
  });

  factory ObjectWithEveryType.empty() {
    return ObjectWithEveryType(
      any: null,
      boolean: false,
      string: "",
      timestamp: DateTime.now(),
      float32: 0.0,
      float64: 0.0,
      int8: 0,
      uint8: 0,
      int16: 0,
      uint16: 0,
      int32: 0,
      uint32: 0,
      int64: BigInt.zero,
      uint64: BigInt.zero,
      enumerator: ObjectWithEveryTypeEnumerator.a,
      array: [],
      object: ObjectWithEveryTypeObject.empty(),
      record: {},
      discriminator: ObjectWithEveryTypeDiscriminator.empty(),
      nestedObject: ObjectWithEveryTypeNestedObject.empty(),
      nestedArray: [],
    );
  }

  factory ObjectWithEveryType.fromJson(Map<String, dynamic> _input_) {
    final any = _input_["any"];
    final boolean = typeFromDynamic<bool>(_input_["boolean"], false);
    final string = typeFromDynamic<String>(_input_["string"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    final float32 = doubleFromDynamic(_input_["float32"], 0.0);
    final float64 = doubleFromDynamic(_input_["float64"], 0.0);
    final int8 = intFromDynamic(_input_["int8"], 0);
    final uint8 = intFromDynamic(_input_["uint8"], 0);
    final int16 = intFromDynamic(_input_["int16"], 0);
    final uint16 = intFromDynamic(_input_["uint16"], 0);
    final int32 = intFromDynamic(_input_["int32"], 0);
    final uint32 = intFromDynamic(_input_["uint32"], 0);
    final int64 = bigIntFromDynamic(_input_["int64"], BigInt.zero);
    final uint64 = bigIntFromDynamic(_input_["uint64"], BigInt.zero);
    final enumerator = ObjectWithEveryTypeEnumerator.fromString(
        typeFromDynamic<String>(_input_["enumerator"], ""));
    final array = _input_["array"] is List
        ? (_input_["array"] as List)
            .map((_el_) => typeFromDynamic<bool>(_el_, false))
            .toList()
        : <bool>[];
    final object = _input_["object"] is Map<String, dynamic>
        ? ObjectWithEveryTypeObject.fromJson(_input_["object"])
        : ObjectWithEveryTypeObject.empty();
    final record = _input_["record"] is Map<String, dynamic>
        ? (_input_["record"] as Map<String, dynamic>).map(
            (_key_, _val_) => MapEntry(
              _key_,
              bigIntFromDynamic(_val_, BigInt.zero),
            ),
          )
        : <String, BigInt>{};
    final discriminator = _input_["discriminator"] is Map<String, dynamic>
        ? ObjectWithEveryTypeDiscriminator.fromJson(_input_["discriminator"])
        : ObjectWithEveryTypeDiscriminator.empty();
    final nestedObject = _input_["nestedObject"] is Map<String, dynamic>
        ? ObjectWithEveryTypeNestedObject.fromJson(_input_["nestedObject"])
        : ObjectWithEveryTypeNestedObject.empty();
    final nestedArray = _input_["nestedArray"] is List
        ? (_input_["nestedArray"] as List)
            .map((_el_) => _el_ is List
                ? (_el_ as List)
                    .map((_el_) => _el_ is Map<String, dynamic>
                        ? ObjectWithEveryTypeNestedArrayElementElement.fromJson(
                            _el_)
                        : ObjectWithEveryTypeNestedArrayElementElement.empty())
                    .toList()
                : <ObjectWithEveryTypeNestedArrayElementElement>[])
            .toList()
        : <List<ObjectWithEveryTypeNestedArrayElementElement>>[];
    return ObjectWithEveryType(
      any: any,
      boolean: boolean,
      string: string,
      timestamp: timestamp,
      float32: float32,
      float64: float64,
      int8: int8,
      uint8: uint8,
      int16: int16,
      uint16: uint16,
      int32: int32,
      uint32: uint32,
      int64: int64,
      uint64: uint64,
      enumerator: enumerator,
      array: array,
      object: object,
      record: record,
      discriminator: discriminator,
      nestedObject: nestedObject,
      nestedArray: nestedArray,
    );
  }

  factory ObjectWithEveryType.fromJsonString(String input) {
    return ObjectWithEveryType.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "any": any,
      "boolean": boolean,
      "string": string,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "float32": float32,
      "float64": float64,
      "int8": int8,
      "uint8": uint8,
      "int16": int16,
      "uint16": uint16,
      "int32": int32,
      "uint32": uint32,
      "int64": int64.toString(),
      "uint64": uint64.toString(),
      "enumerator": enumerator.serialValue,
      "array": array.map((_el_) => _el_).toList(),
      "object": object.toJson(),
      "record": record.map(
        (_key_, _val_) => MapEntry(
          _key_,
          _val_.toString(),
        ),
      ),
      "discriminator": discriminator.toJson(),
      "nestedObject": nestedObject.toJson(),
      "nestedArray": nestedArray
          .map((_el_) => _el_.map((_el_) => _el_.toJson()).toList())
          .toList(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    print(
        "[WARNING] any's cannot be serialized to query params. Skipping field at /ObjectWithEveryType/any.");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("string=$string");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    _queryParts_.add("float32=$float32");
    _queryParts_.add("float64=$float64");
    _queryParts_.add("int8=$int8");
    _queryParts_.add("uint8=$uint8");
    _queryParts_.add("int16=$int16");
    _queryParts_.add("uint16=$uint16");
    _queryParts_.add("int32=$int32");
    _queryParts_.add("uint32=$uint32");
    _queryParts_.add("int64=$int64");
    _queryParts_.add("uint64=$uint64");
    _queryParts_.add("enumerator=${enumerator.serialValue}");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryType/array.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryType/object.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryType/record.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryType/discriminator.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryType/nestedObject.");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryType/nestedArray.");
    return _queryParts_.join("&");
  }

  ObjectWithEveryType copyWith({
    dynamic any,
    bool? boolean,
    String? string,
    DateTime? timestamp,
    double? float32,
    double? float64,
    int? int8,
    int? uint8,
    int? int16,
    int? uint16,
    int? int32,
    int? uint32,
    BigInt? int64,
    BigInt? uint64,
    ObjectWithEveryTypeEnumerator? enumerator,
    List<bool>? array,
    ObjectWithEveryTypeObject? object,
    Map<String, BigInt>? record,
    ObjectWithEveryTypeDiscriminator? discriminator,
    ObjectWithEveryTypeNestedObject? nestedObject,
    List<List<ObjectWithEveryTypeNestedArrayElementElement>>? nestedArray,
  }) {
    return ObjectWithEveryType(
      any: any ?? this.any,
      boolean: boolean ?? this.boolean,
      string: string ?? this.string,
      timestamp: timestamp ?? this.timestamp,
      float32: float32 ?? this.float32,
      float64: float64 ?? this.float64,
      int8: int8 ?? this.int8,
      uint8: uint8 ?? this.uint8,
      int16: int16 ?? this.int16,
      uint16: uint16 ?? this.uint16,
      int32: int32 ?? this.int32,
      uint32: uint32 ?? this.uint32,
      int64: int64 ?? this.int64,
      uint64: uint64 ?? this.uint64,
      enumerator: enumerator ?? this.enumerator,
      array: array ?? this.array,
      object: object ?? this.object,
      record: record ?? this.record,
      discriminator: discriminator ?? this.discriminator,
      nestedObject: nestedObject ?? this.nestedObject,
      nestedArray: nestedArray ?? this.nestedArray,
    );
  }

  @override
  List<Object?> get props => [
        any,
        boolean,
        string,
        timestamp,
        float32,
        float64,
        int8,
        uint8,
        int16,
        uint16,
        int32,
        uint32,
        int64,
        uint64,
        enumerator,
        array,
        object,
        record,
        discriminator,
        nestedObject,
        nestedArray,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryType && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryType ${toJsonString()}";
  }
}

enum ObjectWithEveryTypeEnumerator
    implements Comparable<ObjectWithEveryTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const ObjectWithEveryTypeEnumerator(this.serialValue);
  final String serialValue;

  factory ObjectWithEveryTypeEnumerator.fromString(String input) {
    for (final val in values) {
      if (val.serialValue == input) {
        return val;
      }
    }
    return a;
  }

  @override
  int compareTo(ObjectWithEveryTypeEnumerator other) =>
      name.compareTo(other.name);
}

class ObjectWithEveryTypeObject implements ArriModel {
  final String string;
  final bool boolean;
  final DateTime timestamp;
  const ObjectWithEveryTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });

  factory ObjectWithEveryTypeObject.empty() {
    return ObjectWithEveryTypeObject(
      string: "",
      boolean: false,
      timestamp: DateTime.now(),
    );
  }

  factory ObjectWithEveryTypeObject.fromJson(Map<String, dynamic> _input_) {
    final string = typeFromDynamic<String>(_input_["string"], "");
    final boolean = typeFromDynamic<bool>(_input_["boolean"], false);
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    return ObjectWithEveryTypeObject(
      string: string,
      boolean: boolean,
      timestamp: timestamp,
    );
  }

  factory ObjectWithEveryTypeObject.fromJsonString(String input) {
    return ObjectWithEveryTypeObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("string=$string");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  ObjectWithEveryTypeObject copyWith({
    String? string,
    bool? boolean,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryTypeObject(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        string,
        boolean,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryTypeObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryTypeObject ${toJsonString()}";
  }
}

sealed class ObjectWithEveryTypeDiscriminator implements ArriModel {
  String get type;
  const ObjectWithEveryTypeDiscriminator();

  factory ObjectWithEveryTypeDiscriminator.empty() {
    return ObjectWithEveryTypeDiscriminatorA.empty();
  }

  factory ObjectWithEveryTypeDiscriminator.fromJson(
      Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "A":
        return ObjectWithEveryTypeDiscriminatorA.fromJson(_input_);
      case "B":
        return ObjectWithEveryTypeDiscriminatorB.fromJson(_input_);
      default:
        return ObjectWithEveryTypeDiscriminator.empty();
    }
  }

  factory ObjectWithEveryTypeDiscriminator.fromJsonString(String input) {
    return ObjectWithEveryTypeDiscriminator.fromJson(json.decode(input));
  }
}

class ObjectWithEveryTypeDiscriminatorA
    implements ObjectWithEveryTypeDiscriminator {
  final String title;
  const ObjectWithEveryTypeDiscriminatorA({
    required this.title,
  });

  @override
  String get type => "A";

  factory ObjectWithEveryTypeDiscriminatorA.empty() {
    return ObjectWithEveryTypeDiscriminatorA(
      title: "",
    );
  }

  factory ObjectWithEveryTypeDiscriminatorA.fromJson(
      Map<String, dynamic> _input_) {
    final title = typeFromDynamic<String>(_input_["title"], "");
    return ObjectWithEveryTypeDiscriminatorA(
      title: title,
    );
  }

  factory ObjectWithEveryTypeDiscriminatorA.fromJsonString(String input) {
    return ObjectWithEveryTypeDiscriminatorA.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    return _queryParts_.join("&");
  }

  ObjectWithEveryTypeDiscriminatorA copyWith({
    String? title,
  }) {
    return ObjectWithEveryTypeDiscriminatorA(
      title: title ?? this.title,
    );
  }

  @override
  List<Object?> get props => [
        title,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryTypeDiscriminatorA &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryTypeDiscriminatorA ${toJsonString()}";
  }
}

class ObjectWithEveryTypeDiscriminatorB
    implements ObjectWithEveryTypeDiscriminator {
  final String title;
  final String description;
  const ObjectWithEveryTypeDiscriminatorB({
    required this.title,
    required this.description,
  });

  @override
  String get type => "B";

  factory ObjectWithEveryTypeDiscriminatorB.empty() {
    return ObjectWithEveryTypeDiscriminatorB(
      title: "",
      description: "",
    );
  }

  factory ObjectWithEveryTypeDiscriminatorB.fromJson(
      Map<String, dynamic> _input_) {
    final title = typeFromDynamic<String>(_input_["title"], "");
    final description = typeFromDynamic<String>(_input_["description"], "");
    return ObjectWithEveryTypeDiscriminatorB(
      title: title,
      description: description,
    );
  }

  factory ObjectWithEveryTypeDiscriminatorB.fromJsonString(String input) {
    return ObjectWithEveryTypeDiscriminatorB.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    _queryParts_.add("description=$description");
    return _queryParts_.join("&");
  }

  ObjectWithEveryTypeDiscriminatorB copyWith({
    String? title,
    String? description,
  }) {
    return ObjectWithEveryTypeDiscriminatorB(
      title: title ?? this.title,
      description: description ?? this.description,
    );
  }

  @override
  List<Object?> get props => [
        title,
        description,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryTypeDiscriminatorB &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryTypeDiscriminatorB ${toJsonString()}";
  }
}

class ObjectWithEveryTypeNestedObject implements ArriModel {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryTypeNestedObjectData data;
  const ObjectWithEveryTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory ObjectWithEveryTypeNestedObject.empty() {
    return ObjectWithEveryTypeNestedObject(
      id: "",
      timestamp: DateTime.now(),
      data: ObjectWithEveryTypeNestedObjectData.empty(),
    );
  }

  factory ObjectWithEveryTypeNestedObject.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    final data = _input_["data"] is Map<String, dynamic>
        ? ObjectWithEveryTypeNestedObjectData.fromJson(_input_["data"])
        : ObjectWithEveryTypeNestedObjectData.empty();
    return ObjectWithEveryTypeNestedObject(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory ObjectWithEveryTypeNestedObject.fromJsonString(String input) {
    return ObjectWithEveryTypeNestedObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryTypeNestedObject/data.");
    return _queryParts_.join("&");
  }

  ObjectWithEveryTypeNestedObject copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryTypeNestedObjectData? data,
  }) {
    return ObjectWithEveryTypeNestedObject(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryTypeNestedObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryTypeNestedObject ${toJsonString()}";
  }
}

class ObjectWithEveryTypeNestedObjectData implements ArriModel {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryTypeNestedObjectDataData data;
  const ObjectWithEveryTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory ObjectWithEveryTypeNestedObjectData.empty() {
    return ObjectWithEveryTypeNestedObjectData(
      id: "",
      timestamp: DateTime.now(),
      data: ObjectWithEveryTypeNestedObjectDataData.empty(),
    );
  }

  factory ObjectWithEveryTypeNestedObjectData.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    final data = _input_["data"] is Map<String, dynamic>
        ? ObjectWithEveryTypeNestedObjectDataData.fromJson(_input_["data"])
        : ObjectWithEveryTypeNestedObjectDataData.empty();
    return ObjectWithEveryTypeNestedObjectData(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory ObjectWithEveryTypeNestedObjectData.fromJsonString(String input) {
    return ObjectWithEveryTypeNestedObjectData.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryTypeNestedObjectData/data.");
    return _queryParts_.join("&");
  }

  ObjectWithEveryTypeNestedObjectData copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryTypeNestedObjectDataData? data,
  }) {
    return ObjectWithEveryTypeNestedObjectData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryTypeNestedObjectData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryTypeNestedObjectData ${toJsonString()}";
  }
}

class ObjectWithEveryTypeNestedObjectDataData implements ArriModel {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });

  factory ObjectWithEveryTypeNestedObjectDataData.empty() {
    return ObjectWithEveryTypeNestedObjectDataData(
      id: "",
      timestamp: DateTime.now(),
    );
  }

  factory ObjectWithEveryTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    return ObjectWithEveryTypeNestedObjectDataData(
      id: id,
      timestamp: timestamp,
    );
  }

  factory ObjectWithEveryTypeNestedObjectDataData.fromJsonString(String input) {
    return ObjectWithEveryTypeNestedObjectDataData.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  ObjectWithEveryTypeNestedObjectDataData copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryTypeNestedObjectDataData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryTypeNestedObjectDataData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryTypeNestedObjectDataData ${toJsonString()}";
  }
}

class ObjectWithEveryTypeNestedArrayElementElement implements ArriModel {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryTypeNestedArrayElementElement({
    required this.id,
    required this.timestamp,
  });

  factory ObjectWithEveryTypeNestedArrayElementElement.empty() {
    return ObjectWithEveryTypeNestedArrayElementElement(
      id: "",
      timestamp: DateTime.now(),
    );
  }

  factory ObjectWithEveryTypeNestedArrayElementElement.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    return ObjectWithEveryTypeNestedArrayElementElement(
      id: id,
      timestamp: timestamp,
    );
  }

  factory ObjectWithEveryTypeNestedArrayElementElement.fromJsonString(
      String input) {
    return ObjectWithEveryTypeNestedArrayElementElement.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  ObjectWithEveryTypeNestedArrayElementElement copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryTypeNestedArrayElementElement(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryTypeNestedArrayElementElement &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryTypeNestedArrayElementElement ${toJsonString()}";
  }
}

class ObjectWithEveryNullableType implements ArriModel {
  final dynamic any;
  final bool? boolean;
  final String? string;
  final DateTime? timestamp;
  final double? float32;
  final double? float64;
  final int? int8;
  final int? uint8;
  final int? int16;
  final int? uint16;
  final int? int32;
  final int? uint32;
  final BigInt? int64;
  final BigInt? uint64;
  final ObjectWithEveryNullableTypeEnumerator? enumerator;
  final List<bool?>? array;
  final ObjectWithEveryNullableTypeObject? object;
  final Map<String, BigInt?>? record;
  final ObjectWithEveryNullableTypeDiscriminator? discriminator;
  final ObjectWithEveryNullableTypeNestedObject? nestedObject;
  final List<List<ObjectWithEveryNullableTypeNestedArrayElementElement?>?>?
      nestedArray;
  const ObjectWithEveryNullableType({
    required this.any,
    required this.boolean,
    required this.string,
    required this.timestamp,
    required this.float32,
    required this.float64,
    required this.int8,
    required this.uint8,
    required this.int16,
    required this.uint16,
    required this.int32,
    required this.uint32,
    required this.int64,
    required this.uint64,
    required this.enumerator,
    required this.array,
    required this.object,
    required this.record,
    required this.discriminator,
    required this.nestedObject,
    required this.nestedArray,
  });

  factory ObjectWithEveryNullableType.empty() {
    return ObjectWithEveryNullableType(
      any: null,
      boolean: null,
      string: null,
      timestamp: null,
      float32: null,
      float64: null,
      int8: null,
      uint8: null,
      int16: null,
      uint16: null,
      int32: null,
      uint32: null,
      int64: null,
      uint64: null,
      enumerator: null,
      array: null,
      object: null,
      record: null,
      discriminator: null,
      nestedObject: null,
      nestedArray: null,
    );
  }

  factory ObjectWithEveryNullableType.fromJson(Map<String, dynamic> _input_) {
    final any = _input_["any"];
    final boolean = nullableTypeFromDynamic<bool>(_input_["boolean"]);
    final string = nullableTypeFromDynamic<String>(_input_["string"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    final float32 = nullableDoubleFromDynamic(_input_["float32"]);
    final float64 = nullableDoubleFromDynamic(_input_["float64"]);
    final int8 = nullableIntFromDynamic(_input_["int8"]);
    final uint8 = nullableIntFromDynamic(_input_["uint8"]);
    final int16 = nullableIntFromDynamic(_input_["int16"]);
    final uint16 = nullableIntFromDynamic(_input_["uint16"]);
    final int32 = nullableIntFromDynamic(_input_["int32"]);
    final uint32 = nullableIntFromDynamic(_input_["uint32"]);
    final int64 = nullableBigIntFromDynamic(_input_["int64"]);
    final uint64 = nullableBigIntFromDynamic(_input_["uint64"]);
    final enumerator = _input_["enumerator"] is String
        ? ObjectWithEveryNullableTypeEnumerator.fromString(
            _input_["enumerator"])
        : null;
    final array = _input_["array"] is List
        ? (_input_["array"] as List)
            .map((_el_) => nullableTypeFromDynamic<bool>(_el_))
            .toList()
        : null;
    final object = _input_["object"] is Map<String, dynamic>
        ? ObjectWithEveryNullableTypeObject.fromJson(_input_["object"])
        : null;
    final record = _input_["record"] is Map<String, dynamic>
        ? (_input_["record"] as Map<String, dynamic>).map(
            (_key_, _val_) => MapEntry(
              _key_,
              nullableBigIntFromDynamic(_val_),
            ),
          )
        : null;
    final discriminator = _input_["discriminator"] is Map<String, dynamic>
        ? ObjectWithEveryNullableTypeDiscriminator.fromJson(
            _input_["discriminator"])
        : null;
    final nestedObject = _input_["nestedObject"] is Map<String, dynamic>
        ? ObjectWithEveryNullableTypeNestedObject.fromJson(
            _input_["nestedObject"])
        : null;
    final nestedArray = _input_["nestedArray"] is List
        ? (_input_["nestedArray"] as List)
            .map((_el_) => _el_ is List
                ? (_el_ as List)
                    .map((_el_) => _el_ is Map<String, dynamic>
                        ? ObjectWithEveryNullableTypeNestedArrayElementElement
                            .fromJson(_el_)
                        : null)
                    .toList()
                : null)
            .toList()
        : null;
    return ObjectWithEveryNullableType(
      any: any,
      boolean: boolean,
      string: string,
      timestamp: timestamp,
      float32: float32,
      float64: float64,
      int8: int8,
      uint8: uint8,
      int16: int16,
      uint16: uint16,
      int32: int32,
      uint32: uint32,
      int64: int64,
      uint64: uint64,
      enumerator: enumerator,
      array: array,
      object: object,
      record: record,
      discriminator: discriminator,
      nestedObject: nestedObject,
      nestedArray: nestedArray,
    );
  }

  factory ObjectWithEveryNullableType.fromJsonString(String input) {
    return ObjectWithEveryNullableType.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "any": any,
      "boolean": boolean,
      "string": string,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "float32": float32,
      "float64": float64,
      "int8": int8,
      "uint8": uint8,
      "int16": int16,
      "uint16": uint16,
      "int32": int32,
      "uint32": uint32,
      "int64": int64?.toString(),
      "uint64": uint64?.toString(),
      "enumerator": enumerator?.serialValue,
      "array": array?.map((_el_) => _el_).toList(),
      "object": object?.toJson(),
      "record": record?.map(
        (_key_, _val_) => MapEntry(
          _key_,
          _val_?.toString(),
        ),
      ),
      "discriminator": discriminator?.toJson(),
      "nestedObject": nestedObject?.toJson(),
      "nestedArray": nestedArray
          ?.map((_el_) => _el_?.map((_el_) => _el_?.toJson()).toList())
          .toList(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    print(
        "[WARNING] any's cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/any.");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("string=$string");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    _queryParts_.add("float32=$float32");
    _queryParts_.add("float64=$float64");
    _queryParts_.add("int8=$int8");
    _queryParts_.add("uint8=$uint8");
    _queryParts_.add("int16=$int16");
    _queryParts_.add("uint16=$uint16");
    _queryParts_.add("int32=$int32");
    _queryParts_.add("uint32=$uint32");
    _queryParts_.add("int64=$int64");
    _queryParts_.add("uint64=$uint64");
    _queryParts_.add("enumerator=${enumerator?.serialValue}");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/array.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/object.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/record.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/discriminator.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/nestedObject.");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/nestedArray.");
    return _queryParts_.join("&");
  }

  ObjectWithEveryNullableType copyWith({
    dynamic Function()? any,
    bool? Function()? boolean,
    String? Function()? string,
    DateTime? Function()? timestamp,
    double? Function()? float32,
    double? Function()? float64,
    int? Function()? int8,
    int? Function()? uint8,
    int? Function()? int16,
    int? Function()? uint16,
    int? Function()? int32,
    int? Function()? uint32,
    BigInt? Function()? int64,
    BigInt? Function()? uint64,
    ObjectWithEveryNullableTypeEnumerator? Function()? enumerator,
    List<bool?>? Function()? array,
    ObjectWithEveryNullableTypeObject? Function()? object,
    Map<String, BigInt?>? Function()? record,
    ObjectWithEveryNullableTypeDiscriminator? Function()? discriminator,
    ObjectWithEveryNullableTypeNestedObject? Function()? nestedObject,
    List<List<ObjectWithEveryNullableTypeNestedArrayElementElement?>?>?
            Function()?
        nestedArray,
  }) {
    return ObjectWithEveryNullableType(
      any: any != null ? any() : this.any,
      boolean: boolean != null ? boolean() : this.boolean,
      string: string != null ? string() : this.string,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
      float32: float32 != null ? float32() : this.float32,
      float64: float64 != null ? float64() : this.float64,
      int8: int8 != null ? int8() : this.int8,
      uint8: uint8 != null ? uint8() : this.uint8,
      int16: int16 != null ? int16() : this.int16,
      uint16: uint16 != null ? uint16() : this.uint16,
      int32: int32 != null ? int32() : this.int32,
      uint32: uint32 != null ? uint32() : this.uint32,
      int64: int64 != null ? int64() : this.int64,
      uint64: uint64 != null ? uint64() : this.uint64,
      enumerator: enumerator != null ? enumerator() : this.enumerator,
      array: array != null ? array() : this.array,
      object: object != null ? object() : this.object,
      record: record != null ? record() : this.record,
      discriminator:
          discriminator != null ? discriminator() : this.discriminator,
      nestedObject: nestedObject != null ? nestedObject() : this.nestedObject,
      nestedArray: nestedArray != null ? nestedArray() : this.nestedArray,
    );
  }

  @override
  List<Object?> get props => [
        any,
        boolean,
        string,
        timestamp,
        float32,
        float64,
        int8,
        uint8,
        int16,
        uint16,
        int32,
        uint32,
        int64,
        uint64,
        enumerator,
        array,
        object,
        record,
        discriminator,
        nestedObject,
        nestedArray,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryNullableType &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryNullableType ${toJsonString()}";
  }
}

enum ObjectWithEveryNullableTypeEnumerator
    implements Comparable<ObjectWithEveryNullableTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const ObjectWithEveryNullableTypeEnumerator(this.serialValue);
  final String serialValue;

  factory ObjectWithEveryNullableTypeEnumerator.fromString(String input) {
    for (final val in values) {
      if (val.serialValue == input) {
        return val;
      }
    }
    return a;
  }

  @override
  int compareTo(ObjectWithEveryNullableTypeEnumerator other) =>
      name.compareTo(other.name);
}

class ObjectWithEveryNullableTypeObject implements ArriModel {
  final String? string;
  final bool? boolean;
  final DateTime? timestamp;
  const ObjectWithEveryNullableTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });

  factory ObjectWithEveryNullableTypeObject.empty() {
    return ObjectWithEveryNullableTypeObject(
      string: null,
      boolean: null,
      timestamp: null,
    );
  }

  factory ObjectWithEveryNullableTypeObject.fromJson(
      Map<String, dynamic> _input_) {
    final string = nullableTypeFromDynamic<String>(_input_["string"]);
    final boolean = nullableTypeFromDynamic<bool>(_input_["boolean"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    return ObjectWithEveryNullableTypeObject(
      string: string,
      boolean: boolean,
      timestamp: timestamp,
    );
  }

  factory ObjectWithEveryNullableTypeObject.fromJsonString(String input) {
    return ObjectWithEveryNullableTypeObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("string=$string");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  ObjectWithEveryNullableTypeObject copyWith({
    String? Function()? string,
    bool? Function()? boolean,
    DateTime? Function()? timestamp,
  }) {
    return ObjectWithEveryNullableTypeObject(
      string: string != null ? string() : this.string,
      boolean: boolean != null ? boolean() : this.boolean,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        string,
        boolean,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryNullableTypeObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryNullableTypeObject ${toJsonString()}";
  }
}

sealed class ObjectWithEveryNullableTypeDiscriminator implements ArriModel {
  String get type;
  const ObjectWithEveryNullableTypeDiscriminator();

  factory ObjectWithEveryNullableTypeDiscriminator.empty() {
    return ObjectWithEveryNullableTypeDiscriminatorA.empty();
  }

  factory ObjectWithEveryNullableTypeDiscriminator.fromJson(
      Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "A":
        return ObjectWithEveryNullableTypeDiscriminatorA.fromJson(_input_);
      case "B":
        return ObjectWithEveryNullableTypeDiscriminatorB.fromJson(_input_);
      default:
        return ObjectWithEveryNullableTypeDiscriminator.empty();
    }
  }

  factory ObjectWithEveryNullableTypeDiscriminator.fromJsonString(
      String input) {
    return ObjectWithEveryNullableTypeDiscriminator.fromJson(
        json.decode(input));
  }
}

class ObjectWithEveryNullableTypeDiscriminatorA
    implements ObjectWithEveryNullableTypeDiscriminator {
  final String? title;
  const ObjectWithEveryNullableTypeDiscriminatorA({
    required this.title,
  });

  @override
  String get type => "A";

  factory ObjectWithEveryNullableTypeDiscriminatorA.empty() {
    return ObjectWithEveryNullableTypeDiscriminatorA(
      title: null,
    );
  }

  factory ObjectWithEveryNullableTypeDiscriminatorA.fromJson(
      Map<String, dynamic> _input_) {
    final title = nullableTypeFromDynamic<String>(_input_["title"]);
    return ObjectWithEveryNullableTypeDiscriminatorA(
      title: title,
    );
  }

  factory ObjectWithEveryNullableTypeDiscriminatorA.fromJsonString(
      String input) {
    return ObjectWithEveryNullableTypeDiscriminatorA.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    return _queryParts_.join("&");
  }

  ObjectWithEveryNullableTypeDiscriminatorA copyWith({
    String? Function()? title,
  }) {
    return ObjectWithEveryNullableTypeDiscriminatorA(
      title: title != null ? title() : this.title,
    );
  }

  @override
  List<Object?> get props => [
        title,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryNullableTypeDiscriminatorA &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryNullableTypeDiscriminatorA ${toJsonString()}";
  }
}

class ObjectWithEveryNullableTypeDiscriminatorB
    implements ObjectWithEveryNullableTypeDiscriminator {
  final String? title;
  final String? description;
  const ObjectWithEveryNullableTypeDiscriminatorB({
    required this.title,
    required this.description,
  });

  @override
  String get type => "B";

  factory ObjectWithEveryNullableTypeDiscriminatorB.empty() {
    return ObjectWithEveryNullableTypeDiscriminatorB(
      title: null,
      description: null,
    );
  }

  factory ObjectWithEveryNullableTypeDiscriminatorB.fromJson(
      Map<String, dynamic> _input_) {
    final title = nullableTypeFromDynamic<String>(_input_["title"]);
    final description = nullableTypeFromDynamic<String>(_input_["description"]);
    return ObjectWithEveryNullableTypeDiscriminatorB(
      title: title,
      description: description,
    );
  }

  factory ObjectWithEveryNullableTypeDiscriminatorB.fromJsonString(
      String input) {
    return ObjectWithEveryNullableTypeDiscriminatorB.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    _queryParts_.add("description=$description");
    return _queryParts_.join("&");
  }

  ObjectWithEveryNullableTypeDiscriminatorB copyWith({
    String? Function()? title,
    String? Function()? description,
  }) {
    return ObjectWithEveryNullableTypeDiscriminatorB(
      title: title != null ? title() : this.title,
      description: description != null ? description() : this.description,
    );
  }

  @override
  List<Object?> get props => [
        title,
        description,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryNullableTypeDiscriminatorB &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryNullableTypeDiscriminatorB ${toJsonString()}";
  }
}

class ObjectWithEveryNullableTypeNestedObject implements ArriModel {
  final String? id;
  final DateTime? timestamp;
  final ObjectWithEveryNullableTypeNestedObjectData? data;
  const ObjectWithEveryNullableTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory ObjectWithEveryNullableTypeNestedObject.empty() {
    return ObjectWithEveryNullableTypeNestedObject(
      id: null,
      timestamp: null,
      data: null,
    );
  }

  factory ObjectWithEveryNullableTypeNestedObject.fromJson(
      Map<String, dynamic> _input_) {
    final id = nullableTypeFromDynamic<String>(_input_["id"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    final data = _input_["data"] is Map<String, dynamic>
        ? ObjectWithEveryNullableTypeNestedObjectData.fromJson(_input_["data"])
        : null;
    return ObjectWithEveryNullableTypeNestedObject(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory ObjectWithEveryNullableTypeNestedObject.fromJsonString(String input) {
    return ObjectWithEveryNullableTypeNestedObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "data": data?.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableTypeNestedObject/data.");
    return _queryParts_.join("&");
  }

  ObjectWithEveryNullableTypeNestedObject copyWith({
    String? Function()? id,
    DateTime? Function()? timestamp,
    ObjectWithEveryNullableTypeNestedObjectData? Function()? data,
  }) {
    return ObjectWithEveryNullableTypeNestedObject(
      id: id != null ? id() : this.id,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
      data: data != null ? data() : this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryNullableTypeNestedObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryNullableTypeNestedObject ${toJsonString()}";
  }
}

class ObjectWithEveryNullableTypeNestedObjectData implements ArriModel {
  final String? id;
  final DateTime? timestamp;
  final ObjectWithEveryNullableTypeNestedObjectDataData? data;
  const ObjectWithEveryNullableTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory ObjectWithEveryNullableTypeNestedObjectData.empty() {
    return ObjectWithEveryNullableTypeNestedObjectData(
      id: null,
      timestamp: null,
      data: null,
    );
  }

  factory ObjectWithEveryNullableTypeNestedObjectData.fromJson(
      Map<String, dynamic> _input_) {
    final id = nullableTypeFromDynamic<String>(_input_["id"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    final data = _input_["data"] is Map<String, dynamic>
        ? ObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
            _input_["data"])
        : null;
    return ObjectWithEveryNullableTypeNestedObjectData(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory ObjectWithEveryNullableTypeNestedObjectData.fromJsonString(
      String input) {
    return ObjectWithEveryNullableTypeNestedObjectData.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "data": data?.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableTypeNestedObjectData/data.");
    return _queryParts_.join("&");
  }

  ObjectWithEveryNullableTypeNestedObjectData copyWith({
    String? Function()? id,
    DateTime? Function()? timestamp,
    ObjectWithEveryNullableTypeNestedObjectDataData? Function()? data,
  }) {
    return ObjectWithEveryNullableTypeNestedObjectData(
      id: id != null ? id() : this.id,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
      data: data != null ? data() : this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryNullableTypeNestedObjectData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryNullableTypeNestedObjectData ${toJsonString()}";
  }
}

class ObjectWithEveryNullableTypeNestedObjectDataData implements ArriModel {
  final String? id;
  final DateTime? timestamp;
  const ObjectWithEveryNullableTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });

  factory ObjectWithEveryNullableTypeNestedObjectDataData.empty() {
    return ObjectWithEveryNullableTypeNestedObjectDataData(
      id: null,
      timestamp: null,
    );
  }

  factory ObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> _input_) {
    final id = nullableTypeFromDynamic<String>(_input_["id"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    return ObjectWithEveryNullableTypeNestedObjectDataData(
      id: id,
      timestamp: timestamp,
    );
  }

  factory ObjectWithEveryNullableTypeNestedObjectDataData.fromJsonString(
      String input) {
    return ObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  ObjectWithEveryNullableTypeNestedObjectDataData copyWith({
    String? Function()? id,
    DateTime? Function()? timestamp,
  }) {
    return ObjectWithEveryNullableTypeNestedObjectDataData(
      id: id != null ? id() : this.id,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryNullableTypeNestedObjectDataData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryNullableTypeNestedObjectDataData ${toJsonString()}";
  }
}

class ObjectWithEveryNullableTypeNestedArrayElementElement
    implements ArriModel {
  final String? id;
  final DateTime? timestamp;
  const ObjectWithEveryNullableTypeNestedArrayElementElement({
    required this.id,
    required this.timestamp,
  });

  factory ObjectWithEveryNullableTypeNestedArrayElementElement.empty() {
    return ObjectWithEveryNullableTypeNestedArrayElementElement(
      id: null,
      timestamp: null,
    );
  }

  factory ObjectWithEveryNullableTypeNestedArrayElementElement.fromJson(
      Map<String, dynamic> _input_) {
    final id = nullableTypeFromDynamic<String>(_input_["id"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    return ObjectWithEveryNullableTypeNestedArrayElementElement(
      id: id,
      timestamp: timestamp,
    );
  }

  factory ObjectWithEveryNullableTypeNestedArrayElementElement.fromJsonString(
      String input) {
    return ObjectWithEveryNullableTypeNestedArrayElementElement.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  ObjectWithEveryNullableTypeNestedArrayElementElement copyWith({
    String? Function()? id,
    DateTime? Function()? timestamp,
  }) {
    return ObjectWithEveryNullableTypeNestedArrayElementElement(
      id: id != null ? id() : this.id,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryNullableTypeNestedArrayElementElement &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryNullableTypeNestedArrayElementElement ${toJsonString()}";
  }
}

class ObjectWithPascalCaseKeys implements ArriModel {
  final DateTime createdAt;
  final String displayName;
  final String? phoneNumber;
  final String? emailAddress;
  final bool? isAdmin;
  const ObjectWithPascalCaseKeys({
    required this.createdAt,
    required this.displayName,
    required this.phoneNumber,
    this.emailAddress,
    this.isAdmin,
  });

  factory ObjectWithPascalCaseKeys.empty() {
    return ObjectWithPascalCaseKeys(
      createdAt: DateTime.now(),
      displayName: "",
      phoneNumber: null,
    );
  }

  factory ObjectWithPascalCaseKeys.fromJson(Map<String, dynamic> _input_) {
    final createdAt = dateTimeFromDynamic(_input_["CreatedAt"], DateTime.now());
    final displayName = typeFromDynamic<String>(_input_["DisplayName"], "");
    final phoneNumber = nullableTypeFromDynamic<String>(_input_["PhoneNumber"]);
    final emailAddress =
        nullableTypeFromDynamic<String>(_input_["EmailAddress"]);
    final isAdmin = nullableTypeFromDynamic<bool>(_input_["IsAdmin"]);
    return ObjectWithPascalCaseKeys(
      createdAt: createdAt,
      displayName: displayName,
      phoneNumber: phoneNumber,
      emailAddress: emailAddress,
      isAdmin: isAdmin,
    );
  }

  factory ObjectWithPascalCaseKeys.fromJsonString(String input) {
    return ObjectWithPascalCaseKeys.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "CreatedAt": createdAt.toUtc().toIso8601String(),
      "DisplayName": displayName,
      "PhoneNumber": phoneNumber,
    };
    if (emailAddress != null) _output_["EmailAddress"] = emailAddress;
    if (isAdmin != null) _output_["IsAdmin"] = isAdmin;
    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("CreatedAt=${createdAt.toUtc().toIso8601String()}");
    _queryParts_.add("DisplayName=$displayName");
    _queryParts_.add("PhoneNumber=$phoneNumber");
    if (emailAddress != null) _queryParts_.add("EmailAddress=$emailAddress");
    if (isAdmin != null) _queryParts_.add("IsAdmin=$isAdmin");
    return _queryParts_.join("&");
  }

  ObjectWithPascalCaseKeys copyWith({
    DateTime? createdAt,
    String? displayName,
    String? Function()? phoneNumber,
    String? Function()? emailAddress,
    bool? Function()? isAdmin,
  }) {
    return ObjectWithPascalCaseKeys(
      createdAt: createdAt ?? this.createdAt,
      displayName: displayName ?? this.displayName,
      phoneNumber: phoneNumber != null ? phoneNumber() : this.phoneNumber,
      emailAddress: emailAddress != null ? emailAddress() : this.emailAddress,
      isAdmin: isAdmin != null ? isAdmin() : this.isAdmin,
    );
  }

  @override
  List<Object?> get props => [
        createdAt,
        displayName,
        phoneNumber,
        emailAddress,
        isAdmin,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithPascalCaseKeys &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithPascalCaseKeys ${toJsonString()}";
  }
}

class ObjectWithSnakeCaseKeys implements ArriModel {
  final DateTime createdAt;
  final String displayName;
  final String? phoneNumber;
  final String? emailAddress;
  final bool? isAdmin;
  const ObjectWithSnakeCaseKeys({
    required this.createdAt,
    required this.displayName,
    required this.phoneNumber,
    this.emailAddress,
    this.isAdmin,
  });

  factory ObjectWithSnakeCaseKeys.empty() {
    return ObjectWithSnakeCaseKeys(
      createdAt: DateTime.now(),
      displayName: "",
      phoneNumber: null,
    );
  }

  factory ObjectWithSnakeCaseKeys.fromJson(Map<String, dynamic> _input_) {
    final createdAt =
        dateTimeFromDynamic(_input_["created_at"], DateTime.now());
    final displayName = typeFromDynamic<String>(_input_["display_name"], "");
    final phoneNumber =
        nullableTypeFromDynamic<String>(_input_["phone_number"]);
    final emailAddress =
        nullableTypeFromDynamic<String>(_input_["email_address"]);
    final isAdmin = nullableTypeFromDynamic<bool>(_input_["is_admin"]);
    return ObjectWithSnakeCaseKeys(
      createdAt: createdAt,
      displayName: displayName,
      phoneNumber: phoneNumber,
      emailAddress: emailAddress,
      isAdmin: isAdmin,
    );
  }

  factory ObjectWithSnakeCaseKeys.fromJsonString(String input) {
    return ObjectWithSnakeCaseKeys.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "created_at": createdAt.toUtc().toIso8601String(),
      "display_name": displayName,
      "phone_number": phoneNumber,
    };
    if (emailAddress != null) _output_["email_address"] = emailAddress;
    if (isAdmin != null) _output_["is_admin"] = isAdmin;
    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("created_at=${createdAt.toUtc().toIso8601String()}");
    _queryParts_.add("display_name=$displayName");
    _queryParts_.add("phone_number=$phoneNumber");
    if (emailAddress != null) _queryParts_.add("email_address=$emailAddress");
    if (isAdmin != null) _queryParts_.add("is_admin=$isAdmin");
    return _queryParts_.join("&");
  }

  ObjectWithSnakeCaseKeys copyWith({
    DateTime? createdAt,
    String? displayName,
    String? Function()? phoneNumber,
    String? Function()? emailAddress,
    bool? Function()? isAdmin,
  }) {
    return ObjectWithSnakeCaseKeys(
      createdAt: createdAt ?? this.createdAt,
      displayName: displayName ?? this.displayName,
      phoneNumber: phoneNumber != null ? phoneNumber() : this.phoneNumber,
      emailAddress: emailAddress != null ? emailAddress() : this.emailAddress,
      isAdmin: isAdmin != null ? isAdmin() : this.isAdmin,
    );
  }

  @override
  List<Object?> get props => [
        createdAt,
        displayName,
        phoneNumber,
        emailAddress,
        isAdmin,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithSnakeCaseKeys &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithSnakeCaseKeys ${toJsonString()}";
  }
}

class ObjectWithEveryOptionalType implements ArriModel {
  final dynamic any;
  final bool? boolean;
  final String? string;
  final DateTime? timestamp;
  final double? float32;
  final double? float64;
  final int? int8;
  final int? uint8;
  final int? int16;
  final int? uint16;
  final int? int32;
  final int? uint32;
  final BigInt? int64;
  final BigInt? uint64;
  final ObjectWithEveryOptionalTypeEnumerator? enumerator;
  final List<bool>? array;
  final ObjectWithEveryOptionalTypeObject? object;
  final Map<String, BigInt>? record;
  final ObjectWithEveryOptionalTypeDiscriminator? discriminator;
  final ObjectWithEveryOptionalTypeNestedObject? nestedObject;
  final List<List<ObjectWithEveryOptionalTypeNestedArrayElementElement>>?
      nestedArray;
  const ObjectWithEveryOptionalType({
    this.any,
    this.boolean,
    this.string,
    this.timestamp,
    this.float32,
    this.float64,
    this.int8,
    this.uint8,
    this.int16,
    this.uint16,
    this.int32,
    this.uint32,
    this.int64,
    this.uint64,
    this.enumerator,
    this.array,
    this.object,
    this.record,
    this.discriminator,
    this.nestedObject,
    this.nestedArray,
  });

  factory ObjectWithEveryOptionalType.empty() {
    return ObjectWithEveryOptionalType();
  }

  factory ObjectWithEveryOptionalType.fromJson(Map<String, dynamic> _input_) {
    final any = _input_["any"];
    final boolean = nullableTypeFromDynamic<bool>(_input_["boolean"]);
    final string = nullableTypeFromDynamic<String>(_input_["string"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    final float32 = nullableDoubleFromDynamic(_input_["float32"]);
    final float64 = nullableDoubleFromDynamic(_input_["float64"]);
    final int8 = nullableIntFromDynamic(_input_["int8"]);
    final uint8 = nullableIntFromDynamic(_input_["uint8"]);
    final int16 = nullableIntFromDynamic(_input_["int16"]);
    final uint16 = nullableIntFromDynamic(_input_["uint16"]);
    final int32 = nullableIntFromDynamic(_input_["int32"]);
    final uint32 = nullableIntFromDynamic(_input_["uint32"]);
    final int64 = nullableBigIntFromDynamic(_input_["int64"]);
    final uint64 = nullableBigIntFromDynamic(_input_["uint64"]);
    final enumerator = _input_["enumerator"] is String
        ? ObjectWithEveryOptionalTypeEnumerator.fromString(
            _input_["enumerator"])
        : null;
    final array = _input_["array"] is List
        ? (_input_["array"] as List)
            .map((_el_) => typeFromDynamic<bool>(_el_, false))
            .toList()
        : null;
    final object = _input_["object"] is Map<String, dynamic>
        ? ObjectWithEveryOptionalTypeObject.fromJson(_input_["object"])
        : null;
    final record = _input_["record"] is Map<String, dynamic>
        ? (_input_["record"] as Map<String, dynamic>).map(
            (_key_, _val_) => MapEntry(
              _key_,
              bigIntFromDynamic(_val_, BigInt.zero),
            ),
          )
        : null;
    final discriminator = _input_["discriminator"] is Map<String, dynamic>
        ? ObjectWithEveryOptionalTypeDiscriminator.fromJson(
            _input_["discriminator"])
        : null;
    final nestedObject = _input_["nestedObject"] is Map<String, dynamic>
        ? ObjectWithEveryOptionalTypeNestedObject.fromJson(
            _input_["nestedObject"])
        : null;
    final nestedArray = _input_["nestedArray"] is List
        ? (_input_["nestedArray"] as List)
            .map((_el_) => _el_ is List
                ? (_el_ as List)
                    .map((_el_) => _el_ is Map<String, dynamic>
                        ? ObjectWithEveryOptionalTypeNestedArrayElementElement
                            .fromJson(_el_)
                        : ObjectWithEveryOptionalTypeNestedArrayElementElement
                            .empty())
                    .toList()
                : <ObjectWithEveryOptionalTypeNestedArrayElementElement>[])
            .toList()
        : null;
    return ObjectWithEveryOptionalType(
      any: any,
      boolean: boolean,
      string: string,
      timestamp: timestamp,
      float32: float32,
      float64: float64,
      int8: int8,
      uint8: uint8,
      int16: int16,
      uint16: uint16,
      int32: int32,
      uint32: uint32,
      int64: int64,
      uint64: uint64,
      enumerator: enumerator,
      array: array,
      object: object,
      record: record,
      discriminator: discriminator,
      nestedObject: nestedObject,
      nestedArray: nestedArray,
    );
  }

  factory ObjectWithEveryOptionalType.fromJsonString(String input) {
    return ObjectWithEveryOptionalType.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{};
    if (any != null) _output_["any"] = any;
    if (boolean != null) _output_["boolean"] = boolean;
    if (string != null) _output_["string"] = string;
    if (timestamp != null)
      _output_["timestamp"] = timestamp!.toUtc().toIso8601String();
    if (float32 != null) _output_["float32"] = float32;
    if (float64 != null) _output_["float64"] = float64;
    if (int8 != null) _output_["int8"] = int8;
    if (uint8 != null) _output_["uint8"] = uint8;
    if (int16 != null) _output_["int16"] = int16;
    if (uint16 != null) _output_["uint16"] = uint16;
    if (int32 != null) _output_["int32"] = int32;
    if (uint32 != null) _output_["uint32"] = uint32;
    if (int64 != null) _output_["int64"] = int64!.toString();
    if (uint64 != null) _output_["uint64"] = uint64!.toString();
    if (enumerator != null) _output_["enumerator"] = enumerator!.serialValue;
    if (array != null) _output_["array"] = array!.map((_el_) => _el_).toList();
    if (object != null) _output_["object"] = object!.toJson();
    if (record != null)
      _output_["record"] = record!.map(
        (_key_, _val_) => MapEntry(
          _key_,
          _val_.toString(),
        ),
      );
    if (discriminator != null)
      _output_["discriminator"] = discriminator!.toJson();
    if (nestedObject != null) _output_["nestedObject"] = nestedObject!.toJson();
    if (nestedArray != null)
      _output_["nestedArray"] = nestedArray!
          .map((_el_) => _el_.map((_el_) => _el_.toJson()).toList())
          .toList();
    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    print(
        "[WARNING] any's cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/any.");
    if (boolean != null) _queryParts_.add("boolean=$boolean");
    if (string != null) _queryParts_.add("string=$string");
    if (timestamp != null)
      _queryParts_.add("timestamp=${timestamp!.toUtc().toIso8601String()}");
    if (float32 != null) _queryParts_.add("float32=$float32");
    if (float64 != null) _queryParts_.add("float64=$float64");
    if (int8 != null) _queryParts_.add("int8=$int8");
    if (uint8 != null) _queryParts_.add("uint8=$uint8");
    if (int16 != null) _queryParts_.add("int16=$int16");
    if (uint16 != null) _queryParts_.add("uint16=$uint16");
    if (int32 != null) _queryParts_.add("int32=$int32");
    if (uint32 != null) _queryParts_.add("uint32=$uint32");
    if (int64 != null) _queryParts_.add("int64=$int64");
    if (uint64 != null) _queryParts_.add("uint64=$uint64");
    if (enumerator != null)
      _queryParts_.add("enumerator=${enumerator!.serialValue}");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/array.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/object.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/record.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/discriminator.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/nestedObject.");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/nestedArray.");
    return _queryParts_.join("&");
  }

  ObjectWithEveryOptionalType copyWith({
    dynamic Function()? any,
    bool? Function()? boolean,
    String? Function()? string,
    DateTime? Function()? timestamp,
    double? Function()? float32,
    double? Function()? float64,
    int? Function()? int8,
    int? Function()? uint8,
    int? Function()? int16,
    int? Function()? uint16,
    int? Function()? int32,
    int? Function()? uint32,
    BigInt? Function()? int64,
    BigInt? Function()? uint64,
    ObjectWithEveryOptionalTypeEnumerator? Function()? enumerator,
    List<bool>? Function()? array,
    ObjectWithEveryOptionalTypeObject? Function()? object,
    Map<String, BigInt>? Function()? record,
    ObjectWithEveryOptionalTypeDiscriminator? Function()? discriminator,
    ObjectWithEveryOptionalTypeNestedObject? Function()? nestedObject,
    List<List<ObjectWithEveryOptionalTypeNestedArrayElementElement>>?
            Function()?
        nestedArray,
  }) {
    return ObjectWithEveryOptionalType(
      any: any != null ? any() : this.any,
      boolean: boolean != null ? boolean() : this.boolean,
      string: string != null ? string() : this.string,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
      float32: float32 != null ? float32() : this.float32,
      float64: float64 != null ? float64() : this.float64,
      int8: int8 != null ? int8() : this.int8,
      uint8: uint8 != null ? uint8() : this.uint8,
      int16: int16 != null ? int16() : this.int16,
      uint16: uint16 != null ? uint16() : this.uint16,
      int32: int32 != null ? int32() : this.int32,
      uint32: uint32 != null ? uint32() : this.uint32,
      int64: int64 != null ? int64() : this.int64,
      uint64: uint64 != null ? uint64() : this.uint64,
      enumerator: enumerator != null ? enumerator() : this.enumerator,
      array: array != null ? array() : this.array,
      object: object != null ? object() : this.object,
      record: record != null ? record() : this.record,
      discriminator:
          discriminator != null ? discriminator() : this.discriminator,
      nestedObject: nestedObject != null ? nestedObject() : this.nestedObject,
      nestedArray: nestedArray != null ? nestedArray() : this.nestedArray,
    );
  }

  @override
  List<Object?> get props => [
        any,
        boolean,
        string,
        timestamp,
        float32,
        float64,
        int8,
        uint8,
        int16,
        uint16,
        int32,
        uint32,
        int64,
        uint64,
        enumerator,
        array,
        object,
        record,
        discriminator,
        nestedObject,
        nestedArray,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryOptionalType &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryOptionalType ${toJsonString()}";
  }
}

enum ObjectWithEveryOptionalTypeEnumerator
    implements Comparable<ObjectWithEveryOptionalTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const ObjectWithEveryOptionalTypeEnumerator(this.serialValue);
  final String serialValue;

  factory ObjectWithEveryOptionalTypeEnumerator.fromString(String input) {
    for (final val in values) {
      if (val.serialValue == input) {
        return val;
      }
    }
    return a;
  }

  @override
  int compareTo(ObjectWithEveryOptionalTypeEnumerator other) =>
      name.compareTo(other.name);
}

class ObjectWithEveryOptionalTypeObject implements ArriModel {
  final String string;
  final bool boolean;
  final DateTime timestamp;
  const ObjectWithEveryOptionalTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });

  factory ObjectWithEveryOptionalTypeObject.empty() {
    return ObjectWithEveryOptionalTypeObject(
      string: "",
      boolean: false,
      timestamp: DateTime.now(),
    );
  }

  factory ObjectWithEveryOptionalTypeObject.fromJson(
      Map<String, dynamic> _input_) {
    final string = typeFromDynamic<String>(_input_["string"], "");
    final boolean = typeFromDynamic<bool>(_input_["boolean"], false);
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    return ObjectWithEveryOptionalTypeObject(
      string: string,
      boolean: boolean,
      timestamp: timestamp,
    );
  }

  factory ObjectWithEveryOptionalTypeObject.fromJsonString(String input) {
    return ObjectWithEveryOptionalTypeObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("string=$string");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  ObjectWithEveryOptionalTypeObject copyWith({
    String? string,
    bool? boolean,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryOptionalTypeObject(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        string,
        boolean,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryOptionalTypeObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryOptionalTypeObject ${toJsonString()}";
  }
}

sealed class ObjectWithEveryOptionalTypeDiscriminator implements ArriModel {
  String get type;
  const ObjectWithEveryOptionalTypeDiscriminator();

  factory ObjectWithEveryOptionalTypeDiscriminator.empty() {
    return ObjectWithEveryOptionalTypeDiscriminatorA.empty();
  }

  factory ObjectWithEveryOptionalTypeDiscriminator.fromJson(
      Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "A":
        return ObjectWithEveryOptionalTypeDiscriminatorA.fromJson(_input_);
      case "B":
        return ObjectWithEveryOptionalTypeDiscriminatorB.fromJson(_input_);
      default:
        return ObjectWithEveryOptionalTypeDiscriminator.empty();
    }
  }

  factory ObjectWithEveryOptionalTypeDiscriminator.fromJsonString(
      String input) {
    return ObjectWithEveryOptionalTypeDiscriminator.fromJson(
        json.decode(input));
  }
}

class ObjectWithEveryOptionalTypeDiscriminatorA
    implements ObjectWithEveryOptionalTypeDiscriminator {
  final String title;
  const ObjectWithEveryOptionalTypeDiscriminatorA({
    required this.title,
  });

  @override
  String get type => "A";

  factory ObjectWithEveryOptionalTypeDiscriminatorA.empty() {
    return ObjectWithEveryOptionalTypeDiscriminatorA(
      title: "",
    );
  }

  factory ObjectWithEveryOptionalTypeDiscriminatorA.fromJson(
      Map<String, dynamic> _input_) {
    final title = typeFromDynamic<String>(_input_["title"], "");
    return ObjectWithEveryOptionalTypeDiscriminatorA(
      title: title,
    );
  }

  factory ObjectWithEveryOptionalTypeDiscriminatorA.fromJsonString(
      String input) {
    return ObjectWithEveryOptionalTypeDiscriminatorA.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    return _queryParts_.join("&");
  }

  ObjectWithEveryOptionalTypeDiscriminatorA copyWith({
    String? title,
  }) {
    return ObjectWithEveryOptionalTypeDiscriminatorA(
      title: title ?? this.title,
    );
  }

  @override
  List<Object?> get props => [
        title,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryOptionalTypeDiscriminatorA &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryOptionalTypeDiscriminatorA ${toJsonString()}";
  }
}

class ObjectWithEveryOptionalTypeDiscriminatorB
    implements ObjectWithEveryOptionalTypeDiscriminator {
  final String title;
  final String description;
  const ObjectWithEveryOptionalTypeDiscriminatorB({
    required this.title,
    required this.description,
  });

  @override
  String get type => "B";

  factory ObjectWithEveryOptionalTypeDiscriminatorB.empty() {
    return ObjectWithEveryOptionalTypeDiscriminatorB(
      title: "",
      description: "",
    );
  }

  factory ObjectWithEveryOptionalTypeDiscriminatorB.fromJson(
      Map<String, dynamic> _input_) {
    final title = typeFromDynamic<String>(_input_["title"], "");
    final description = typeFromDynamic<String>(_input_["description"], "");
    return ObjectWithEveryOptionalTypeDiscriminatorB(
      title: title,
      description: description,
    );
  }

  factory ObjectWithEveryOptionalTypeDiscriminatorB.fromJsonString(
      String input) {
    return ObjectWithEveryOptionalTypeDiscriminatorB.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    _queryParts_.add("description=$description");
    return _queryParts_.join("&");
  }

  ObjectWithEveryOptionalTypeDiscriminatorB copyWith({
    String? title,
    String? description,
  }) {
    return ObjectWithEveryOptionalTypeDiscriminatorB(
      title: title ?? this.title,
      description: description ?? this.description,
    );
  }

  @override
  List<Object?> get props => [
        title,
        description,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryOptionalTypeDiscriminatorB &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryOptionalTypeDiscriminatorB ${toJsonString()}";
  }
}

class ObjectWithEveryOptionalTypeNestedObject implements ArriModel {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryOptionalTypeNestedObjectData data;
  const ObjectWithEveryOptionalTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory ObjectWithEveryOptionalTypeNestedObject.empty() {
    return ObjectWithEveryOptionalTypeNestedObject(
      id: "",
      timestamp: DateTime.now(),
      data: ObjectWithEveryOptionalTypeNestedObjectData.empty(),
    );
  }

  factory ObjectWithEveryOptionalTypeNestedObject.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    final data = _input_["data"] is Map<String, dynamic>
        ? ObjectWithEveryOptionalTypeNestedObjectData.fromJson(_input_["data"])
        : ObjectWithEveryOptionalTypeNestedObjectData.empty();
    return ObjectWithEveryOptionalTypeNestedObject(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory ObjectWithEveryOptionalTypeNestedObject.fromJsonString(String input) {
    return ObjectWithEveryOptionalTypeNestedObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalTypeNestedObject/data.");
    return _queryParts_.join("&");
  }

  ObjectWithEveryOptionalTypeNestedObject copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryOptionalTypeNestedObjectData? data,
  }) {
    return ObjectWithEveryOptionalTypeNestedObject(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryOptionalTypeNestedObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryOptionalTypeNestedObject ${toJsonString()}";
  }
}

class ObjectWithEveryOptionalTypeNestedObjectData implements ArriModel {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryOptionalTypeNestedObjectDataData data;
  const ObjectWithEveryOptionalTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory ObjectWithEveryOptionalTypeNestedObjectData.empty() {
    return ObjectWithEveryOptionalTypeNestedObjectData(
      id: "",
      timestamp: DateTime.now(),
      data: ObjectWithEveryOptionalTypeNestedObjectDataData.empty(),
    );
  }

  factory ObjectWithEveryOptionalTypeNestedObjectData.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    final data = _input_["data"] is Map<String, dynamic>
        ? ObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
            _input_["data"])
        : ObjectWithEveryOptionalTypeNestedObjectDataData.empty();
    return ObjectWithEveryOptionalTypeNestedObjectData(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory ObjectWithEveryOptionalTypeNestedObjectData.fromJsonString(
      String input) {
    return ObjectWithEveryOptionalTypeNestedObjectData.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalTypeNestedObjectData/data.");
    return _queryParts_.join("&");
  }

  ObjectWithEveryOptionalTypeNestedObjectData copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryOptionalTypeNestedObjectDataData? data,
  }) {
    return ObjectWithEveryOptionalTypeNestedObjectData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryOptionalTypeNestedObjectData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryOptionalTypeNestedObjectData ${toJsonString()}";
  }
}

class ObjectWithEveryOptionalTypeNestedObjectDataData implements ArriModel {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryOptionalTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });

  factory ObjectWithEveryOptionalTypeNestedObjectDataData.empty() {
    return ObjectWithEveryOptionalTypeNestedObjectDataData(
      id: "",
      timestamp: DateTime.now(),
    );
  }

  factory ObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    return ObjectWithEveryOptionalTypeNestedObjectDataData(
      id: id,
      timestamp: timestamp,
    );
  }

  factory ObjectWithEveryOptionalTypeNestedObjectDataData.fromJsonString(
      String input) {
    return ObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  ObjectWithEveryOptionalTypeNestedObjectDataData copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryOptionalTypeNestedObjectDataData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryOptionalTypeNestedObjectDataData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryOptionalTypeNestedObjectDataData ${toJsonString()}";
  }
}

class ObjectWithEveryOptionalTypeNestedArrayElementElement
    implements ArriModel {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryOptionalTypeNestedArrayElementElement({
    required this.id,
    required this.timestamp,
  });

  factory ObjectWithEveryOptionalTypeNestedArrayElementElement.empty() {
    return ObjectWithEveryOptionalTypeNestedArrayElementElement(
      id: "",
      timestamp: DateTime.now(),
    );
  }

  factory ObjectWithEveryOptionalTypeNestedArrayElementElement.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    return ObjectWithEveryOptionalTypeNestedArrayElementElement(
      id: id,
      timestamp: timestamp,
    );
  }

  factory ObjectWithEveryOptionalTypeNestedArrayElementElement.fromJsonString(
      String input) {
    return ObjectWithEveryOptionalTypeNestedArrayElementElement.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  ObjectWithEveryOptionalTypeNestedArrayElementElement copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryOptionalTypeNestedArrayElementElement(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryOptionalTypeNestedArrayElementElement &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryOptionalTypeNestedArrayElementElement ${toJsonString()}";
  }
}

class RecursiveObject implements ArriModel {
  final RecursiveObject? left;
  final RecursiveObject? right;
  final String value;
  const RecursiveObject({
    required this.left,
    required this.right,
    required this.value,
  });

  factory RecursiveObject.empty() {
    return RecursiveObject(
      left: null,
      right: null,
      value: "",
    );
  }

  factory RecursiveObject.fromJson(Map<String, dynamic> _input_) {
    final left = _input_["left"] is Map<String, dynamic>
        ? RecursiveObject.fromJson(_input_["left"])
        : null;
    final right = _input_["right"] is Map<String, dynamic>
        ? RecursiveObject.fromJson(_input_["right"])
        : null;
    final value = typeFromDynamic<String>(_input_["value"], "");
    return RecursiveObject(
      left: left,
      right: right,
      value: value,
    );
  }

  factory RecursiveObject.fromJsonString(String input) {
    return RecursiveObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "left": left?.toJson(),
      "right": right?.toJson(),
      "value": value,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /RecursiveObject/left.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /RecursiveObject/right.");
    _queryParts_.add("value=$value");
    return _queryParts_.join("&");
  }

  RecursiveObject copyWith({
    RecursiveObject? Function()? left,
    RecursiveObject? Function()? right,
    String? value,
  }) {
    return RecursiveObject(
      left: left != null ? left() : this.left,
      right: right != null ? right() : this.right,
      value: value ?? this.value,
    );
  }

  @override
  List<Object?> get props => [
        left,
        right,
        value,
      ];

  @override
  bool operator ==(Object other) {
    return other is RecursiveObject && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "RecursiveObject ${toJsonString()}";
  }
}

sealed class RecursiveUnion implements ArriModel {
  String get type;
  const RecursiveUnion();

  factory RecursiveUnion.empty() {
    return RecursiveUnionChild.empty();
  }

  factory RecursiveUnion.fromJson(Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "CHILD":
        return RecursiveUnionChild.fromJson(_input_);
      case "CHILDREN":
        return RecursiveUnionChildren.fromJson(_input_);
      case "TEXT":
        return RecursiveUnionText.fromJson(_input_);
      case "SHAPE":
        return RecursiveUnionShape.fromJson(_input_);
      default:
        return RecursiveUnion.empty();
    }
  }

  factory RecursiveUnion.fromJsonString(String input) {
    return RecursiveUnion.fromJson(json.decode(input));
  }
}

/// Child node
class RecursiveUnionChild implements RecursiveUnion {
  final RecursiveUnion data;
  const RecursiveUnionChild({
    required this.data,
  });

  @override
  String get type => "CHILD";

  factory RecursiveUnionChild.empty() {
    return RecursiveUnionChild(
      data: RecursiveUnion.empty(),
    );
  }

  factory RecursiveUnionChild.fromJson(Map<String, dynamic> _input_) {
    final data = _input_["data"] is Map<String, dynamic>
        ? RecursiveUnion.fromJson(_input_["data"])
        : RecursiveUnion.empty();
    return RecursiveUnionChild(
      data: data,
    );
  }

  factory RecursiveUnionChild.fromJsonString(String input) {
    return RecursiveUnionChild.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /RecursiveUnionChild/data.");
    return _queryParts_.join("&");
  }

  RecursiveUnionChild copyWith({
    RecursiveUnion? data,
  }) {
    return RecursiveUnionChild(
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is RecursiveUnionChild && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "RecursiveUnionChild ${toJsonString()}";
  }
}

/// List of children node
class RecursiveUnionChildren implements RecursiveUnion {
  final List<RecursiveUnion> data;
  const RecursiveUnionChildren({
    required this.data,
  });

  @override
  String get type => "CHILDREN";

  factory RecursiveUnionChildren.empty() {
    return RecursiveUnionChildren(
      data: [],
    );
  }

  factory RecursiveUnionChildren.fromJson(Map<String, dynamic> _input_) {
    final data = _input_["data"] is List
        ? (_input_["data"] as List)
            .map((_el_) => _el_ is Map<String, dynamic>
                ? RecursiveUnion.fromJson(_el_)
                : RecursiveUnion.empty())
            .toList()
        : <RecursiveUnion>[];
    return RecursiveUnionChildren(
      data: data,
    );
  }

  factory RecursiveUnionChildren.fromJsonString(String input) {
    return RecursiveUnionChildren.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "data": data.map((_el_) => _el_.toJson()).toList(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /RecursiveUnionChildren/data.");
    return _queryParts_.join("&");
  }

  RecursiveUnionChildren copyWith({
    List<RecursiveUnion>? data,
  }) {
    return RecursiveUnionChildren(
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is RecursiveUnionChildren && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "RecursiveUnionChildren ${toJsonString()}";
  }
}

/// Text node
class RecursiveUnionText implements RecursiveUnion {
  final String data;
  const RecursiveUnionText({
    required this.data,
  });

  @override
  String get type => "TEXT";

  factory RecursiveUnionText.empty() {
    return RecursiveUnionText(
      data: "",
    );
  }

  factory RecursiveUnionText.fromJson(Map<String, dynamic> _input_) {
    final data = typeFromDynamic<String>(_input_["data"], "");
    return RecursiveUnionText(
      data: data,
    );
  }

  factory RecursiveUnionText.fromJsonString(String input) {
    return RecursiveUnionText.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "data": data,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("data=$data");
    return _queryParts_.join("&");
  }

  RecursiveUnionText copyWith({
    String? data,
  }) {
    return RecursiveUnionText(
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is RecursiveUnionText && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "RecursiveUnionText ${toJsonString()}";
  }
}

/// Shape node
class RecursiveUnionShape implements RecursiveUnion {
  final RecursiveUnionShapeData data;
  const RecursiveUnionShape({
    required this.data,
  });

  @override
  String get type => "SHAPE";

  factory RecursiveUnionShape.empty() {
    return RecursiveUnionShape(
      data: RecursiveUnionShapeData.empty(),
    );
  }

  factory RecursiveUnionShape.fromJson(Map<String, dynamic> _input_) {
    final data = _input_["data"] is Map<String, dynamic>
        ? RecursiveUnionShapeData.fromJson(_input_["data"])
        : RecursiveUnionShapeData.empty();
    return RecursiveUnionShape(
      data: data,
    );
  }

  factory RecursiveUnionShape.fromJsonString(String input) {
    return RecursiveUnionShape.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /RecursiveUnionShape/data.");
    return _queryParts_.join("&");
  }

  RecursiveUnionShape copyWith({
    RecursiveUnionShapeData? data,
  }) {
    return RecursiveUnionShape(
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is RecursiveUnionShape && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "RecursiveUnionShape ${toJsonString()}";
  }
}

class RecursiveUnionShapeData implements ArriModel {
  final double width;
  final double height;
  final String color;
  const RecursiveUnionShapeData({
    required this.width,
    required this.height,
    required this.color,
  });

  factory RecursiveUnionShapeData.empty() {
    return RecursiveUnionShapeData(
      width: 0.0,
      height: 0.0,
      color: "",
    );
  }

  factory RecursiveUnionShapeData.fromJson(Map<String, dynamic> _input_) {
    final width = doubleFromDynamic(_input_["width"], 0.0);
    final height = doubleFromDynamic(_input_["height"], 0.0);
    final color = typeFromDynamic<String>(_input_["color"], "");
    return RecursiveUnionShapeData(
      width: width,
      height: height,
      color: color,
    );
  }

  factory RecursiveUnionShapeData.fromJsonString(String input) {
    return RecursiveUnionShapeData.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "width": width,
      "height": height,
      "color": color,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("width=$width");
    _queryParts_.add("height=$height");
    _queryParts_.add("color=$color");
    return _queryParts_.join("&");
  }

  RecursiveUnionShapeData copyWith({
    double? width,
    double? height,
    String? color,
  }) {
    return RecursiveUnionShapeData(
      width: width ?? this.width,
      height: height ?? this.height,
      color: color ?? this.color,
    );
  }

  @override
  List<Object?> get props => [
        width,
        height,
        color,
      ];

  @override
  bool operator ==(Object other) {
    return other is RecursiveUnionShapeData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "RecursiveUnionShapeData ${toJsonString()}";
  }
}
