// this file was autogenerated by arri
// ignore_for_file: type=lint, unused_field, unnecessary_cast
import 'dart:async';
import 'dart:convert';
import 'package:arri_client/arri_client.dart';
import 'package:http/http.dart' as http;

class TestClient {
  final http.Client? _httpClient;
  final String _baseUrl;
  final String _clientVersion = "10";
  final FutureOr<Map<String, String>> Function()? _headers;
  final Function(Object)? _onError;
  TestClient({
    http.Client? httpClient,
    required String baseUrl,
    FutureOr<Map<String, String>> Function()? headers,
    Function(Object)? onError,
  })  : _httpClient = httpClient,
        _baseUrl = baseUrl,
        _headers = headers,
        _onError = onError;

  TestClientTestsService get tests => TestClientTestsService(
        baseUrl: _baseUrl,
        headers: _headers,
        httpClient: _httpClient,
        onError: _onError,
      );

  TestClientUsersService get users => TestClientUsersService(
        baseUrl: _baseUrl,
        headers: _headers,
        httpClient: _httpClient,
        onError: _onError,
      );
}

class TestClientTestsService {
  final http.Client? _httpClient;
  final String _baseUrl;
  final String _clientVersion = "10";
  final FutureOr<Map<String, String>> Function()? _headers;
  final Function(Object)? _onError;
  TestClientTestsService({
    http.Client? httpClient,
    required String baseUrl,
    FutureOr<Map<String, String>> Function()? headers,
    Function(Object)? onError,
  })  : _httpClient = httpClient,
        _baseUrl = baseUrl,
        _headers = headers,
        _onError = onError;

  Future<DefaultPayload> emptyParamsGetRequest() async {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/empty-params-get-request",
      method: HttpMethod.get,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      parser: (body) => DefaultPayload.fromJsonString(body),
      onError: _onError,
    );
  }

  Future<DefaultPayload> emptyParamsPostRequest() async {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/empty-params-post-request",
      method: HttpMethod.post,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      parser: (body) => DefaultPayload.fromJsonString(body),
      onError: _onError,
    );
  }

  Future<void> emptyResponseGetRequest(DefaultPayload params) async {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/empty-response-get-request",
      method: HttpMethod.get,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      params: params.toJson(),
      parser: (body) {},
      onError: _onError,
    );
  }

  Future<void> emptyResponsePostRequest(DefaultPayload params) async {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/empty-response-post-request",
      method: HttpMethod.post,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      params: params.toJson(),
      parser: (body) {},
      onError: _onError,
    );
  }

  /// If the target language supports it. Generated code should mark this procedure as deprecated.
  @deprecated
  Future<void> deprecatedRpc(DeprecatedRpcParams params) async {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/deprecated-rpc",
      method: HttpMethod.post,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      params: params.toJson(),
      parser: (body) {},
      onError: _onError,
    );
  }

  Future<DiscriminatorWithEmptyObject> sendDiscriminatorWithEmptyObject(
      DiscriminatorWithEmptyObject params) async {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/send-discriminator-with-empty-object",
      method: HttpMethod.post,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      params: params.toJson(),
      parser: (body) => DiscriminatorWithEmptyObject.fromJsonString(body),
      onError: _onError,
    );
  }

  Future<void> sendError(SendErrorParams params) async {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/send-error",
      method: HttpMethod.post,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      params: params.toJson(),
      parser: (body) {},
      onError: _onError,
    );
  }

  Future<ObjectWithEveryType> sendObject(ObjectWithEveryType params) async {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/send-object",
      method: HttpMethod.post,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      params: params.toJson(),
      parser: (body) => ObjectWithEveryType.fromJsonString(body),
      onError: _onError,
    );
  }

  Future<ObjectWithEveryNullableType> sendObjectWithNullableFields(
      ObjectWithEveryNullableType params) async {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/send-object-with-nullable-fields",
      method: HttpMethod.post,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      params: params.toJson(),
      parser: (body) => ObjectWithEveryNullableType.fromJsonString(body),
      onError: _onError,
    );
  }

  Future<ObjectWithPascalCaseKeys> sendObjectWithPascalCaseKeys(
      ObjectWithPascalCaseKeys params) async {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/send-object-with-pascal-case-keys",
      method: HttpMethod.post,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      params: params.toJson(),
      parser: (body) => ObjectWithPascalCaseKeys.fromJsonString(body),
      onError: _onError,
    );
  }

  Future<ObjectWithSnakeCaseKeys> sendObjectWithSnakeCaseKeys(
      ObjectWithSnakeCaseKeys params) async {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/send-object-with-snake-case-keys",
      method: HttpMethod.post,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      params: params.toJson(),
      parser: (body) => ObjectWithSnakeCaseKeys.fromJsonString(body),
      onError: _onError,
    );
  }

  Future<ObjectWithEveryOptionalType> sendPartialObject(
      ObjectWithEveryOptionalType params) async {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/send-partial-object",
      method: HttpMethod.post,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      params: params.toJson(),
      parser: (body) => ObjectWithEveryOptionalType.fromJsonString(body),
      onError: _onError,
    );
  }

  Future<RecursiveObject> sendRecursiveObject(RecursiveObject params) async {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/send-recursive-object",
      method: HttpMethod.post,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      params: params.toJson(),
      parser: (body) => RecursiveObject.fromJsonString(body),
      onError: _onError,
    );
  }

  Future<RecursiveUnion> sendRecursiveUnion(RecursiveUnion params) async {
    return parsedArriRequest(
      "$_baseUrl/rpcs/tests/send-recursive-union",
      method: HttpMethod.post,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      params: params.toJson(),
      parser: (body) => RecursiveUnion.fromJsonString(body),
      onError: _onError,
    );
  }

  EventSource<AutoReconnectResponse> streamAutoReconnect(
    AutoReconnectParams params, {
    void Function(AutoReconnectResponse data,
            EventSource<AutoReconnectResponse> connection)?
        onMessage,
    void Function(http.StreamedResponse response,
            EventSource<AutoReconnectResponse> connection)?
        onOpen,
    void Function(EventSource<AutoReconnectResponse> connection)? onClose,
    void Function(
            ArriError error, EventSource<AutoReconnectResponse> connection)?
        onError,
    Duration? retryDelay,
    int? maxRetryCount,
    String? lastEventId,
  }) {
    return parsedArriSseRequest(
      "$_baseUrl/rpcs/tests/stream-auto-reconnect",
      method: HttpMethod.get,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      retryDelay: retryDelay,
      maxRetryCount: maxRetryCount,
      lastEventId: lastEventId,
      params: params.toJson(),
      parser: (body) => AutoReconnectResponse.fromJsonString(body),
      onMessage: onMessage,
      onOpen: onOpen,
      onClose: onClose,
      onError: onError != null && _onError != null
          ? (err, es) {
              _onError.call(onError);
              return onError(err, es);
            }
          : onError != null
              ? onError
              : _onError != null
                  ? (err, _) => _onError.call(err)
                  : null,
    );
  }

  /// This route will always return an error. The client should automatically retry with exponential backoff.
  EventSource<StreamConnectionErrorTestResponse> streamConnectionErrorTest(
    StreamConnectionErrorTestParams params, {
    void Function(StreamConnectionErrorTestResponse data,
            EventSource<StreamConnectionErrorTestResponse> connection)?
        onMessage,
    void Function(http.StreamedResponse response,
            EventSource<StreamConnectionErrorTestResponse> connection)?
        onOpen,
    void Function(EventSource<StreamConnectionErrorTestResponse> connection)?
        onClose,
    void Function(ArriError error,
            EventSource<StreamConnectionErrorTestResponse> connection)?
        onError,
    Duration? retryDelay,
    int? maxRetryCount,
    String? lastEventId,
  }) {
    return parsedArriSseRequest(
      "$_baseUrl/rpcs/tests/stream-connection-error-test",
      method: HttpMethod.get,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      retryDelay: retryDelay,
      maxRetryCount: maxRetryCount,
      lastEventId: lastEventId,
      params: params.toJson(),
      parser: (body) => StreamConnectionErrorTestResponse.fromJsonString(body),
      onMessage: onMessage,
      onOpen: onOpen,
      onClose: onClose,
      onError: onError != null && _onError != null
          ? (err, es) {
              _onError.call(onError);
              return onError(err, es);
            }
          : onError != null
              ? onError
              : _onError != null
                  ? (err, _) => _onError.call(err)
                  : null,
    );
  }

  /// Test to ensure that the client can handle receiving streams of large objects. When objects are large messages will sometimes get sent in chunks. Meaning you have to handle receiving a partial message
  EventSource<StreamLargeObjectsResponse> streamLargeObjects({
    void Function(StreamLargeObjectsResponse data,
            EventSource<StreamLargeObjectsResponse> connection)?
        onMessage,
    void Function(http.StreamedResponse response,
            EventSource<StreamLargeObjectsResponse> connection)?
        onOpen,
    void Function(EventSource<StreamLargeObjectsResponse> connection)? onClose,
    void Function(ArriError error,
            EventSource<StreamLargeObjectsResponse> connection)?
        onError,
    Duration? retryDelay,
    int? maxRetryCount,
    String? lastEventId,
  }) {
    return parsedArriSseRequest(
      "$_baseUrl/rpcs/tests/stream-large-objects",
      method: HttpMethod.get,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      retryDelay: retryDelay,
      maxRetryCount: maxRetryCount,
      lastEventId: lastEventId,
      parser: (body) => StreamLargeObjectsResponse.fromJsonString(body),
      onMessage: onMessage,
      onOpen: onOpen,
      onClose: onClose,
      onError: onError != null && _onError != null
          ? (err, es) {
              _onError.call(onError);
              return onError(err, es);
            }
          : onError != null
              ? onError
              : _onError != null
                  ? (err, _) => _onError.call(err)
                  : null,
    );
  }

  EventSource<ChatMessage> streamMessages(
    ChatMessageParams params, {
    void Function(ChatMessage data, EventSource<ChatMessage> connection)?
        onMessage,
    void Function(http.StreamedResponse response,
            EventSource<ChatMessage> connection)?
        onOpen,
    void Function(EventSource<ChatMessage> connection)? onClose,
    void Function(ArriError error, EventSource<ChatMessage> connection)?
        onError,
    Duration? retryDelay,
    int? maxRetryCount,
    String? lastEventId,
  }) {
    return parsedArriSseRequest(
      "$_baseUrl/rpcs/tests/stream-messages",
      method: HttpMethod.get,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      retryDelay: retryDelay,
      maxRetryCount: maxRetryCount,
      lastEventId: lastEventId,
      params: params.toJson(),
      parser: (body) => ChatMessage.fromJsonString(body),
      onMessage: onMessage,
      onOpen: onOpen,
      onClose: onClose,
      onError: onError != null && _onError != null
          ? (err, es) {
              _onError.call(onError);
              return onError(err, es);
            }
          : onError != null
              ? onError
              : _onError != null
                  ? (err, _) => _onError.call(err)
                  : null,
    );
  }

  EventSource<TestsStreamRetryWithNewCredentialsResponse>
      streamRetryWithNewCredentials({
    void Function(TestsStreamRetryWithNewCredentialsResponse data,
            EventSource<TestsStreamRetryWithNewCredentialsResponse> connection)?
        onMessage,
    void Function(http.StreamedResponse response,
            EventSource<TestsStreamRetryWithNewCredentialsResponse> connection)?
        onOpen,
    void Function(
            EventSource<TestsStreamRetryWithNewCredentialsResponse> connection)?
        onClose,
    void Function(ArriError error,
            EventSource<TestsStreamRetryWithNewCredentialsResponse> connection)?
        onError,
    Duration? retryDelay,
    int? maxRetryCount,
    String? lastEventId,
  }) {
    return parsedArriSseRequest(
      "$_baseUrl/rpcs/tests/stream-retry-with-new-credentials",
      method: HttpMethod.get,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      retryDelay: retryDelay,
      maxRetryCount: maxRetryCount,
      lastEventId: lastEventId,
      parser: (body) =>
          TestsStreamRetryWithNewCredentialsResponse.fromJsonString(body),
      onMessage: onMessage,
      onOpen: onOpen,
      onClose: onClose,
      onError: onError != null && _onError != null
          ? (err, es) {
              _onError.call(onError);
              return onError(err, es);
            }
          : onError != null
              ? onError
              : _onError != null
                  ? (err, _) => _onError.call(err)
                  : null,
    );
  }

  /// When the client receives the 'done' event, it should close the connection and NOT reconnect
  EventSource<ChatMessage> streamTenEventsThenEnd({
    void Function(ChatMessage data, EventSource<ChatMessage> connection)?
        onMessage,
    void Function(http.StreamedResponse response,
            EventSource<ChatMessage> connection)?
        onOpen,
    void Function(EventSource<ChatMessage> connection)? onClose,
    void Function(ArriError error, EventSource<ChatMessage> connection)?
        onError,
    Duration? retryDelay,
    int? maxRetryCount,
    String? lastEventId,
  }) {
    return parsedArriSseRequest(
      "$_baseUrl/rpcs/tests/stream-ten-events-then-end",
      method: HttpMethod.get,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      retryDelay: retryDelay,
      maxRetryCount: maxRetryCount,
      lastEventId: lastEventId,
      parser: (body) => ChatMessage.fromJsonString(body),
      onMessage: onMessage,
      onOpen: onOpen,
      onClose: onClose,
      onError: onError != null && _onError != null
          ? (err, es) {
              _onError.call(onError);
              return onError(err, es);
            }
          : onError != null
              ? onError
              : _onError != null
                  ? (err, _) => _onError.call(err)
                  : null,
    );
  }
}

class TestClientUsersService {
  final http.Client? _httpClient;
  final String _baseUrl;
  final String _clientVersion = "10";
  final FutureOr<Map<String, String>> Function()? _headers;
  final Function(Object)? _onError;
  TestClientUsersService({
    http.Client? httpClient,
    required String baseUrl,
    FutureOr<Map<String, String>> Function()? headers,
    Function(Object)? onError,
  })  : _httpClient = httpClient,
        _baseUrl = baseUrl,
        _headers = headers,
        _onError = onError;

  EventSource<UsersWatchUserResponse> watchUser(
    UsersWatchUserParams params, {
    void Function(UsersWatchUserResponse data,
            EventSource<UsersWatchUserResponse> connection)?
        onMessage,
    void Function(http.StreamedResponse response,
            EventSource<UsersWatchUserResponse> connection)?
        onOpen,
    void Function(EventSource<UsersWatchUserResponse> connection)? onClose,
    void Function(
            ArriError error, EventSource<UsersWatchUserResponse> connection)?
        onError,
    Duration? retryDelay,
    int? maxRetryCount,
    String? lastEventId,
  }) {
    return parsedArriSseRequest(
      "$_baseUrl/rpcs/users/watch-user",
      method: HttpMethod.get,
      httpClient: _httpClient,
      headers: _headers,
      clientVersion: _clientVersion,
      retryDelay: retryDelay,
      maxRetryCount: maxRetryCount,
      lastEventId: lastEventId,
      params: params.toJson(),
      parser: (body) => UsersWatchUserResponse.fromJsonString(body),
      onMessage: onMessage,
      onOpen: onOpen,
      onClose: onClose,
      onError: onError != null && _onError != null
          ? (err, es) {
              _onError.call(onError);
              return onError(err, es);
            }
          : onError != null
              ? onError
              : _onError != null
                  ? (err, _) => _onError.call(err)
                  : null,
    );
  }
}

class ManuallyAddedModel implements ArriModel {
  final String hello;
  const ManuallyAddedModel({
    required this.hello,
  });

  factory ManuallyAddedModel.empty() {
    return ManuallyAddedModel(
      hello: "",
    );
  }

  factory ManuallyAddedModel.fromJson(Map<String, dynamic> _input_) {
    final hello = typeFromDynamic<String>(_input_["hello"], "");
    return ManuallyAddedModel(
      hello: hello,
    );
  }

  factory ManuallyAddedModel.fromJsonString(String input) {
    return ManuallyAddedModel.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "hello": hello,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("hello=$hello");
    return _queryParts_.join("&");
  }

  @override
  ManuallyAddedModel copyWith({
    String? hello,
  }) {
    return ManuallyAddedModel(
      hello: hello ?? this.hello,
    );
  }

  @override
  List<Object?> get props => [
        hello,
      ];

  @override
  bool operator ==(Object other) {
    return other is ManuallyAddedModel && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ManuallyAddedModel ${toJsonString()}";
  }
}

class DefaultPayload implements ArriModel {
  final String message;
  const DefaultPayload({
    required this.message,
  });

  factory DefaultPayload.empty() {
    return DefaultPayload(
      message: "",
    );
  }

  factory DefaultPayload.fromJson(Map<String, dynamic> _input_) {
    final message = typeFromDynamic<String>(_input_["message"], "");
    return DefaultPayload(
      message: message,
    );
  }

  factory DefaultPayload.fromJsonString(String input) {
    return DefaultPayload.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "message": message,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("message=$message");
    return _queryParts_.join("&");
  }

  @override
  DefaultPayload copyWith({
    String? message,
  }) {
    return DefaultPayload(
      message: message ?? this.message,
    );
  }

  @override
  List<Object?> get props => [
        message,
      ];

  @override
  bool operator ==(Object other) {
    return other is DefaultPayload && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "DefaultPayload ${toJsonString()}";
  }
}

@deprecated
class DeprecatedRpcParams implements ArriModel {
  @deprecated
  final String deprecatedField;
  const DeprecatedRpcParams({
    required this.deprecatedField,
  });

  factory DeprecatedRpcParams.empty() {
    return DeprecatedRpcParams(
      deprecatedField: "",
    );
  }

  factory DeprecatedRpcParams.fromJson(Map<String, dynamic> _input_) {
    final deprecatedField =
        typeFromDynamic<String>(_input_["deprecatedField"], "");
    return DeprecatedRpcParams(
      deprecatedField: deprecatedField,
    );
  }

  factory DeprecatedRpcParams.fromJsonString(String input) {
    return DeprecatedRpcParams.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "deprecatedField": deprecatedField,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("deprecatedField=$deprecatedField");
    return _queryParts_.join("&");
  }

  @override
  DeprecatedRpcParams copyWith({
    String? deprecatedField,
  }) {
    return DeprecatedRpcParams(
      deprecatedField: deprecatedField ?? this.deprecatedField,
    );
  }

  @override
  List<Object?> get props => [
        deprecatedField,
      ];

  @override
  bool operator ==(Object other) {
    return other is DeprecatedRpcParams && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "DeprecatedRpcParams ${toJsonString()}";
  }
}

sealed class DiscriminatorWithEmptyObject implements ArriModel {
  String get type;
  const DiscriminatorWithEmptyObject();

  factory DiscriminatorWithEmptyObject.empty() {
    return DiscriminatorWithEmptyObjectEmpty.empty();
  }

  factory DiscriminatorWithEmptyObject.fromJson(Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "EMPTY":
        return DiscriminatorWithEmptyObjectEmpty.fromJson(_input_);
      case "NOT_EMPTY":
        return DiscriminatorWithEmptyObjectNotEmpty.fromJson(_input_);
      default:
        return DiscriminatorWithEmptyObject.empty();
    }
  }

  factory DiscriminatorWithEmptyObject.fromJsonString(String input) {
    return DiscriminatorWithEmptyObject.fromJson(json.decode(input));
  }
}

class DiscriminatorWithEmptyObjectEmpty
    implements DiscriminatorWithEmptyObject {
  const DiscriminatorWithEmptyObjectEmpty();

  @override
  String get type => "EMPTY";

  factory DiscriminatorWithEmptyObjectEmpty.empty() {
    return DiscriminatorWithEmptyObjectEmpty();
  }

  factory DiscriminatorWithEmptyObjectEmpty.fromJson(
      Map<String, dynamic> _input_) {
    return DiscriminatorWithEmptyObjectEmpty();
  }

  factory DiscriminatorWithEmptyObjectEmpty.fromJsonString(String input) {
    return DiscriminatorWithEmptyObjectEmpty.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    return _queryParts_.join("&");
  }

  @override
  DiscriminatorWithEmptyObjectEmpty copyWith() {
    return DiscriminatorWithEmptyObjectEmpty();
  }

  @override
  List<Object?> get props => [];

  @override
  bool operator ==(Object other) {
    return other is DiscriminatorWithEmptyObjectEmpty &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "DiscriminatorWithEmptyObjectEmpty ${toJsonString()}";
  }
}

class DiscriminatorWithEmptyObjectNotEmpty
    implements DiscriminatorWithEmptyObject {
  final String foo;
  final double bar;
  final bool baz;
  const DiscriminatorWithEmptyObjectNotEmpty({
    required this.foo,
    required this.bar,
    required this.baz,
  });

  @override
  String get type => "NOT_EMPTY";

  factory DiscriminatorWithEmptyObjectNotEmpty.empty() {
    return DiscriminatorWithEmptyObjectNotEmpty(
      foo: "",
      bar: 0.0,
      baz: false,
    );
  }

  factory DiscriminatorWithEmptyObjectNotEmpty.fromJson(
      Map<String, dynamic> _input_) {
    final foo = typeFromDynamic<String>(_input_["foo"], "");
    final bar = doubleFromDynamic(_input_["bar"], 0.0);
    final baz = typeFromDynamic<bool>(_input_["baz"], false);
    return DiscriminatorWithEmptyObjectNotEmpty(
      foo: foo,
      bar: bar,
      baz: baz,
    );
  }

  factory DiscriminatorWithEmptyObjectNotEmpty.fromJsonString(String input) {
    return DiscriminatorWithEmptyObjectNotEmpty.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "foo": foo,
      "bar": bar,
      "baz": baz,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("foo=$foo");
    _queryParts_.add("bar=$bar");
    _queryParts_.add("baz=$baz");
    return _queryParts_.join("&");
  }

  @override
  DiscriminatorWithEmptyObjectNotEmpty copyWith({
    String? foo,
    double? bar,
    bool? baz,
  }) {
    return DiscriminatorWithEmptyObjectNotEmpty(
      foo: foo ?? this.foo,
      bar: bar ?? this.bar,
      baz: baz ?? this.baz,
    );
  }

  @override
  List<Object?> get props => [
        foo,
        bar,
        baz,
      ];

  @override
  bool operator ==(Object other) {
    return other is DiscriminatorWithEmptyObjectNotEmpty &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "DiscriminatorWithEmptyObjectNotEmpty ${toJsonString()}";
  }
}

class SendErrorParams implements ArriModel {
  final int code;
  final String message;
  const SendErrorParams({
    required this.code,
    required this.message,
  });

  factory SendErrorParams.empty() {
    return SendErrorParams(
      code: 0,
      message: "",
    );
  }

  factory SendErrorParams.fromJson(Map<String, dynamic> _input_) {
    final code = intFromDynamic(_input_["code"], 0);
    final message = typeFromDynamic<String>(_input_["message"], "");
    return SendErrorParams(
      code: code,
      message: message,
    );
  }

  factory SendErrorParams.fromJsonString(String input) {
    return SendErrorParams.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "code": code,
      "message": message,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("code=$code");
    _queryParts_.add("message=$message");
    return _queryParts_.join("&");
  }

  @override
  SendErrorParams copyWith({
    int? code,
    String? message,
  }) {
    return SendErrorParams(
      code: code ?? this.code,
      message: message ?? this.message,
    );
  }

  @override
  List<Object?> get props => [
        code,
        message,
      ];

  @override
  bool operator ==(Object other) {
    return other is SendErrorParams && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "SendErrorParams ${toJsonString()}";
  }
}

class ObjectWithEveryType implements ArriModel {
  final dynamic any;
  final bool boolean;
  final String string;
  final DateTime timestamp;
  final double float32;
  final double float64;
  final int int8;
  final int uint8;
  final int int16;
  final int uint16;
  final int int32;
  final int uint32;
  final BigInt int64;
  final BigInt uint64;
  final ObjectWithEveryTypeEnumerator enumerator;
  final List<bool> array;
  final ObjectWithEveryTypeObject object;
  final Map<String, BigInt> record;
  final ObjectWithEveryTypeDiscriminator discriminator;
  final ObjectWithEveryTypeNestedObject nestedObject;
  final List<List<ObjectWithEveryTypeNestedArrayElementElement>> nestedArray;
  const ObjectWithEveryType({
    required this.any,
    required this.boolean,
    required this.string,
    required this.timestamp,
    required this.float32,
    required this.float64,
    required this.int8,
    required this.uint8,
    required this.int16,
    required this.uint16,
    required this.int32,
    required this.uint32,
    required this.int64,
    required this.uint64,
    required this.enumerator,
    required this.array,
    required this.object,
    required this.record,
    required this.discriminator,
    required this.nestedObject,
    required this.nestedArray,
  });

  factory ObjectWithEveryType.empty() {
    return ObjectWithEveryType(
      any: null,
      boolean: false,
      string: "",
      timestamp: DateTime.now(),
      float32: 0.0,
      float64: 0.0,
      int8: 0,
      uint8: 0,
      int16: 0,
      uint16: 0,
      int32: 0,
      uint32: 0,
      int64: BigInt.zero,
      uint64: BigInt.zero,
      enumerator: ObjectWithEveryTypeEnumerator.a,
      array: [],
      object: ObjectWithEveryTypeObject.empty(),
      record: {},
      discriminator: ObjectWithEveryTypeDiscriminator.empty(),
      nestedObject: ObjectWithEveryTypeNestedObject.empty(),
      nestedArray: [],
    );
  }

  factory ObjectWithEveryType.fromJson(Map<String, dynamic> _input_) {
    final any = _input_["any"];
    final boolean = typeFromDynamic<bool>(_input_["boolean"], false);
    final string = typeFromDynamic<String>(_input_["string"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    final float32 = doubleFromDynamic(_input_["float32"], 0.0);
    final float64 = doubleFromDynamic(_input_["float64"], 0.0);
    final int8 = intFromDynamic(_input_["int8"], 0);
    final uint8 = intFromDynamic(_input_["uint8"], 0);
    final int16 = intFromDynamic(_input_["int16"], 0);
    final uint16 = intFromDynamic(_input_["uint16"], 0);
    final int32 = intFromDynamic(_input_["int32"], 0);
    final uint32 = intFromDynamic(_input_["uint32"], 0);
    final int64 = bigIntFromDynamic(_input_["int64"], BigInt.zero);
    final uint64 = bigIntFromDynamic(_input_["uint64"], BigInt.zero);
    final enumerator = ObjectWithEveryTypeEnumerator.fromString(
        typeFromDynamic<String>(_input_["enumerator"], ""));
    final array = _input_["array"] is List
        ? (_input_["array"] as List)
            .map((_el_) => typeFromDynamic<bool>(_el_, false))
            .toList()
        : <bool>[];
    final object = _input_["object"] is Map<String, dynamic>
        ? ObjectWithEveryTypeObject.fromJson(_input_["object"])
        : ObjectWithEveryTypeObject.empty();
    final record = _input_["record"] is Map<String, dynamic>
        ? (_input_["record"] as Map<String, dynamic>).map(
            (_key_, _val_) => MapEntry(
              _key_,
              bigIntFromDynamic(_val_, BigInt.zero),
            ),
          )
        : <String, BigInt>{};
    final discriminator = _input_["discriminator"] is Map<String, dynamic>
        ? ObjectWithEveryTypeDiscriminator.fromJson(_input_["discriminator"])
        : ObjectWithEveryTypeDiscriminator.empty();
    final nestedObject = _input_["nestedObject"] is Map<String, dynamic>
        ? ObjectWithEveryTypeNestedObject.fromJson(_input_["nestedObject"])
        : ObjectWithEveryTypeNestedObject.empty();
    final nestedArray = _input_["nestedArray"] is List
        ? (_input_["nestedArray"] as List)
            .map((_el_) => _el_ is List
                ? (_el_ as List)
                    .map((_el_) => _el_ is Map<String, dynamic>
                        ? ObjectWithEveryTypeNestedArrayElementElement.fromJson(
                            _el_)
                        : ObjectWithEveryTypeNestedArrayElementElement.empty())
                    .toList()
                : <ObjectWithEveryTypeNestedArrayElementElement>[])
            .toList()
        : <List<ObjectWithEveryTypeNestedArrayElementElement>>[];
    return ObjectWithEveryType(
      any: any,
      boolean: boolean,
      string: string,
      timestamp: timestamp,
      float32: float32,
      float64: float64,
      int8: int8,
      uint8: uint8,
      int16: int16,
      uint16: uint16,
      int32: int32,
      uint32: uint32,
      int64: int64,
      uint64: uint64,
      enumerator: enumerator,
      array: array,
      object: object,
      record: record,
      discriminator: discriminator,
      nestedObject: nestedObject,
      nestedArray: nestedArray,
    );
  }

  factory ObjectWithEveryType.fromJsonString(String input) {
    return ObjectWithEveryType.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "any": any,
      "boolean": boolean,
      "string": string,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "float32": float32,
      "float64": float64,
      "int8": int8,
      "uint8": uint8,
      "int16": int16,
      "uint16": uint16,
      "int32": int32,
      "uint32": uint32,
      "int64": int64.toString(),
      "uint64": uint64.toString(),
      "enumerator": enumerator.serialValue,
      "array": array.map((_el_) => _el_).toList(),
      "object": object.toJson(),
      "record": record.map(
        (_key_, _val_) => MapEntry(
          _key_,
          _val_.toString(),
        ),
      ),
      "discriminator": discriminator.toJson(),
      "nestedObject": nestedObject.toJson(),
      "nestedArray": nestedArray
          .map((_el_) => _el_.map((_el_) => _el_.toJson()).toList())
          .toList(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    print(
        "[WARNING] any's cannot be serialized to query params. Skipping field at /ObjectWithEveryType/any.");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("string=$string");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    _queryParts_.add("float32=$float32");
    _queryParts_.add("float64=$float64");
    _queryParts_.add("int8=$int8");
    _queryParts_.add("uint8=$uint8");
    _queryParts_.add("int16=$int16");
    _queryParts_.add("uint16=$uint16");
    _queryParts_.add("int32=$int32");
    _queryParts_.add("uint32=$uint32");
    _queryParts_.add("int64=$int64");
    _queryParts_.add("uint64=$uint64");
    _queryParts_.add("enumerator=${enumerator.serialValue}");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryType/array.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryType/object.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryType/record.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryType/discriminator.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryType/nestedObject.");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryType/nestedArray.");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryType copyWith({
    dynamic any,
    bool? boolean,
    String? string,
    DateTime? timestamp,
    double? float32,
    double? float64,
    int? int8,
    int? uint8,
    int? int16,
    int? uint16,
    int? int32,
    int? uint32,
    BigInt? int64,
    BigInt? uint64,
    ObjectWithEveryTypeEnumerator? enumerator,
    List<bool>? array,
    ObjectWithEveryTypeObject? object,
    Map<String, BigInt>? record,
    ObjectWithEveryTypeDiscriminator? discriminator,
    ObjectWithEveryTypeNestedObject? nestedObject,
    List<List<ObjectWithEveryTypeNestedArrayElementElement>>? nestedArray,
  }) {
    return ObjectWithEveryType(
      any: any ?? this.any,
      boolean: boolean ?? this.boolean,
      string: string ?? this.string,
      timestamp: timestamp ?? this.timestamp,
      float32: float32 ?? this.float32,
      float64: float64 ?? this.float64,
      int8: int8 ?? this.int8,
      uint8: uint8 ?? this.uint8,
      int16: int16 ?? this.int16,
      uint16: uint16 ?? this.uint16,
      int32: int32 ?? this.int32,
      uint32: uint32 ?? this.uint32,
      int64: int64 ?? this.int64,
      uint64: uint64 ?? this.uint64,
      enumerator: enumerator ?? this.enumerator,
      array: array ?? this.array,
      object: object ?? this.object,
      record: record ?? this.record,
      discriminator: discriminator ?? this.discriminator,
      nestedObject: nestedObject ?? this.nestedObject,
      nestedArray: nestedArray ?? this.nestedArray,
    );
  }

  @override
  List<Object?> get props => [
        any,
        boolean,
        string,
        timestamp,
        float32,
        float64,
        int8,
        uint8,
        int16,
        uint16,
        int32,
        uint32,
        int64,
        uint64,
        enumerator,
        array,
        object,
        record,
        discriminator,
        nestedObject,
        nestedArray,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryType && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryType ${toJsonString()}";
  }
}

enum ObjectWithEveryTypeEnumerator
    implements Comparable<ObjectWithEveryTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const ObjectWithEveryTypeEnumerator(this.serialValue);
  final String serialValue;

  factory ObjectWithEveryTypeEnumerator.fromString(String input) {
    for (final val in values) {
      if (val.serialValue == input) {
        return val;
      }
    }
    return a;
  }

  @override
  int compareTo(ObjectWithEveryTypeEnumerator other) =>
      name.compareTo(other.name);
}

class ObjectWithEveryTypeObject implements ArriModel {
  final String string;
  final bool boolean;
  final DateTime timestamp;
  const ObjectWithEveryTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });

  factory ObjectWithEveryTypeObject.empty() {
    return ObjectWithEveryTypeObject(
      string: "",
      boolean: false,
      timestamp: DateTime.now(),
    );
  }

  factory ObjectWithEveryTypeObject.fromJson(Map<String, dynamic> _input_) {
    final string = typeFromDynamic<String>(_input_["string"], "");
    final boolean = typeFromDynamic<bool>(_input_["boolean"], false);
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    return ObjectWithEveryTypeObject(
      string: string,
      boolean: boolean,
      timestamp: timestamp,
    );
  }

  factory ObjectWithEveryTypeObject.fromJsonString(String input) {
    return ObjectWithEveryTypeObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("string=$string");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryTypeObject copyWith({
    String? string,
    bool? boolean,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryTypeObject(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        string,
        boolean,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryTypeObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryTypeObject ${toJsonString()}";
  }
}

sealed class ObjectWithEveryTypeDiscriminator implements ArriModel {
  String get type;
  const ObjectWithEveryTypeDiscriminator();

  factory ObjectWithEveryTypeDiscriminator.empty() {
    return ObjectWithEveryTypeDiscriminatorA.empty();
  }

  factory ObjectWithEveryTypeDiscriminator.fromJson(
      Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "A":
        return ObjectWithEveryTypeDiscriminatorA.fromJson(_input_);
      case "B":
        return ObjectWithEveryTypeDiscriminatorB.fromJson(_input_);
      default:
        return ObjectWithEveryTypeDiscriminator.empty();
    }
  }

  factory ObjectWithEveryTypeDiscriminator.fromJsonString(String input) {
    return ObjectWithEveryTypeDiscriminator.fromJson(json.decode(input));
  }
}

class ObjectWithEveryTypeDiscriminatorA
    implements ObjectWithEveryTypeDiscriminator {
  final String title;
  const ObjectWithEveryTypeDiscriminatorA({
    required this.title,
  });

  @override
  String get type => "A";

  factory ObjectWithEveryTypeDiscriminatorA.empty() {
    return ObjectWithEveryTypeDiscriminatorA(
      title: "",
    );
  }

  factory ObjectWithEveryTypeDiscriminatorA.fromJson(
      Map<String, dynamic> _input_) {
    final title = typeFromDynamic<String>(_input_["title"], "");
    return ObjectWithEveryTypeDiscriminatorA(
      title: title,
    );
  }

  factory ObjectWithEveryTypeDiscriminatorA.fromJsonString(String input) {
    return ObjectWithEveryTypeDiscriminatorA.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryTypeDiscriminatorA copyWith({
    String? title,
  }) {
    return ObjectWithEveryTypeDiscriminatorA(
      title: title ?? this.title,
    );
  }

  @override
  List<Object?> get props => [
        title,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryTypeDiscriminatorA &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryTypeDiscriminatorA ${toJsonString()}";
  }
}

class ObjectWithEveryTypeDiscriminatorB
    implements ObjectWithEveryTypeDiscriminator {
  final String title;
  final String description;
  const ObjectWithEveryTypeDiscriminatorB({
    required this.title,
    required this.description,
  });

  @override
  String get type => "B";

  factory ObjectWithEveryTypeDiscriminatorB.empty() {
    return ObjectWithEveryTypeDiscriminatorB(
      title: "",
      description: "",
    );
  }

  factory ObjectWithEveryTypeDiscriminatorB.fromJson(
      Map<String, dynamic> _input_) {
    final title = typeFromDynamic<String>(_input_["title"], "");
    final description = typeFromDynamic<String>(_input_["description"], "");
    return ObjectWithEveryTypeDiscriminatorB(
      title: title,
      description: description,
    );
  }

  factory ObjectWithEveryTypeDiscriminatorB.fromJsonString(String input) {
    return ObjectWithEveryTypeDiscriminatorB.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    _queryParts_.add("description=$description");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryTypeDiscriminatorB copyWith({
    String? title,
    String? description,
  }) {
    return ObjectWithEveryTypeDiscriminatorB(
      title: title ?? this.title,
      description: description ?? this.description,
    );
  }

  @override
  List<Object?> get props => [
        title,
        description,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryTypeDiscriminatorB &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryTypeDiscriminatorB ${toJsonString()}";
  }
}

class ObjectWithEveryTypeNestedObject implements ArriModel {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryTypeNestedObjectData data;
  const ObjectWithEveryTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory ObjectWithEveryTypeNestedObject.empty() {
    return ObjectWithEveryTypeNestedObject(
      id: "",
      timestamp: DateTime.now(),
      data: ObjectWithEveryTypeNestedObjectData.empty(),
    );
  }

  factory ObjectWithEveryTypeNestedObject.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    final data = _input_["data"] is Map<String, dynamic>
        ? ObjectWithEveryTypeNestedObjectData.fromJson(_input_["data"])
        : ObjectWithEveryTypeNestedObjectData.empty();
    return ObjectWithEveryTypeNestedObject(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory ObjectWithEveryTypeNestedObject.fromJsonString(String input) {
    return ObjectWithEveryTypeNestedObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryTypeNestedObject/data.");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryTypeNestedObject copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryTypeNestedObjectData? data,
  }) {
    return ObjectWithEveryTypeNestedObject(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryTypeNestedObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryTypeNestedObject ${toJsonString()}";
  }
}

class ObjectWithEveryTypeNestedObjectData implements ArriModel {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryTypeNestedObjectDataData data;
  const ObjectWithEveryTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory ObjectWithEveryTypeNestedObjectData.empty() {
    return ObjectWithEveryTypeNestedObjectData(
      id: "",
      timestamp: DateTime.now(),
      data: ObjectWithEveryTypeNestedObjectDataData.empty(),
    );
  }

  factory ObjectWithEveryTypeNestedObjectData.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    final data = _input_["data"] is Map<String, dynamic>
        ? ObjectWithEveryTypeNestedObjectDataData.fromJson(_input_["data"])
        : ObjectWithEveryTypeNestedObjectDataData.empty();
    return ObjectWithEveryTypeNestedObjectData(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory ObjectWithEveryTypeNestedObjectData.fromJsonString(String input) {
    return ObjectWithEveryTypeNestedObjectData.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryTypeNestedObjectData/data.");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryTypeNestedObjectData copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryTypeNestedObjectDataData? data,
  }) {
    return ObjectWithEveryTypeNestedObjectData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryTypeNestedObjectData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryTypeNestedObjectData ${toJsonString()}";
  }
}

class ObjectWithEveryTypeNestedObjectDataData implements ArriModel {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });

  factory ObjectWithEveryTypeNestedObjectDataData.empty() {
    return ObjectWithEveryTypeNestedObjectDataData(
      id: "",
      timestamp: DateTime.now(),
    );
  }

  factory ObjectWithEveryTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    return ObjectWithEveryTypeNestedObjectDataData(
      id: id,
      timestamp: timestamp,
    );
  }

  factory ObjectWithEveryTypeNestedObjectDataData.fromJsonString(String input) {
    return ObjectWithEveryTypeNestedObjectDataData.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryTypeNestedObjectDataData copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryTypeNestedObjectDataData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryTypeNestedObjectDataData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryTypeNestedObjectDataData ${toJsonString()}";
  }
}

class ObjectWithEveryTypeNestedArrayElementElement implements ArriModel {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryTypeNestedArrayElementElement({
    required this.id,
    required this.timestamp,
  });

  factory ObjectWithEveryTypeNestedArrayElementElement.empty() {
    return ObjectWithEveryTypeNestedArrayElementElement(
      id: "",
      timestamp: DateTime.now(),
    );
  }

  factory ObjectWithEveryTypeNestedArrayElementElement.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    return ObjectWithEveryTypeNestedArrayElementElement(
      id: id,
      timestamp: timestamp,
    );
  }

  factory ObjectWithEveryTypeNestedArrayElementElement.fromJsonString(
      String input) {
    return ObjectWithEveryTypeNestedArrayElementElement.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryTypeNestedArrayElementElement copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryTypeNestedArrayElementElement(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryTypeNestedArrayElementElement &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryTypeNestedArrayElementElement ${toJsonString()}";
  }
}

class ObjectWithEveryNullableType implements ArriModel {
  final dynamic any;
  final bool? boolean;
  final String? string;
  final DateTime? timestamp;
  final double? float32;
  final double? float64;
  final int? int8;
  final int? uint8;
  final int? int16;
  final int? uint16;
  final int? int32;
  final int? uint32;
  final BigInt? int64;
  final BigInt? uint64;
  final ObjectWithEveryNullableTypeEnumerator? enumerator;
  final List<bool?>? array;
  final ObjectWithEveryNullableTypeObject? object;
  final Map<String, BigInt?>? record;
  final ObjectWithEveryNullableTypeDiscriminator? discriminator;
  final ObjectWithEveryNullableTypeNestedObject? nestedObject;
  final List<List<ObjectWithEveryNullableTypeNestedArrayElementElement?>?>?
      nestedArray;
  const ObjectWithEveryNullableType({
    required this.any,
    required this.boolean,
    required this.string,
    required this.timestamp,
    required this.float32,
    required this.float64,
    required this.int8,
    required this.uint8,
    required this.int16,
    required this.uint16,
    required this.int32,
    required this.uint32,
    required this.int64,
    required this.uint64,
    required this.enumerator,
    required this.array,
    required this.object,
    required this.record,
    required this.discriminator,
    required this.nestedObject,
    required this.nestedArray,
  });

  factory ObjectWithEveryNullableType.empty() {
    return ObjectWithEveryNullableType(
      any: null,
      boolean: null,
      string: null,
      timestamp: null,
      float32: null,
      float64: null,
      int8: null,
      uint8: null,
      int16: null,
      uint16: null,
      int32: null,
      uint32: null,
      int64: null,
      uint64: null,
      enumerator: null,
      array: null,
      object: null,
      record: null,
      discriminator: null,
      nestedObject: null,
      nestedArray: null,
    );
  }

  factory ObjectWithEveryNullableType.fromJson(Map<String, dynamic> _input_) {
    final any = _input_["any"];
    final boolean = nullableTypeFromDynamic<bool>(_input_["boolean"]);
    final string = nullableTypeFromDynamic<String>(_input_["string"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    final float32 = nullableDoubleFromDynamic(_input_["float32"]);
    final float64 = nullableDoubleFromDynamic(_input_["float64"]);
    final int8 = nullableIntFromDynamic(_input_["int8"]);
    final uint8 = nullableIntFromDynamic(_input_["uint8"]);
    final int16 = nullableIntFromDynamic(_input_["int16"]);
    final uint16 = nullableIntFromDynamic(_input_["uint16"]);
    final int32 = nullableIntFromDynamic(_input_["int32"]);
    final uint32 = nullableIntFromDynamic(_input_["uint32"]);
    final int64 = nullableBigIntFromDynamic(_input_["int64"]);
    final uint64 = nullableBigIntFromDynamic(_input_["uint64"]);
    final enumerator = _input_["enumerator"] is String
        ? ObjectWithEveryNullableTypeEnumerator.fromString(
            _input_["enumerator"])
        : null;
    final array = _input_["array"] is List
        ? (_input_["array"] as List)
            .map((_el_) => nullableTypeFromDynamic<bool>(_el_))
            .toList()
        : null;
    final object = _input_["object"] is Map<String, dynamic>
        ? ObjectWithEveryNullableTypeObject.fromJson(_input_["object"])
        : null;
    final record = _input_["record"] is Map<String, dynamic>
        ? (_input_["record"] as Map<String, dynamic>).map(
            (_key_, _val_) => MapEntry(
              _key_,
              nullableBigIntFromDynamic(_val_),
            ),
          )
        : null;
    final discriminator = _input_["discriminator"] is Map<String, dynamic>
        ? ObjectWithEveryNullableTypeDiscriminator.fromJson(
            _input_["discriminator"])
        : null;
    final nestedObject = _input_["nestedObject"] is Map<String, dynamic>
        ? ObjectWithEveryNullableTypeNestedObject.fromJson(
            _input_["nestedObject"])
        : null;
    final nestedArray = _input_["nestedArray"] is List
        ? (_input_["nestedArray"] as List)
            .map((_el_) => _el_ is List
                ? (_el_ as List)
                    .map((_el_) => _el_ is Map<String, dynamic>
                        ? ObjectWithEveryNullableTypeNestedArrayElementElement
                            .fromJson(_el_)
                        : null)
                    .toList()
                : null)
            .toList()
        : null;
    return ObjectWithEveryNullableType(
      any: any,
      boolean: boolean,
      string: string,
      timestamp: timestamp,
      float32: float32,
      float64: float64,
      int8: int8,
      uint8: uint8,
      int16: int16,
      uint16: uint16,
      int32: int32,
      uint32: uint32,
      int64: int64,
      uint64: uint64,
      enumerator: enumerator,
      array: array,
      object: object,
      record: record,
      discriminator: discriminator,
      nestedObject: nestedObject,
      nestedArray: nestedArray,
    );
  }

  factory ObjectWithEveryNullableType.fromJsonString(String input) {
    return ObjectWithEveryNullableType.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "any": any,
      "boolean": boolean,
      "string": string,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "float32": float32,
      "float64": float64,
      "int8": int8,
      "uint8": uint8,
      "int16": int16,
      "uint16": uint16,
      "int32": int32,
      "uint32": uint32,
      "int64": int64?.toString(),
      "uint64": uint64?.toString(),
      "enumerator": enumerator?.serialValue,
      "array": array?.map((_el_) => _el_).toList(),
      "object": object?.toJson(),
      "record": record?.map(
        (_key_, _val_) => MapEntry(
          _key_,
          _val_?.toString(),
        ),
      ),
      "discriminator": discriminator?.toJson(),
      "nestedObject": nestedObject?.toJson(),
      "nestedArray": nestedArray
          ?.map((_el_) => _el_?.map((_el_) => _el_?.toJson()).toList())
          .toList(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    print(
        "[WARNING] any's cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/any.");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("string=$string");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    _queryParts_.add("float32=$float32");
    _queryParts_.add("float64=$float64");
    _queryParts_.add("int8=$int8");
    _queryParts_.add("uint8=$uint8");
    _queryParts_.add("int16=$int16");
    _queryParts_.add("uint16=$uint16");
    _queryParts_.add("int32=$int32");
    _queryParts_.add("uint32=$uint32");
    _queryParts_.add("int64=$int64");
    _queryParts_.add("uint64=$uint64");
    _queryParts_.add("enumerator=${enumerator?.serialValue}");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/array.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/object.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/record.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/discriminator.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/nestedObject.");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/nestedArray.");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryNullableType copyWith({
    dynamic Function()? any,
    bool? Function()? boolean,
    String? Function()? string,
    DateTime? Function()? timestamp,
    double? Function()? float32,
    double? Function()? float64,
    int? Function()? int8,
    int? Function()? uint8,
    int? Function()? int16,
    int? Function()? uint16,
    int? Function()? int32,
    int? Function()? uint32,
    BigInt? Function()? int64,
    BigInt? Function()? uint64,
    ObjectWithEveryNullableTypeEnumerator? Function()? enumerator,
    List<bool?>? Function()? array,
    ObjectWithEveryNullableTypeObject? Function()? object,
    Map<String, BigInt?>? Function()? record,
    ObjectWithEveryNullableTypeDiscriminator? Function()? discriminator,
    ObjectWithEveryNullableTypeNestedObject? Function()? nestedObject,
    List<List<ObjectWithEveryNullableTypeNestedArrayElementElement?>?>?
            Function()?
        nestedArray,
  }) {
    return ObjectWithEveryNullableType(
      any: any != null ? any() : this.any,
      boolean: boolean != null ? boolean() : this.boolean,
      string: string != null ? string() : this.string,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
      float32: float32 != null ? float32() : this.float32,
      float64: float64 != null ? float64() : this.float64,
      int8: int8 != null ? int8() : this.int8,
      uint8: uint8 != null ? uint8() : this.uint8,
      int16: int16 != null ? int16() : this.int16,
      uint16: uint16 != null ? uint16() : this.uint16,
      int32: int32 != null ? int32() : this.int32,
      uint32: uint32 != null ? uint32() : this.uint32,
      int64: int64 != null ? int64() : this.int64,
      uint64: uint64 != null ? uint64() : this.uint64,
      enumerator: enumerator != null ? enumerator() : this.enumerator,
      array: array != null ? array() : this.array,
      object: object != null ? object() : this.object,
      record: record != null ? record() : this.record,
      discriminator:
          discriminator != null ? discriminator() : this.discriminator,
      nestedObject: nestedObject != null ? nestedObject() : this.nestedObject,
      nestedArray: nestedArray != null ? nestedArray() : this.nestedArray,
    );
  }

  @override
  List<Object?> get props => [
        any,
        boolean,
        string,
        timestamp,
        float32,
        float64,
        int8,
        uint8,
        int16,
        uint16,
        int32,
        uint32,
        int64,
        uint64,
        enumerator,
        array,
        object,
        record,
        discriminator,
        nestedObject,
        nestedArray,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryNullableType &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryNullableType ${toJsonString()}";
  }
}

enum ObjectWithEveryNullableTypeEnumerator
    implements Comparable<ObjectWithEveryNullableTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const ObjectWithEveryNullableTypeEnumerator(this.serialValue);
  final String serialValue;

  factory ObjectWithEveryNullableTypeEnumerator.fromString(String input) {
    for (final val in values) {
      if (val.serialValue == input) {
        return val;
      }
    }
    return a;
  }

  @override
  int compareTo(ObjectWithEveryNullableTypeEnumerator other) =>
      name.compareTo(other.name);
}

class ObjectWithEveryNullableTypeObject implements ArriModel {
  final String? string;
  final bool? boolean;
  final DateTime? timestamp;
  const ObjectWithEveryNullableTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });

  factory ObjectWithEveryNullableTypeObject.empty() {
    return ObjectWithEveryNullableTypeObject(
      string: null,
      boolean: null,
      timestamp: null,
    );
  }

  factory ObjectWithEveryNullableTypeObject.fromJson(
      Map<String, dynamic> _input_) {
    final string = nullableTypeFromDynamic<String>(_input_["string"]);
    final boolean = nullableTypeFromDynamic<bool>(_input_["boolean"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    return ObjectWithEveryNullableTypeObject(
      string: string,
      boolean: boolean,
      timestamp: timestamp,
    );
  }

  factory ObjectWithEveryNullableTypeObject.fromJsonString(String input) {
    return ObjectWithEveryNullableTypeObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("string=$string");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryNullableTypeObject copyWith({
    String? Function()? string,
    bool? Function()? boolean,
    DateTime? Function()? timestamp,
  }) {
    return ObjectWithEveryNullableTypeObject(
      string: string != null ? string() : this.string,
      boolean: boolean != null ? boolean() : this.boolean,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        string,
        boolean,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryNullableTypeObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryNullableTypeObject ${toJsonString()}";
  }
}

sealed class ObjectWithEveryNullableTypeDiscriminator implements ArriModel {
  String get type;
  const ObjectWithEveryNullableTypeDiscriminator();

  factory ObjectWithEveryNullableTypeDiscriminator.empty() {
    return ObjectWithEveryNullableTypeDiscriminatorA.empty();
  }

  factory ObjectWithEveryNullableTypeDiscriminator.fromJson(
      Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "A":
        return ObjectWithEveryNullableTypeDiscriminatorA.fromJson(_input_);
      case "B":
        return ObjectWithEveryNullableTypeDiscriminatorB.fromJson(_input_);
      default:
        return ObjectWithEveryNullableTypeDiscriminator.empty();
    }
  }

  factory ObjectWithEveryNullableTypeDiscriminator.fromJsonString(
      String input) {
    return ObjectWithEveryNullableTypeDiscriminator.fromJson(
        json.decode(input));
  }
}

class ObjectWithEveryNullableTypeDiscriminatorA
    implements ObjectWithEveryNullableTypeDiscriminator {
  final String? title;
  const ObjectWithEveryNullableTypeDiscriminatorA({
    required this.title,
  });

  @override
  String get type => "A";

  factory ObjectWithEveryNullableTypeDiscriminatorA.empty() {
    return ObjectWithEveryNullableTypeDiscriminatorA(
      title: null,
    );
  }

  factory ObjectWithEveryNullableTypeDiscriminatorA.fromJson(
      Map<String, dynamic> _input_) {
    final title = nullableTypeFromDynamic<String>(_input_["title"]);
    return ObjectWithEveryNullableTypeDiscriminatorA(
      title: title,
    );
  }

  factory ObjectWithEveryNullableTypeDiscriminatorA.fromJsonString(
      String input) {
    return ObjectWithEveryNullableTypeDiscriminatorA.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryNullableTypeDiscriminatorA copyWith({
    String? Function()? title,
  }) {
    return ObjectWithEveryNullableTypeDiscriminatorA(
      title: title != null ? title() : this.title,
    );
  }

  @override
  List<Object?> get props => [
        title,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryNullableTypeDiscriminatorA &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryNullableTypeDiscriminatorA ${toJsonString()}";
  }
}

class ObjectWithEveryNullableTypeDiscriminatorB
    implements ObjectWithEveryNullableTypeDiscriminator {
  final String? title;
  final String? description;
  const ObjectWithEveryNullableTypeDiscriminatorB({
    required this.title,
    required this.description,
  });

  @override
  String get type => "B";

  factory ObjectWithEveryNullableTypeDiscriminatorB.empty() {
    return ObjectWithEveryNullableTypeDiscriminatorB(
      title: null,
      description: null,
    );
  }

  factory ObjectWithEveryNullableTypeDiscriminatorB.fromJson(
      Map<String, dynamic> _input_) {
    final title = nullableTypeFromDynamic<String>(_input_["title"]);
    final description = nullableTypeFromDynamic<String>(_input_["description"]);
    return ObjectWithEveryNullableTypeDiscriminatorB(
      title: title,
      description: description,
    );
  }

  factory ObjectWithEveryNullableTypeDiscriminatorB.fromJsonString(
      String input) {
    return ObjectWithEveryNullableTypeDiscriminatorB.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    _queryParts_.add("description=$description");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryNullableTypeDiscriminatorB copyWith({
    String? Function()? title,
    String? Function()? description,
  }) {
    return ObjectWithEveryNullableTypeDiscriminatorB(
      title: title != null ? title() : this.title,
      description: description != null ? description() : this.description,
    );
  }

  @override
  List<Object?> get props => [
        title,
        description,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryNullableTypeDiscriminatorB &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryNullableTypeDiscriminatorB ${toJsonString()}";
  }
}

class ObjectWithEveryNullableTypeNestedObject implements ArriModel {
  final String? id;
  final DateTime? timestamp;
  final ObjectWithEveryNullableTypeNestedObjectData? data;
  const ObjectWithEveryNullableTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory ObjectWithEveryNullableTypeNestedObject.empty() {
    return ObjectWithEveryNullableTypeNestedObject(
      id: null,
      timestamp: null,
      data: null,
    );
  }

  factory ObjectWithEveryNullableTypeNestedObject.fromJson(
      Map<String, dynamic> _input_) {
    final id = nullableTypeFromDynamic<String>(_input_["id"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    final data = _input_["data"] is Map<String, dynamic>
        ? ObjectWithEveryNullableTypeNestedObjectData.fromJson(_input_["data"])
        : null;
    return ObjectWithEveryNullableTypeNestedObject(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory ObjectWithEveryNullableTypeNestedObject.fromJsonString(String input) {
    return ObjectWithEveryNullableTypeNestedObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "data": data?.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableTypeNestedObject/data.");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryNullableTypeNestedObject copyWith({
    String? Function()? id,
    DateTime? Function()? timestamp,
    ObjectWithEveryNullableTypeNestedObjectData? Function()? data,
  }) {
    return ObjectWithEveryNullableTypeNestedObject(
      id: id != null ? id() : this.id,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
      data: data != null ? data() : this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryNullableTypeNestedObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryNullableTypeNestedObject ${toJsonString()}";
  }
}

class ObjectWithEveryNullableTypeNestedObjectData implements ArriModel {
  final String? id;
  final DateTime? timestamp;
  final ObjectWithEveryNullableTypeNestedObjectDataData? data;
  const ObjectWithEveryNullableTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory ObjectWithEveryNullableTypeNestedObjectData.empty() {
    return ObjectWithEveryNullableTypeNestedObjectData(
      id: null,
      timestamp: null,
      data: null,
    );
  }

  factory ObjectWithEveryNullableTypeNestedObjectData.fromJson(
      Map<String, dynamic> _input_) {
    final id = nullableTypeFromDynamic<String>(_input_["id"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    final data = _input_["data"] is Map<String, dynamic>
        ? ObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
            _input_["data"])
        : null;
    return ObjectWithEveryNullableTypeNestedObjectData(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory ObjectWithEveryNullableTypeNestedObjectData.fromJsonString(
      String input) {
    return ObjectWithEveryNullableTypeNestedObjectData.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "data": data?.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableTypeNestedObjectData/data.");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryNullableTypeNestedObjectData copyWith({
    String? Function()? id,
    DateTime? Function()? timestamp,
    ObjectWithEveryNullableTypeNestedObjectDataData? Function()? data,
  }) {
    return ObjectWithEveryNullableTypeNestedObjectData(
      id: id != null ? id() : this.id,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
      data: data != null ? data() : this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryNullableTypeNestedObjectData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryNullableTypeNestedObjectData ${toJsonString()}";
  }
}

class ObjectWithEveryNullableTypeNestedObjectDataData implements ArriModel {
  final String? id;
  final DateTime? timestamp;
  const ObjectWithEveryNullableTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });

  factory ObjectWithEveryNullableTypeNestedObjectDataData.empty() {
    return ObjectWithEveryNullableTypeNestedObjectDataData(
      id: null,
      timestamp: null,
    );
  }

  factory ObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> _input_) {
    final id = nullableTypeFromDynamic<String>(_input_["id"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    return ObjectWithEveryNullableTypeNestedObjectDataData(
      id: id,
      timestamp: timestamp,
    );
  }

  factory ObjectWithEveryNullableTypeNestedObjectDataData.fromJsonString(
      String input) {
    return ObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryNullableTypeNestedObjectDataData copyWith({
    String? Function()? id,
    DateTime? Function()? timestamp,
  }) {
    return ObjectWithEveryNullableTypeNestedObjectDataData(
      id: id != null ? id() : this.id,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryNullableTypeNestedObjectDataData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryNullableTypeNestedObjectDataData ${toJsonString()}";
  }
}

class ObjectWithEveryNullableTypeNestedArrayElementElement
    implements ArriModel {
  final String? id;
  final DateTime? timestamp;
  const ObjectWithEveryNullableTypeNestedArrayElementElement({
    required this.id,
    required this.timestamp,
  });

  factory ObjectWithEveryNullableTypeNestedArrayElementElement.empty() {
    return ObjectWithEveryNullableTypeNestedArrayElementElement(
      id: null,
      timestamp: null,
    );
  }

  factory ObjectWithEveryNullableTypeNestedArrayElementElement.fromJson(
      Map<String, dynamic> _input_) {
    final id = nullableTypeFromDynamic<String>(_input_["id"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    return ObjectWithEveryNullableTypeNestedArrayElementElement(
      id: id,
      timestamp: timestamp,
    );
  }

  factory ObjectWithEveryNullableTypeNestedArrayElementElement.fromJsonString(
      String input) {
    return ObjectWithEveryNullableTypeNestedArrayElementElement.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryNullableTypeNestedArrayElementElement copyWith({
    String? Function()? id,
    DateTime? Function()? timestamp,
  }) {
    return ObjectWithEveryNullableTypeNestedArrayElementElement(
      id: id != null ? id() : this.id,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryNullableTypeNestedArrayElementElement &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryNullableTypeNestedArrayElementElement ${toJsonString()}";
  }
}

class ObjectWithPascalCaseKeys implements ArriModel {
  final DateTime createdAt;
  final String displayName;
  final String? phoneNumber;
  final String? emailAddress;
  final bool? isAdmin;
  const ObjectWithPascalCaseKeys({
    required this.createdAt,
    required this.displayName,
    required this.phoneNumber,
    this.emailAddress,
    this.isAdmin,
  });

  factory ObjectWithPascalCaseKeys.empty() {
    return ObjectWithPascalCaseKeys(
      createdAt: DateTime.now(),
      displayName: "",
      phoneNumber: null,
    );
  }

  factory ObjectWithPascalCaseKeys.fromJson(Map<String, dynamic> _input_) {
    final createdAt = dateTimeFromDynamic(_input_["CreatedAt"], DateTime.now());
    final displayName = typeFromDynamic<String>(_input_["DisplayName"], "");
    final phoneNumber = nullableTypeFromDynamic<String>(_input_["PhoneNumber"]);
    final emailAddress =
        nullableTypeFromDynamic<String>(_input_["EmailAddress"]);
    final isAdmin = nullableTypeFromDynamic<bool>(_input_["IsAdmin"]);
    return ObjectWithPascalCaseKeys(
      createdAt: createdAt,
      displayName: displayName,
      phoneNumber: phoneNumber,
      emailAddress: emailAddress,
      isAdmin: isAdmin,
    );
  }

  factory ObjectWithPascalCaseKeys.fromJsonString(String input) {
    return ObjectWithPascalCaseKeys.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "CreatedAt": createdAt.toUtc().toIso8601String(),
      "DisplayName": displayName,
      "PhoneNumber": phoneNumber,
    };
    if (emailAddress != null) _output_["EmailAddress"] = emailAddress;
    if (isAdmin != null) _output_["IsAdmin"] = isAdmin;
    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("CreatedAt=${createdAt.toUtc().toIso8601String()}");
    _queryParts_.add("DisplayName=$displayName");
    _queryParts_.add("PhoneNumber=$phoneNumber");
    if (emailAddress != null) _queryParts_.add("EmailAddress=$emailAddress");
    if (isAdmin != null) _queryParts_.add("IsAdmin=$isAdmin");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithPascalCaseKeys copyWith({
    DateTime? createdAt,
    String? displayName,
    String? Function()? phoneNumber,
    String? Function()? emailAddress,
    bool? Function()? isAdmin,
  }) {
    return ObjectWithPascalCaseKeys(
      createdAt: createdAt ?? this.createdAt,
      displayName: displayName ?? this.displayName,
      phoneNumber: phoneNumber != null ? phoneNumber() : this.phoneNumber,
      emailAddress: emailAddress != null ? emailAddress() : this.emailAddress,
      isAdmin: isAdmin != null ? isAdmin() : this.isAdmin,
    );
  }

  @override
  List<Object?> get props => [
        createdAt,
        displayName,
        phoneNumber,
        emailAddress,
        isAdmin,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithPascalCaseKeys &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithPascalCaseKeys ${toJsonString()}";
  }
}

class ObjectWithSnakeCaseKeys implements ArriModel {
  final DateTime createdAt;
  final String displayName;
  final String? phoneNumber;
  final String? emailAddress;
  final bool? isAdmin;
  const ObjectWithSnakeCaseKeys({
    required this.createdAt,
    required this.displayName,
    required this.phoneNumber,
    this.emailAddress,
    this.isAdmin,
  });

  factory ObjectWithSnakeCaseKeys.empty() {
    return ObjectWithSnakeCaseKeys(
      createdAt: DateTime.now(),
      displayName: "",
      phoneNumber: null,
    );
  }

  factory ObjectWithSnakeCaseKeys.fromJson(Map<String, dynamic> _input_) {
    final createdAt =
        dateTimeFromDynamic(_input_["created_at"], DateTime.now());
    final displayName = typeFromDynamic<String>(_input_["display_name"], "");
    final phoneNumber =
        nullableTypeFromDynamic<String>(_input_["phone_number"]);
    final emailAddress =
        nullableTypeFromDynamic<String>(_input_["email_address"]);
    final isAdmin = nullableTypeFromDynamic<bool>(_input_["is_admin"]);
    return ObjectWithSnakeCaseKeys(
      createdAt: createdAt,
      displayName: displayName,
      phoneNumber: phoneNumber,
      emailAddress: emailAddress,
      isAdmin: isAdmin,
    );
  }

  factory ObjectWithSnakeCaseKeys.fromJsonString(String input) {
    return ObjectWithSnakeCaseKeys.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "created_at": createdAt.toUtc().toIso8601String(),
      "display_name": displayName,
      "phone_number": phoneNumber,
    };
    if (emailAddress != null) _output_["email_address"] = emailAddress;
    if (isAdmin != null) _output_["is_admin"] = isAdmin;
    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("created_at=${createdAt.toUtc().toIso8601String()}");
    _queryParts_.add("display_name=$displayName");
    _queryParts_.add("phone_number=$phoneNumber");
    if (emailAddress != null) _queryParts_.add("email_address=$emailAddress");
    if (isAdmin != null) _queryParts_.add("is_admin=$isAdmin");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithSnakeCaseKeys copyWith({
    DateTime? createdAt,
    String? displayName,
    String? Function()? phoneNumber,
    String? Function()? emailAddress,
    bool? Function()? isAdmin,
  }) {
    return ObjectWithSnakeCaseKeys(
      createdAt: createdAt ?? this.createdAt,
      displayName: displayName ?? this.displayName,
      phoneNumber: phoneNumber != null ? phoneNumber() : this.phoneNumber,
      emailAddress: emailAddress != null ? emailAddress() : this.emailAddress,
      isAdmin: isAdmin != null ? isAdmin() : this.isAdmin,
    );
  }

  @override
  List<Object?> get props => [
        createdAt,
        displayName,
        phoneNumber,
        emailAddress,
        isAdmin,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithSnakeCaseKeys &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithSnakeCaseKeys ${toJsonString()}";
  }
}

class ObjectWithEveryOptionalType implements ArriModel {
  final dynamic any;
  final bool? boolean;
  final String? string;
  final DateTime? timestamp;
  final double? float32;
  final double? float64;
  final int? int8;
  final int? uint8;
  final int? int16;
  final int? uint16;
  final int? int32;
  final int? uint32;
  final BigInt? int64;
  final BigInt? uint64;
  final ObjectWithEveryOptionalTypeEnumerator? enumerator;
  final List<bool>? array;
  final ObjectWithEveryOptionalTypeObject? object;
  final Map<String, BigInt>? record;
  final ObjectWithEveryOptionalTypeDiscriminator? discriminator;
  final ObjectWithEveryOptionalTypeNestedObject? nestedObject;
  final List<List<ObjectWithEveryOptionalTypeNestedArrayElementElement>>?
      nestedArray;
  const ObjectWithEveryOptionalType({
    this.any,
    this.boolean,
    this.string,
    this.timestamp,
    this.float32,
    this.float64,
    this.int8,
    this.uint8,
    this.int16,
    this.uint16,
    this.int32,
    this.uint32,
    this.int64,
    this.uint64,
    this.enumerator,
    this.array,
    this.object,
    this.record,
    this.discriminator,
    this.nestedObject,
    this.nestedArray,
  });

  factory ObjectWithEveryOptionalType.empty() {
    return ObjectWithEveryOptionalType();
  }

  factory ObjectWithEveryOptionalType.fromJson(Map<String, dynamic> _input_) {
    final any = _input_["any"];
    final boolean = nullableTypeFromDynamic<bool>(_input_["boolean"]);
    final string = nullableTypeFromDynamic<String>(_input_["string"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    final float32 = nullableDoubleFromDynamic(_input_["float32"]);
    final float64 = nullableDoubleFromDynamic(_input_["float64"]);
    final int8 = nullableIntFromDynamic(_input_["int8"]);
    final uint8 = nullableIntFromDynamic(_input_["uint8"]);
    final int16 = nullableIntFromDynamic(_input_["int16"]);
    final uint16 = nullableIntFromDynamic(_input_["uint16"]);
    final int32 = nullableIntFromDynamic(_input_["int32"]);
    final uint32 = nullableIntFromDynamic(_input_["uint32"]);
    final int64 = nullableBigIntFromDynamic(_input_["int64"]);
    final uint64 = nullableBigIntFromDynamic(_input_["uint64"]);
    final enumerator = _input_["enumerator"] is String
        ? ObjectWithEveryOptionalTypeEnumerator.fromString(
            _input_["enumerator"])
        : null;
    final array = _input_["array"] is List
        ? (_input_["array"] as List)
            .map((_el_) => typeFromDynamic<bool>(_el_, false))
            .toList()
        : null;
    final object = _input_["object"] is Map<String, dynamic>
        ? ObjectWithEveryOptionalTypeObject.fromJson(_input_["object"])
        : null;
    final record = _input_["record"] is Map<String, dynamic>
        ? (_input_["record"] as Map<String, dynamic>).map(
            (_key_, _val_) => MapEntry(
              _key_,
              bigIntFromDynamic(_val_, BigInt.zero),
            ),
          )
        : null;
    final discriminator = _input_["discriminator"] is Map<String, dynamic>
        ? ObjectWithEveryOptionalTypeDiscriminator.fromJson(
            _input_["discriminator"])
        : null;
    final nestedObject = _input_["nestedObject"] is Map<String, dynamic>
        ? ObjectWithEveryOptionalTypeNestedObject.fromJson(
            _input_["nestedObject"])
        : null;
    final nestedArray = _input_["nestedArray"] is List
        ? (_input_["nestedArray"] as List)
            .map((_el_) => _el_ is List
                ? (_el_ as List)
                    .map((_el_) => _el_ is Map<String, dynamic>
                        ? ObjectWithEveryOptionalTypeNestedArrayElementElement
                            .fromJson(_el_)
                        : ObjectWithEveryOptionalTypeNestedArrayElementElement
                            .empty())
                    .toList()
                : <ObjectWithEveryOptionalTypeNestedArrayElementElement>[])
            .toList()
        : null;
    return ObjectWithEveryOptionalType(
      any: any,
      boolean: boolean,
      string: string,
      timestamp: timestamp,
      float32: float32,
      float64: float64,
      int8: int8,
      uint8: uint8,
      int16: int16,
      uint16: uint16,
      int32: int32,
      uint32: uint32,
      int64: int64,
      uint64: uint64,
      enumerator: enumerator,
      array: array,
      object: object,
      record: record,
      discriminator: discriminator,
      nestedObject: nestedObject,
      nestedArray: nestedArray,
    );
  }

  factory ObjectWithEveryOptionalType.fromJsonString(String input) {
    return ObjectWithEveryOptionalType.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{};
    if (any != null) _output_["any"] = any;
    if (boolean != null) _output_["boolean"] = boolean;
    if (string != null) _output_["string"] = string;
    if (timestamp != null)
      _output_["timestamp"] = timestamp!.toUtc().toIso8601String();
    if (float32 != null) _output_["float32"] = float32;
    if (float64 != null) _output_["float64"] = float64;
    if (int8 != null) _output_["int8"] = int8;
    if (uint8 != null) _output_["uint8"] = uint8;
    if (int16 != null) _output_["int16"] = int16;
    if (uint16 != null) _output_["uint16"] = uint16;
    if (int32 != null) _output_["int32"] = int32;
    if (uint32 != null) _output_["uint32"] = uint32;
    if (int64 != null) _output_["int64"] = int64!.toString();
    if (uint64 != null) _output_["uint64"] = uint64!.toString();
    if (enumerator != null) _output_["enumerator"] = enumerator!.serialValue;
    if (array != null) _output_["array"] = array!.map((_el_) => _el_).toList();
    if (object != null) _output_["object"] = object!.toJson();
    if (record != null)
      _output_["record"] = record!.map(
        (_key_, _val_) => MapEntry(
          _key_,
          _val_.toString(),
        ),
      );
    if (discriminator != null)
      _output_["discriminator"] = discriminator!.toJson();
    if (nestedObject != null) _output_["nestedObject"] = nestedObject!.toJson();
    if (nestedArray != null)
      _output_["nestedArray"] = nestedArray!
          .map((_el_) => _el_.map((_el_) => _el_.toJson()).toList())
          .toList();
    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    print(
        "[WARNING] any's cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/any.");
    if (boolean != null) _queryParts_.add("boolean=$boolean");
    if (string != null) _queryParts_.add("string=$string");
    if (timestamp != null)
      _queryParts_.add("timestamp=${timestamp!.toUtc().toIso8601String()}");
    if (float32 != null) _queryParts_.add("float32=$float32");
    if (float64 != null) _queryParts_.add("float64=$float64");
    if (int8 != null) _queryParts_.add("int8=$int8");
    if (uint8 != null) _queryParts_.add("uint8=$uint8");
    if (int16 != null) _queryParts_.add("int16=$int16");
    if (uint16 != null) _queryParts_.add("uint16=$uint16");
    if (int32 != null) _queryParts_.add("int32=$int32");
    if (uint32 != null) _queryParts_.add("uint32=$uint32");
    if (int64 != null) _queryParts_.add("int64=$int64");
    if (uint64 != null) _queryParts_.add("uint64=$uint64");
    if (enumerator != null)
      _queryParts_.add("enumerator=${enumerator!.serialValue}");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/array.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/object.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/record.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/discriminator.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/nestedObject.");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/nestedArray.");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryOptionalType copyWith({
    dynamic Function()? any,
    bool? Function()? boolean,
    String? Function()? string,
    DateTime? Function()? timestamp,
    double? Function()? float32,
    double? Function()? float64,
    int? Function()? int8,
    int? Function()? uint8,
    int? Function()? int16,
    int? Function()? uint16,
    int? Function()? int32,
    int? Function()? uint32,
    BigInt? Function()? int64,
    BigInt? Function()? uint64,
    ObjectWithEveryOptionalTypeEnumerator? Function()? enumerator,
    List<bool>? Function()? array,
    ObjectWithEveryOptionalTypeObject? Function()? object,
    Map<String, BigInt>? Function()? record,
    ObjectWithEveryOptionalTypeDiscriminator? Function()? discriminator,
    ObjectWithEveryOptionalTypeNestedObject? Function()? nestedObject,
    List<List<ObjectWithEveryOptionalTypeNestedArrayElementElement>>?
            Function()?
        nestedArray,
  }) {
    return ObjectWithEveryOptionalType(
      any: any != null ? any() : this.any,
      boolean: boolean != null ? boolean() : this.boolean,
      string: string != null ? string() : this.string,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
      float32: float32 != null ? float32() : this.float32,
      float64: float64 != null ? float64() : this.float64,
      int8: int8 != null ? int8() : this.int8,
      uint8: uint8 != null ? uint8() : this.uint8,
      int16: int16 != null ? int16() : this.int16,
      uint16: uint16 != null ? uint16() : this.uint16,
      int32: int32 != null ? int32() : this.int32,
      uint32: uint32 != null ? uint32() : this.uint32,
      int64: int64 != null ? int64() : this.int64,
      uint64: uint64 != null ? uint64() : this.uint64,
      enumerator: enumerator != null ? enumerator() : this.enumerator,
      array: array != null ? array() : this.array,
      object: object != null ? object() : this.object,
      record: record != null ? record() : this.record,
      discriminator:
          discriminator != null ? discriminator() : this.discriminator,
      nestedObject: nestedObject != null ? nestedObject() : this.nestedObject,
      nestedArray: nestedArray != null ? nestedArray() : this.nestedArray,
    );
  }

  @override
  List<Object?> get props => [
        any,
        boolean,
        string,
        timestamp,
        float32,
        float64,
        int8,
        uint8,
        int16,
        uint16,
        int32,
        uint32,
        int64,
        uint64,
        enumerator,
        array,
        object,
        record,
        discriminator,
        nestedObject,
        nestedArray,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryOptionalType &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryOptionalType ${toJsonString()}";
  }
}

enum ObjectWithEveryOptionalTypeEnumerator
    implements Comparable<ObjectWithEveryOptionalTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const ObjectWithEveryOptionalTypeEnumerator(this.serialValue);
  final String serialValue;

  factory ObjectWithEveryOptionalTypeEnumerator.fromString(String input) {
    for (final val in values) {
      if (val.serialValue == input) {
        return val;
      }
    }
    return a;
  }

  @override
  int compareTo(ObjectWithEveryOptionalTypeEnumerator other) =>
      name.compareTo(other.name);
}

class ObjectWithEveryOptionalTypeObject implements ArriModel {
  final String string;
  final bool boolean;
  final DateTime timestamp;
  const ObjectWithEveryOptionalTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });

  factory ObjectWithEveryOptionalTypeObject.empty() {
    return ObjectWithEveryOptionalTypeObject(
      string: "",
      boolean: false,
      timestamp: DateTime.now(),
    );
  }

  factory ObjectWithEveryOptionalTypeObject.fromJson(
      Map<String, dynamic> _input_) {
    final string = typeFromDynamic<String>(_input_["string"], "");
    final boolean = typeFromDynamic<bool>(_input_["boolean"], false);
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    return ObjectWithEveryOptionalTypeObject(
      string: string,
      boolean: boolean,
      timestamp: timestamp,
    );
  }

  factory ObjectWithEveryOptionalTypeObject.fromJsonString(String input) {
    return ObjectWithEveryOptionalTypeObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("string=$string");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryOptionalTypeObject copyWith({
    String? string,
    bool? boolean,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryOptionalTypeObject(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        string,
        boolean,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryOptionalTypeObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryOptionalTypeObject ${toJsonString()}";
  }
}

sealed class ObjectWithEveryOptionalTypeDiscriminator implements ArriModel {
  String get type;
  const ObjectWithEveryOptionalTypeDiscriminator();

  factory ObjectWithEveryOptionalTypeDiscriminator.empty() {
    return ObjectWithEveryOptionalTypeDiscriminatorA.empty();
  }

  factory ObjectWithEveryOptionalTypeDiscriminator.fromJson(
      Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "A":
        return ObjectWithEveryOptionalTypeDiscriminatorA.fromJson(_input_);
      case "B":
        return ObjectWithEveryOptionalTypeDiscriminatorB.fromJson(_input_);
      default:
        return ObjectWithEveryOptionalTypeDiscriminator.empty();
    }
  }

  factory ObjectWithEveryOptionalTypeDiscriminator.fromJsonString(
      String input) {
    return ObjectWithEveryOptionalTypeDiscriminator.fromJson(
        json.decode(input));
  }
}

class ObjectWithEveryOptionalTypeDiscriminatorA
    implements ObjectWithEveryOptionalTypeDiscriminator {
  final String title;
  const ObjectWithEveryOptionalTypeDiscriminatorA({
    required this.title,
  });

  @override
  String get type => "A";

  factory ObjectWithEveryOptionalTypeDiscriminatorA.empty() {
    return ObjectWithEveryOptionalTypeDiscriminatorA(
      title: "",
    );
  }

  factory ObjectWithEveryOptionalTypeDiscriminatorA.fromJson(
      Map<String, dynamic> _input_) {
    final title = typeFromDynamic<String>(_input_["title"], "");
    return ObjectWithEveryOptionalTypeDiscriminatorA(
      title: title,
    );
  }

  factory ObjectWithEveryOptionalTypeDiscriminatorA.fromJsonString(
      String input) {
    return ObjectWithEveryOptionalTypeDiscriminatorA.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryOptionalTypeDiscriminatorA copyWith({
    String? title,
  }) {
    return ObjectWithEveryOptionalTypeDiscriminatorA(
      title: title ?? this.title,
    );
  }

  @override
  List<Object?> get props => [
        title,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryOptionalTypeDiscriminatorA &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryOptionalTypeDiscriminatorA ${toJsonString()}";
  }
}

class ObjectWithEveryOptionalTypeDiscriminatorB
    implements ObjectWithEveryOptionalTypeDiscriminator {
  final String title;
  final String description;
  const ObjectWithEveryOptionalTypeDiscriminatorB({
    required this.title,
    required this.description,
  });

  @override
  String get type => "B";

  factory ObjectWithEveryOptionalTypeDiscriminatorB.empty() {
    return ObjectWithEveryOptionalTypeDiscriminatorB(
      title: "",
      description: "",
    );
  }

  factory ObjectWithEveryOptionalTypeDiscriminatorB.fromJson(
      Map<String, dynamic> _input_) {
    final title = typeFromDynamic<String>(_input_["title"], "");
    final description = typeFromDynamic<String>(_input_["description"], "");
    return ObjectWithEveryOptionalTypeDiscriminatorB(
      title: title,
      description: description,
    );
  }

  factory ObjectWithEveryOptionalTypeDiscriminatorB.fromJsonString(
      String input) {
    return ObjectWithEveryOptionalTypeDiscriminatorB.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    _queryParts_.add("description=$description");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryOptionalTypeDiscriminatorB copyWith({
    String? title,
    String? description,
  }) {
    return ObjectWithEveryOptionalTypeDiscriminatorB(
      title: title ?? this.title,
      description: description ?? this.description,
    );
  }

  @override
  List<Object?> get props => [
        title,
        description,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryOptionalTypeDiscriminatorB &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryOptionalTypeDiscriminatorB ${toJsonString()}";
  }
}

class ObjectWithEveryOptionalTypeNestedObject implements ArriModel {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryOptionalTypeNestedObjectData data;
  const ObjectWithEveryOptionalTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory ObjectWithEveryOptionalTypeNestedObject.empty() {
    return ObjectWithEveryOptionalTypeNestedObject(
      id: "",
      timestamp: DateTime.now(),
      data: ObjectWithEveryOptionalTypeNestedObjectData.empty(),
    );
  }

  factory ObjectWithEveryOptionalTypeNestedObject.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    final data = _input_["data"] is Map<String, dynamic>
        ? ObjectWithEveryOptionalTypeNestedObjectData.fromJson(_input_["data"])
        : ObjectWithEveryOptionalTypeNestedObjectData.empty();
    return ObjectWithEveryOptionalTypeNestedObject(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory ObjectWithEveryOptionalTypeNestedObject.fromJsonString(String input) {
    return ObjectWithEveryOptionalTypeNestedObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalTypeNestedObject/data.");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryOptionalTypeNestedObject copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryOptionalTypeNestedObjectData? data,
  }) {
    return ObjectWithEveryOptionalTypeNestedObject(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryOptionalTypeNestedObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryOptionalTypeNestedObject ${toJsonString()}";
  }
}

class ObjectWithEveryOptionalTypeNestedObjectData implements ArriModel {
  final String id;
  final DateTime timestamp;
  final ObjectWithEveryOptionalTypeNestedObjectDataData data;
  const ObjectWithEveryOptionalTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory ObjectWithEveryOptionalTypeNestedObjectData.empty() {
    return ObjectWithEveryOptionalTypeNestedObjectData(
      id: "",
      timestamp: DateTime.now(),
      data: ObjectWithEveryOptionalTypeNestedObjectDataData.empty(),
    );
  }

  factory ObjectWithEveryOptionalTypeNestedObjectData.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    final data = _input_["data"] is Map<String, dynamic>
        ? ObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
            _input_["data"])
        : ObjectWithEveryOptionalTypeNestedObjectDataData.empty();
    return ObjectWithEveryOptionalTypeNestedObjectData(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory ObjectWithEveryOptionalTypeNestedObjectData.fromJsonString(
      String input) {
    return ObjectWithEveryOptionalTypeNestedObjectData.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalTypeNestedObjectData/data.");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryOptionalTypeNestedObjectData copyWith({
    String? id,
    DateTime? timestamp,
    ObjectWithEveryOptionalTypeNestedObjectDataData? data,
  }) {
    return ObjectWithEveryOptionalTypeNestedObjectData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryOptionalTypeNestedObjectData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryOptionalTypeNestedObjectData ${toJsonString()}";
  }
}

class ObjectWithEveryOptionalTypeNestedObjectDataData implements ArriModel {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryOptionalTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });

  factory ObjectWithEveryOptionalTypeNestedObjectDataData.empty() {
    return ObjectWithEveryOptionalTypeNestedObjectDataData(
      id: "",
      timestamp: DateTime.now(),
    );
  }

  factory ObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    return ObjectWithEveryOptionalTypeNestedObjectDataData(
      id: id,
      timestamp: timestamp,
    );
  }

  factory ObjectWithEveryOptionalTypeNestedObjectDataData.fromJsonString(
      String input) {
    return ObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryOptionalTypeNestedObjectDataData copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryOptionalTypeNestedObjectDataData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryOptionalTypeNestedObjectDataData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryOptionalTypeNestedObjectDataData ${toJsonString()}";
  }
}

class ObjectWithEveryOptionalTypeNestedArrayElementElement
    implements ArriModel {
  final String id;
  final DateTime timestamp;
  const ObjectWithEveryOptionalTypeNestedArrayElementElement({
    required this.id,
    required this.timestamp,
  });

  factory ObjectWithEveryOptionalTypeNestedArrayElementElement.empty() {
    return ObjectWithEveryOptionalTypeNestedArrayElementElement(
      id: "",
      timestamp: DateTime.now(),
    );
  }

  factory ObjectWithEveryOptionalTypeNestedArrayElementElement.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    return ObjectWithEveryOptionalTypeNestedArrayElementElement(
      id: id,
      timestamp: timestamp,
    );
  }

  factory ObjectWithEveryOptionalTypeNestedArrayElementElement.fromJsonString(
      String input) {
    return ObjectWithEveryOptionalTypeNestedArrayElementElement.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  @override
  ObjectWithEveryOptionalTypeNestedArrayElementElement copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return ObjectWithEveryOptionalTypeNestedArrayElementElement(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is ObjectWithEveryOptionalTypeNestedArrayElementElement &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ObjectWithEveryOptionalTypeNestedArrayElementElement ${toJsonString()}";
  }
}

class RecursiveObject implements ArriModel {
  final RecursiveObject? left;
  final RecursiveObject? right;
  final String value;
  const RecursiveObject({
    required this.left,
    required this.right,
    required this.value,
  });

  factory RecursiveObject.empty() {
    return RecursiveObject(
      left: null,
      right: null,
      value: "",
    );
  }

  factory RecursiveObject.fromJson(Map<String, dynamic> _input_) {
    final left = _input_["left"] is Map<String, dynamic>
        ? RecursiveObject.fromJson(_input_["left"])
        : null;
    final right = _input_["right"] is Map<String, dynamic>
        ? RecursiveObject.fromJson(_input_["right"])
        : null;
    final value = typeFromDynamic<String>(_input_["value"], "");
    return RecursiveObject(
      left: left,
      right: right,
      value: value,
    );
  }

  factory RecursiveObject.fromJsonString(String input) {
    return RecursiveObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "left": left?.toJson(),
      "right": right?.toJson(),
      "value": value,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /RecursiveObject/left.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /RecursiveObject/right.");
    _queryParts_.add("value=$value");
    return _queryParts_.join("&");
  }

  @override
  RecursiveObject copyWith({
    RecursiveObject? Function()? left,
    RecursiveObject? Function()? right,
    String? value,
  }) {
    return RecursiveObject(
      left: left != null ? left() : this.left,
      right: right != null ? right() : this.right,
      value: value ?? this.value,
    );
  }

  @override
  List<Object?> get props => [
        left,
        right,
        value,
      ];

  @override
  bool operator ==(Object other) {
    return other is RecursiveObject && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "RecursiveObject ${toJsonString()}";
  }
}

sealed class RecursiveUnion implements ArriModel {
  String get type;
  const RecursiveUnion();

  factory RecursiveUnion.empty() {
    return RecursiveUnionChild.empty();
  }

  factory RecursiveUnion.fromJson(Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "CHILD":
        return RecursiveUnionChild.fromJson(_input_);
      case "CHILDREN":
        return RecursiveUnionChildren.fromJson(_input_);
      case "TEXT":
        return RecursiveUnionText.fromJson(_input_);
      case "SHAPE":
        return RecursiveUnionShape.fromJson(_input_);
      default:
        return RecursiveUnion.empty();
    }
  }

  factory RecursiveUnion.fromJsonString(String input) {
    return RecursiveUnion.fromJson(json.decode(input));
  }
}

/// Child node
class RecursiveUnionChild implements RecursiveUnion {
  final RecursiveUnion data;
  const RecursiveUnionChild({
    required this.data,
  });

  @override
  String get type => "CHILD";

  factory RecursiveUnionChild.empty() {
    return RecursiveUnionChild(
      data: RecursiveUnion.empty(),
    );
  }

  factory RecursiveUnionChild.fromJson(Map<String, dynamic> _input_) {
    final data = _input_["data"] is Map<String, dynamic>
        ? RecursiveUnion.fromJson(_input_["data"])
        : RecursiveUnion.empty();
    return RecursiveUnionChild(
      data: data,
    );
  }

  factory RecursiveUnionChild.fromJsonString(String input) {
    return RecursiveUnionChild.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /RecursiveUnionChild/data.");
    return _queryParts_.join("&");
  }

  @override
  RecursiveUnionChild copyWith({
    RecursiveUnion? data,
  }) {
    return RecursiveUnionChild(
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is RecursiveUnionChild && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "RecursiveUnionChild ${toJsonString()}";
  }
}

/// List of children node
class RecursiveUnionChildren implements RecursiveUnion {
  final List<RecursiveUnion> data;
  const RecursiveUnionChildren({
    required this.data,
  });

  @override
  String get type => "CHILDREN";

  factory RecursiveUnionChildren.empty() {
    return RecursiveUnionChildren(
      data: [],
    );
  }

  factory RecursiveUnionChildren.fromJson(Map<String, dynamic> _input_) {
    final data = _input_["data"] is List
        ? (_input_["data"] as List)
            .map((_el_) => _el_ is Map<String, dynamic>
                ? RecursiveUnion.fromJson(_el_)
                : RecursiveUnion.empty())
            .toList()
        : <RecursiveUnion>[];
    return RecursiveUnionChildren(
      data: data,
    );
  }

  factory RecursiveUnionChildren.fromJsonString(String input) {
    return RecursiveUnionChildren.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "data": data.map((_el_) => _el_.toJson()).toList(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /RecursiveUnionChildren/data.");
    return _queryParts_.join("&");
  }

  @override
  RecursiveUnionChildren copyWith({
    List<RecursiveUnion>? data,
  }) {
    return RecursiveUnionChildren(
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is RecursiveUnionChildren && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "RecursiveUnionChildren ${toJsonString()}";
  }
}

/// Text node
class RecursiveUnionText implements RecursiveUnion {
  final String data;
  const RecursiveUnionText({
    required this.data,
  });

  @override
  String get type => "TEXT";

  factory RecursiveUnionText.empty() {
    return RecursiveUnionText(
      data: "",
    );
  }

  factory RecursiveUnionText.fromJson(Map<String, dynamic> _input_) {
    final data = typeFromDynamic<String>(_input_["data"], "");
    return RecursiveUnionText(
      data: data,
    );
  }

  factory RecursiveUnionText.fromJsonString(String input) {
    return RecursiveUnionText.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "data": data,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("data=$data");
    return _queryParts_.join("&");
  }

  @override
  RecursiveUnionText copyWith({
    String? data,
  }) {
    return RecursiveUnionText(
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is RecursiveUnionText && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "RecursiveUnionText ${toJsonString()}";
  }
}

/// Shape node
class RecursiveUnionShape implements RecursiveUnion {
  final RecursiveUnionShapeData data;
  const RecursiveUnionShape({
    required this.data,
  });

  @override
  String get type => "SHAPE";

  factory RecursiveUnionShape.empty() {
    return RecursiveUnionShape(
      data: RecursiveUnionShapeData.empty(),
    );
  }

  factory RecursiveUnionShape.fromJson(Map<String, dynamic> _input_) {
    final data = _input_["data"] is Map<String, dynamic>
        ? RecursiveUnionShapeData.fromJson(_input_["data"])
        : RecursiveUnionShapeData.empty();
    return RecursiveUnionShape(
      data: data,
    );
  }

  factory RecursiveUnionShape.fromJsonString(String input) {
    return RecursiveUnionShape.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /RecursiveUnionShape/data.");
    return _queryParts_.join("&");
  }

  @override
  RecursiveUnionShape copyWith({
    RecursiveUnionShapeData? data,
  }) {
    return RecursiveUnionShape(
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is RecursiveUnionShape && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "RecursiveUnionShape ${toJsonString()}";
  }
}

class RecursiveUnionShapeData implements ArriModel {
  final double width;
  final double height;
  final String color;
  const RecursiveUnionShapeData({
    required this.width,
    required this.height,
    required this.color,
  });

  factory RecursiveUnionShapeData.empty() {
    return RecursiveUnionShapeData(
      width: 0.0,
      height: 0.0,
      color: "",
    );
  }

  factory RecursiveUnionShapeData.fromJson(Map<String, dynamic> _input_) {
    final width = doubleFromDynamic(_input_["width"], 0.0);
    final height = doubleFromDynamic(_input_["height"], 0.0);
    final color = typeFromDynamic<String>(_input_["color"], "");
    return RecursiveUnionShapeData(
      width: width,
      height: height,
      color: color,
    );
  }

  factory RecursiveUnionShapeData.fromJsonString(String input) {
    return RecursiveUnionShapeData.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "width": width,
      "height": height,
      "color": color,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("width=$width");
    _queryParts_.add("height=$height");
    _queryParts_.add("color=$color");
    return _queryParts_.join("&");
  }

  @override
  RecursiveUnionShapeData copyWith({
    double? width,
    double? height,
    String? color,
  }) {
    return RecursiveUnionShapeData(
      width: width ?? this.width,
      height: height ?? this.height,
      color: color ?? this.color,
    );
  }

  @override
  List<Object?> get props => [
        width,
        height,
        color,
      ];

  @override
  bool operator ==(Object other) {
    return other is RecursiveUnionShapeData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "RecursiveUnionShapeData ${toJsonString()}";
  }
}

class AutoReconnectParams implements ArriModel {
  final int messageCount;
  const AutoReconnectParams({
    required this.messageCount,
  });

  factory AutoReconnectParams.empty() {
    return AutoReconnectParams(
      messageCount: 0,
    );
  }

  factory AutoReconnectParams.fromJson(Map<String, dynamic> _input_) {
    final messageCount = intFromDynamic(_input_["messageCount"], 0);
    return AutoReconnectParams(
      messageCount: messageCount,
    );
  }

  factory AutoReconnectParams.fromJsonString(String input) {
    return AutoReconnectParams.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "messageCount": messageCount,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("messageCount=$messageCount");
    return _queryParts_.join("&");
  }

  @override
  AutoReconnectParams copyWith({
    int? messageCount,
  }) {
    return AutoReconnectParams(
      messageCount: messageCount ?? this.messageCount,
    );
  }

  @override
  List<Object?> get props => [
        messageCount,
      ];

  @override
  bool operator ==(Object other) {
    return other is AutoReconnectParams && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "AutoReconnectParams ${toJsonString()}";
  }
}

class AutoReconnectResponse implements ArriModel {
  final int count;
  final String message;
  const AutoReconnectResponse({
    required this.count,
    required this.message,
  });

  factory AutoReconnectResponse.empty() {
    return AutoReconnectResponse(
      count: 0,
      message: "",
    );
  }

  factory AutoReconnectResponse.fromJson(Map<String, dynamic> _input_) {
    final count = intFromDynamic(_input_["count"], 0);
    final message = typeFromDynamic<String>(_input_["message"], "");
    return AutoReconnectResponse(
      count: count,
      message: message,
    );
  }

  factory AutoReconnectResponse.fromJsonString(String input) {
    return AutoReconnectResponse.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "count": count,
      "message": message,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("count=$count");
    _queryParts_.add("message=$message");
    return _queryParts_.join("&");
  }

  @override
  AutoReconnectResponse copyWith({
    int? count,
    String? message,
  }) {
    return AutoReconnectResponse(
      count: count ?? this.count,
      message: message ?? this.message,
    );
  }

  @override
  List<Object?> get props => [
        count,
        message,
      ];

  @override
  bool operator ==(Object other) {
    return other is AutoReconnectResponse && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "AutoReconnectResponse ${toJsonString()}";
  }
}

class StreamConnectionErrorTestParams implements ArriModel {
  final int statusCode;
  final String statusMessage;
  const StreamConnectionErrorTestParams({
    required this.statusCode,
    required this.statusMessage,
  });

  factory StreamConnectionErrorTestParams.empty() {
    return StreamConnectionErrorTestParams(
      statusCode: 0,
      statusMessage: "",
    );
  }

  factory StreamConnectionErrorTestParams.fromJson(
      Map<String, dynamic> _input_) {
    final statusCode = intFromDynamic(_input_["statusCode"], 0);
    final statusMessage = typeFromDynamic<String>(_input_["statusMessage"], "");
    return StreamConnectionErrorTestParams(
      statusCode: statusCode,
      statusMessage: statusMessage,
    );
  }

  factory StreamConnectionErrorTestParams.fromJsonString(String input) {
    return StreamConnectionErrorTestParams.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "statusCode": statusCode,
      "statusMessage": statusMessage,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("statusCode=$statusCode");
    _queryParts_.add("statusMessage=$statusMessage");
    return _queryParts_.join("&");
  }

  @override
  StreamConnectionErrorTestParams copyWith({
    int? statusCode,
    String? statusMessage,
  }) {
    return StreamConnectionErrorTestParams(
      statusCode: statusCode ?? this.statusCode,
      statusMessage: statusMessage ?? this.statusMessage,
    );
  }

  @override
  List<Object?> get props => [
        statusCode,
        statusMessage,
      ];

  @override
  bool operator ==(Object other) {
    return other is StreamConnectionErrorTestParams &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "StreamConnectionErrorTestParams ${toJsonString()}";
  }
}

class StreamConnectionErrorTestResponse implements ArriModel {
  final String message;
  const StreamConnectionErrorTestResponse({
    required this.message,
  });

  factory StreamConnectionErrorTestResponse.empty() {
    return StreamConnectionErrorTestResponse(
      message: "",
    );
  }

  factory StreamConnectionErrorTestResponse.fromJson(
      Map<String, dynamic> _input_) {
    final message = typeFromDynamic<String>(_input_["message"], "");
    return StreamConnectionErrorTestResponse(
      message: message,
    );
  }

  factory StreamConnectionErrorTestResponse.fromJsonString(String input) {
    return StreamConnectionErrorTestResponse.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "message": message,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("message=$message");
    return _queryParts_.join("&");
  }

  @override
  StreamConnectionErrorTestResponse copyWith({
    String? message,
  }) {
    return StreamConnectionErrorTestResponse(
      message: message ?? this.message,
    );
  }

  @override
  List<Object?> get props => [
        message,
      ];

  @override
  bool operator ==(Object other) {
    return other is StreamConnectionErrorTestResponse &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "StreamConnectionErrorTestResponse ${toJsonString()}";
  }
}

class StreamLargeObjectsResponse implements ArriModel {
  final List<double> numbers;
  final List<StreamLargeObjectsResponseObjectsElement> objects;
  const StreamLargeObjectsResponse({
    required this.numbers,
    required this.objects,
  });

  factory StreamLargeObjectsResponse.empty() {
    return StreamLargeObjectsResponse(
      numbers: [],
      objects: [],
    );
  }

  factory StreamLargeObjectsResponse.fromJson(Map<String, dynamic> _input_) {
    final numbers = _input_["numbers"] is List
        ? (_input_["numbers"] as List)
            .map((_el_) => doubleFromDynamic(_el_, 0.0))
            .toList()
        : <double>[];
    final objects = _input_["objects"] is List
        ? (_input_["objects"] as List)
            .map((_el_) => _el_ is Map<String, dynamic>
                ? StreamLargeObjectsResponseObjectsElement.fromJson(_el_)
                : StreamLargeObjectsResponseObjectsElement.empty())
            .toList()
        : <StreamLargeObjectsResponseObjectsElement>[];
    return StreamLargeObjectsResponse(
      numbers: numbers,
      objects: objects,
    );
  }

  factory StreamLargeObjectsResponse.fromJsonString(String input) {
    return StreamLargeObjectsResponse.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "numbers": numbers.map((_el_) => _el_).toList(),
      "objects": objects.map((_el_) => _el_.toJson()).toList(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /StreamLargeObjectsResponse/numbers.");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /StreamLargeObjectsResponse/objects.");
    return _queryParts_.join("&");
  }

  @override
  StreamLargeObjectsResponse copyWith({
    List<double>? numbers,
    List<StreamLargeObjectsResponseObjectsElement>? objects,
  }) {
    return StreamLargeObjectsResponse(
      numbers: numbers ?? this.numbers,
      objects: objects ?? this.objects,
    );
  }

  @override
  List<Object?> get props => [
        numbers,
        objects,
      ];

  @override
  bool operator ==(Object other) {
    return other is StreamLargeObjectsResponse &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "StreamLargeObjectsResponse ${toJsonString()}";
  }
}

class StreamLargeObjectsResponseObjectsElement implements ArriModel {
  final String id;
  final String name;
  final String email;
  const StreamLargeObjectsResponseObjectsElement({
    required this.id,
    required this.name,
    required this.email,
  });

  factory StreamLargeObjectsResponseObjectsElement.empty() {
    return StreamLargeObjectsResponseObjectsElement(
      id: "",
      name: "",
      email: "",
    );
  }

  factory StreamLargeObjectsResponseObjectsElement.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final name = typeFromDynamic<String>(_input_["name"], "");
    final email = typeFromDynamic<String>(_input_["email"], "");
    return StreamLargeObjectsResponseObjectsElement(
      id: id,
      name: name,
      email: email,
    );
  }

  factory StreamLargeObjectsResponseObjectsElement.fromJsonString(
      String input) {
    return StreamLargeObjectsResponseObjectsElement.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "name": name,
      "email": email,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("name=$name");
    _queryParts_.add("email=$email");
    return _queryParts_.join("&");
  }

  @override
  StreamLargeObjectsResponseObjectsElement copyWith({
    String? id,
    String? name,
    String? email,
  }) {
    return StreamLargeObjectsResponseObjectsElement(
      id: id ?? this.id,
      name: name ?? this.name,
      email: email ?? this.email,
    );
  }

  @override
  List<Object?> get props => [
        id,
        name,
        email,
      ];

  @override
  bool operator ==(Object other) {
    return other is StreamLargeObjectsResponseObjectsElement &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "StreamLargeObjectsResponseObjectsElement ${toJsonString()}";
  }
}

class ChatMessageParams implements ArriModel {
  final String channelId;
  const ChatMessageParams({
    required this.channelId,
  });

  factory ChatMessageParams.empty() {
    return ChatMessageParams(
      channelId: "",
    );
  }

  factory ChatMessageParams.fromJson(Map<String, dynamic> _input_) {
    final channelId = typeFromDynamic<String>(_input_["channelId"], "");
    return ChatMessageParams(
      channelId: channelId,
    );
  }

  factory ChatMessageParams.fromJsonString(String input) {
    return ChatMessageParams.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "channelId": channelId,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("channelId=$channelId");
    return _queryParts_.join("&");
  }

  @override
  ChatMessageParams copyWith({
    String? channelId,
  }) {
    return ChatMessageParams(
      channelId: channelId ?? this.channelId,
    );
  }

  @override
  List<Object?> get props => [
        channelId,
      ];

  @override
  bool operator ==(Object other) {
    return other is ChatMessageParams && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ChatMessageParams ${toJsonString()}";
  }
}

sealed class ChatMessage implements ArriModel {
  String get messageType;
  const ChatMessage();

  factory ChatMessage.empty() {
    return ChatMessageText.empty();
  }

  factory ChatMessage.fromJson(Map<String, dynamic> _input_) {
    final messageType = typeFromDynamic<String>(_input_["messageType"], "");
    switch (messageType) {
      case "TEXT":
        return ChatMessageText.fromJson(_input_);
      case "IMAGE":
        return ChatMessageImage.fromJson(_input_);
      case "URL":
        return ChatMessageUrl.fromJson(_input_);
      default:
        return ChatMessage.empty();
    }
  }

  factory ChatMessage.fromJsonString(String input) {
    return ChatMessage.fromJson(json.decode(input));
  }
}

class ChatMessageText implements ChatMessage {
  final String id;
  final String channelId;
  final String userId;
  final DateTime date;
  final String text;
  const ChatMessageText({
    required this.id,
    required this.channelId,
    required this.userId,
    required this.date,
    required this.text,
  });

  @override
  String get messageType => "TEXT";

  factory ChatMessageText.empty() {
    return ChatMessageText(
      id: "",
      channelId: "",
      userId: "",
      date: DateTime.now(),
      text: "",
    );
  }

  factory ChatMessageText.fromJson(Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final channelId = typeFromDynamic<String>(_input_["channelId"], "");
    final userId = typeFromDynamic<String>(_input_["userId"], "");
    final date = dateTimeFromDynamic(_input_["date"], DateTime.now());
    final text = typeFromDynamic<String>(_input_["text"], "");
    return ChatMessageText(
      id: id,
      channelId: channelId,
      userId: userId,
      date: date,
      text: text,
    );
  }

  factory ChatMessageText.fromJsonString(String input) {
    return ChatMessageText.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "messageType": messageType,
      "id": id,
      "channelId": channelId,
      "userId": userId,
      "date": date.toUtc().toIso8601String(),
      "text": text,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("messageType=$messageType");
    _queryParts_.add("id=$id");
    _queryParts_.add("channelId=$channelId");
    _queryParts_.add("userId=$userId");
    _queryParts_.add("date=${date.toUtc().toIso8601String()}");
    _queryParts_.add("text=$text");
    return _queryParts_.join("&");
  }

  @override
  ChatMessageText copyWith({
    String? id,
    String? channelId,
    String? userId,
    DateTime? date,
    String? text,
  }) {
    return ChatMessageText(
      id: id ?? this.id,
      channelId: channelId ?? this.channelId,
      userId: userId ?? this.userId,
      date: date ?? this.date,
      text: text ?? this.text,
    );
  }

  @override
  List<Object?> get props => [
        id,
        channelId,
        userId,
        date,
        text,
      ];

  @override
  bool operator ==(Object other) {
    return other is ChatMessageText && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ChatMessageText ${toJsonString()}";
  }
}

class ChatMessageImage implements ChatMessage {
  final String id;
  final String channelId;
  final String userId;
  final DateTime date;
  final String image;
  const ChatMessageImage({
    required this.id,
    required this.channelId,
    required this.userId,
    required this.date,
    required this.image,
  });

  @override
  String get messageType => "IMAGE";

  factory ChatMessageImage.empty() {
    return ChatMessageImage(
      id: "",
      channelId: "",
      userId: "",
      date: DateTime.now(),
      image: "",
    );
  }

  factory ChatMessageImage.fromJson(Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final channelId = typeFromDynamic<String>(_input_["channelId"], "");
    final userId = typeFromDynamic<String>(_input_["userId"], "");
    final date = dateTimeFromDynamic(_input_["date"], DateTime.now());
    final image = typeFromDynamic<String>(_input_["image"], "");
    return ChatMessageImage(
      id: id,
      channelId: channelId,
      userId: userId,
      date: date,
      image: image,
    );
  }

  factory ChatMessageImage.fromJsonString(String input) {
    return ChatMessageImage.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "messageType": messageType,
      "id": id,
      "channelId": channelId,
      "userId": userId,
      "date": date.toUtc().toIso8601String(),
      "image": image,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("messageType=$messageType");
    _queryParts_.add("id=$id");
    _queryParts_.add("channelId=$channelId");
    _queryParts_.add("userId=$userId");
    _queryParts_.add("date=${date.toUtc().toIso8601String()}");
    _queryParts_.add("image=$image");
    return _queryParts_.join("&");
  }

  @override
  ChatMessageImage copyWith({
    String? id,
    String? channelId,
    String? userId,
    DateTime? date,
    String? image,
  }) {
    return ChatMessageImage(
      id: id ?? this.id,
      channelId: channelId ?? this.channelId,
      userId: userId ?? this.userId,
      date: date ?? this.date,
      image: image ?? this.image,
    );
  }

  @override
  List<Object?> get props => [
        id,
        channelId,
        userId,
        date,
        image,
      ];

  @override
  bool operator ==(Object other) {
    return other is ChatMessageImage && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ChatMessageImage ${toJsonString()}";
  }
}

class ChatMessageUrl implements ChatMessage {
  final String id;
  final String channelId;
  final String userId;
  final DateTime date;
  final String url;
  const ChatMessageUrl({
    required this.id,
    required this.channelId,
    required this.userId,
    required this.date,
    required this.url,
  });

  @override
  String get messageType => "URL";

  factory ChatMessageUrl.empty() {
    return ChatMessageUrl(
      id: "",
      channelId: "",
      userId: "",
      date: DateTime.now(),
      url: "",
    );
  }

  factory ChatMessageUrl.fromJson(Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final channelId = typeFromDynamic<String>(_input_["channelId"], "");
    final userId = typeFromDynamic<String>(_input_["userId"], "");
    final date = dateTimeFromDynamic(_input_["date"], DateTime.now());
    final url = typeFromDynamic<String>(_input_["url"], "");
    return ChatMessageUrl(
      id: id,
      channelId: channelId,
      userId: userId,
      date: date,
      url: url,
    );
  }

  factory ChatMessageUrl.fromJsonString(String input) {
    return ChatMessageUrl.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "messageType": messageType,
      "id": id,
      "channelId": channelId,
      "userId": userId,
      "date": date.toUtc().toIso8601String(),
      "url": url,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("messageType=$messageType");
    _queryParts_.add("id=$id");
    _queryParts_.add("channelId=$channelId");
    _queryParts_.add("userId=$userId");
    _queryParts_.add("date=${date.toUtc().toIso8601String()}");
    _queryParts_.add("url=$url");
    return _queryParts_.join("&");
  }

  @override
  ChatMessageUrl copyWith({
    String? id,
    String? channelId,
    String? userId,
    DateTime? date,
    String? url,
  }) {
    return ChatMessageUrl(
      id: id ?? this.id,
      channelId: channelId ?? this.channelId,
      userId: userId ?? this.userId,
      date: date ?? this.date,
      url: url ?? this.url,
    );
  }

  @override
  List<Object?> get props => [
        id,
        channelId,
        userId,
        date,
        url,
      ];

  @override
  bool operator ==(Object other) {
    return other is ChatMessageUrl && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "ChatMessageUrl ${toJsonString()}";
  }
}

class TestsStreamRetryWithNewCredentialsResponse implements ArriModel {
  final String message;
  const TestsStreamRetryWithNewCredentialsResponse({
    required this.message,
  });

  factory TestsStreamRetryWithNewCredentialsResponse.empty() {
    return TestsStreamRetryWithNewCredentialsResponse(
      message: "",
    );
  }

  factory TestsStreamRetryWithNewCredentialsResponse.fromJson(
      Map<String, dynamic> _input_) {
    final message = typeFromDynamic<String>(_input_["message"], "");
    return TestsStreamRetryWithNewCredentialsResponse(
      message: message,
    );
  }

  factory TestsStreamRetryWithNewCredentialsResponse.fromJsonString(
      String input) {
    return TestsStreamRetryWithNewCredentialsResponse.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "message": message,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("message=$message");
    return _queryParts_.join("&");
  }

  @override
  TestsStreamRetryWithNewCredentialsResponse copyWith({
    String? message,
  }) {
    return TestsStreamRetryWithNewCredentialsResponse(
      message: message ?? this.message,
    );
  }

  @override
  List<Object?> get props => [
        message,
      ];

  @override
  bool operator ==(Object other) {
    return other is TestsStreamRetryWithNewCredentialsResponse &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "TestsStreamRetryWithNewCredentialsResponse ${toJsonString()}";
  }
}

class UsersWatchUserParams implements ArriModel {
  final String userId;
  const UsersWatchUserParams({
    required this.userId,
  });

  factory UsersWatchUserParams.empty() {
    return UsersWatchUserParams(
      userId: "",
    );
  }

  factory UsersWatchUserParams.fromJson(Map<String, dynamic> _input_) {
    final userId = typeFromDynamic<String>(_input_["userId"], "");
    return UsersWatchUserParams(
      userId: userId,
    );
  }

  factory UsersWatchUserParams.fromJsonString(String input) {
    return UsersWatchUserParams.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "userId": userId,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("userId=$userId");
    return _queryParts_.join("&");
  }

  @override
  UsersWatchUserParams copyWith({
    String? userId,
  }) {
    return UsersWatchUserParams(
      userId: userId ?? this.userId,
    );
  }

  @override
  List<Object?> get props => [
        userId,
      ];

  @override
  bool operator ==(Object other) {
    return other is UsersWatchUserParams && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "UsersWatchUserParams ${toJsonString()}";
  }
}

class UsersWatchUserResponse implements ArriModel {
  final String id;
  final UsersWatchUserResponseRole role;

  /// A profile picture
  final UserPhoto? photo;
  final DateTime createdAt;
  final int numFollowers;
  final UserSettings settings;
  final List<UsersWatchUserResponseRecentNotificationsElement>
      recentNotifications;
  final Map<String, UsersWatchUserResponseBookmarksentry> bookmarks;
  final Map<String, dynamic> metadata;
  final List<dynamic> randomList;
  final String? bio;
  const UsersWatchUserResponse({
    required this.id,
    required this.role,
    required this.photo,
    required this.createdAt,
    required this.numFollowers,
    required this.settings,
    required this.recentNotifications,
    required this.bookmarks,
    required this.metadata,
    required this.randomList,
    this.bio,
  });

  factory UsersWatchUserResponse.empty() {
    return UsersWatchUserResponse(
      id: "",
      role: UsersWatchUserResponseRole.standard,
      photo: null,
      createdAt: DateTime.now(),
      numFollowers: 0,
      settings: UserSettings.empty(),
      recentNotifications: [],
      bookmarks: {},
      metadata: {},
      randomList: [],
    );
  }

  factory UsersWatchUserResponse.fromJson(Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final role = UsersWatchUserResponseRole.fromString(
        typeFromDynamic<String>(_input_["role"], ""));
    final photo = _input_["photo"] is Map<String, dynamic>
        ? UserPhoto.fromJson(_input_["photo"])
        : null;
    final createdAt = dateTimeFromDynamic(_input_["createdAt"], DateTime.now());
    final numFollowers = intFromDynamic(_input_["numFollowers"], 0);
    final settings = _input_["settings"] is Map<String, dynamic>
        ? UserSettings.fromJson(_input_["settings"])
        : UserSettings.empty();
    final recentNotifications = _input_["recentNotifications"] is List
        ? (_input_["recentNotifications"] as List)
            .map((_el_) => _el_ is Map<String, dynamic>
                ? UsersWatchUserResponseRecentNotificationsElement.fromJson(
                    _el_)
                : UsersWatchUserResponseRecentNotificationsElement.empty())
            .toList()
        : <UsersWatchUserResponseRecentNotificationsElement>[];
    final bookmarks = _input_["bookmarks"] is Map<String, dynamic>
        ? (_input_["bookmarks"] as Map<String, dynamic>).map(
            (_key_, _val_) => MapEntry(
              _key_,
              _val_ is Map<String, dynamic>
                  ? UsersWatchUserResponseBookmarksentry.fromJson(_val_)
                  : UsersWatchUserResponseBookmarksentry.empty(),
            ),
          )
        : <String, UsersWatchUserResponseBookmarksentry>{};
    final metadata = _input_["metadata"] is Map<String, dynamic>
        ? (_input_["metadata"] as Map<String, dynamic>).map(
            (_key_, _val_) => MapEntry(
              _key_,
              _val_,
            ),
          )
        : <String, dynamic>{};
    final randomList = _input_["randomList"] is List
        ? (_input_["randomList"] as List).map((_el_) => _el_).toList()
        : <dynamic>[];
    final bio = nullableTypeFromDynamic<String>(_input_["bio"]);
    return UsersWatchUserResponse(
      id: id,
      role: role,
      photo: photo,
      createdAt: createdAt,
      numFollowers: numFollowers,
      settings: settings,
      recentNotifications: recentNotifications,
      bookmarks: bookmarks,
      metadata: metadata,
      randomList: randomList,
      bio: bio,
    );
  }

  factory UsersWatchUserResponse.fromJsonString(String input) {
    return UsersWatchUserResponse.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "role": role.serialValue,
      "photo": photo?.toJson(),
      "createdAt": createdAt.toUtc().toIso8601String(),
      "numFollowers": numFollowers,
      "settings": settings.toJson(),
      "recentNotifications":
          recentNotifications.map((_el_) => _el_.toJson()).toList(),
      "bookmarks": bookmarks.map(
        (_key_, _val_) => MapEntry(
          _key_,
          _val_.toJson(),
        ),
      ),
      "metadata": metadata.map(
        (_key_, _val_) => MapEntry(
          _key_,
          _val_,
        ),
      ),
      "randomList": randomList.map((_el_) => _el_).toList(),
    };
    if (bio != null) _output_["bio"] = bio;
    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("role=${role.serialValue}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /UsersWatchUserResponse/photo.");
    _queryParts_.add("createdAt=${createdAt.toUtc().toIso8601String()}");
    _queryParts_.add("numFollowers=$numFollowers");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /UsersWatchUserResponse/settings.");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /UsersWatchUserResponse/recentNotifications.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /UsersWatchUserResponse/bookmarks.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /UsersWatchUserResponse/metadata.");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /UsersWatchUserResponse/randomList.");
    if (bio != null) _queryParts_.add("bio=$bio");
    return _queryParts_.join("&");
  }

  @override
  UsersWatchUserResponse copyWith({
    String? id,
    UsersWatchUserResponseRole? role,
    UserPhoto? Function()? photo,
    DateTime? createdAt,
    int? numFollowers,
    UserSettings? settings,
    List<UsersWatchUserResponseRecentNotificationsElement>? recentNotifications,
    Map<String, UsersWatchUserResponseBookmarksentry>? bookmarks,
    Map<String, dynamic>? metadata,
    List<dynamic>? randomList,
    String? Function()? bio,
  }) {
    return UsersWatchUserResponse(
      id: id ?? this.id,
      role: role ?? this.role,
      photo: photo != null ? photo() : this.photo,
      createdAt: createdAt ?? this.createdAt,
      numFollowers: numFollowers ?? this.numFollowers,
      settings: settings ?? this.settings,
      recentNotifications: recentNotifications ?? this.recentNotifications,
      bookmarks: bookmarks ?? this.bookmarks,
      metadata: metadata ?? this.metadata,
      randomList: randomList ?? this.randomList,
      bio: bio != null ? bio() : this.bio,
    );
  }

  @override
  List<Object?> get props => [
        id,
        role,
        photo,
        createdAt,
        numFollowers,
        settings,
        recentNotifications,
        bookmarks,
        metadata,
        randomList,
        bio,
      ];

  @override
  bool operator ==(Object other) {
    return other is UsersWatchUserResponse && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "UsersWatchUserResponse ${toJsonString()}";
  }
}

enum UsersWatchUserResponseRole
    implements Comparable<UsersWatchUserResponseRole> {
  standard("standard"),
  admin("admin");

  const UsersWatchUserResponseRole(this.serialValue);
  final String serialValue;

  factory UsersWatchUserResponseRole.fromString(String input) {
    for (final val in values) {
      if (val.serialValue == input) {
        return val;
      }
    }
    return standard;
  }

  @override
  int compareTo(UsersWatchUserResponseRole other) => name.compareTo(other.name);
}

/// A profile picture
class UserPhoto implements ArriModel {
  final String url;
  final double width;
  final double height;
  final BigInt bytes;

  /// When the photo was last updated in nanoseconds
  final BigInt nanoseconds;
  const UserPhoto({
    required this.url,
    required this.width,
    required this.height,
    required this.bytes,
    required this.nanoseconds,
  });

  factory UserPhoto.empty() {
    return UserPhoto(
      url: "",
      width: 0.0,
      height: 0.0,
      bytes: BigInt.zero,
      nanoseconds: BigInt.zero,
    );
  }

  factory UserPhoto.fromJson(Map<String, dynamic> _input_) {
    final url = typeFromDynamic<String>(_input_["url"], "");
    final width = doubleFromDynamic(_input_["width"], 0.0);
    final height = doubleFromDynamic(_input_["height"], 0.0);
    final bytes = bigIntFromDynamic(_input_["bytes"], BigInt.zero);
    final nanoseconds = bigIntFromDynamic(_input_["nanoseconds"], BigInt.zero);
    return UserPhoto(
      url: url,
      width: width,
      height: height,
      bytes: bytes,
      nanoseconds: nanoseconds,
    );
  }

  factory UserPhoto.fromJsonString(String input) {
    return UserPhoto.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "url": url,
      "width": width,
      "height": height,
      "bytes": bytes.toString(),
      "nanoseconds": nanoseconds.toString(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("url=$url");
    _queryParts_.add("width=$width");
    _queryParts_.add("height=$height");
    _queryParts_.add("bytes=$bytes");
    _queryParts_.add("nanoseconds=$nanoseconds");
    return _queryParts_.join("&");
  }

  @override
  UserPhoto copyWith({
    String? url,
    double? width,
    double? height,
    BigInt? bytes,
    BigInt? nanoseconds,
  }) {
    return UserPhoto(
      url: url ?? this.url,
      width: width ?? this.width,
      height: height ?? this.height,
      bytes: bytes ?? this.bytes,
      nanoseconds: nanoseconds ?? this.nanoseconds,
    );
  }

  @override
  List<Object?> get props => [
        url,
        width,
        height,
        bytes,
        nanoseconds,
      ];

  @override
  bool operator ==(Object other) {
    return other is UserPhoto && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "UserPhoto ${toJsonString()}";
  }
}

class UserSettings implements ArriModel {
  final bool notificationsEnabled;
  final UserSettingsPreferredTheme preferredTheme;
  const UserSettings({
    required this.notificationsEnabled,
    required this.preferredTheme,
  });

  factory UserSettings.empty() {
    return UserSettings(
      notificationsEnabled: false,
      preferredTheme: UserSettingsPreferredTheme.darkMode,
    );
  }

  factory UserSettings.fromJson(Map<String, dynamic> _input_) {
    final notificationsEnabled =
        typeFromDynamic<bool>(_input_["notificationsEnabled"], false);
    final preferredTheme = UserSettingsPreferredTheme.fromString(
        typeFromDynamic<String>(_input_["preferredTheme"], ""));
    return UserSettings(
      notificationsEnabled: notificationsEnabled,
      preferredTheme: preferredTheme,
    );
  }

  factory UserSettings.fromJsonString(String input) {
    return UserSettings.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "notificationsEnabled": notificationsEnabled,
      "preferredTheme": preferredTheme.serialValue,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("notificationsEnabled=$notificationsEnabled");
    _queryParts_.add("preferredTheme=${preferredTheme.serialValue}");
    return _queryParts_.join("&");
  }

  @override
  UserSettings copyWith({
    bool? notificationsEnabled,
    UserSettingsPreferredTheme? preferredTheme,
  }) {
    return UserSettings(
      notificationsEnabled: notificationsEnabled ?? this.notificationsEnabled,
      preferredTheme: preferredTheme ?? this.preferredTheme,
    );
  }

  @override
  List<Object?> get props => [
        notificationsEnabled,
        preferredTheme,
      ];

  @override
  bool operator ==(Object other) {
    return other is UserSettings && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "UserSettings ${toJsonString()}";
  }
}

enum UserSettingsPreferredTheme
    implements Comparable<UserSettingsPreferredTheme> {
  darkMode("dark-mode"),
  lightMode("light-mode"),
  system("system");

  const UserSettingsPreferredTheme(this.serialValue);
  final String serialValue;

  factory UserSettingsPreferredTheme.fromString(String input) {
    for (final val in values) {
      if (val.serialValue == input) {
        return val;
      }
    }
    return darkMode;
  }

  @override
  int compareTo(UserSettingsPreferredTheme other) => name.compareTo(other.name);
}

sealed class UsersWatchUserResponseRecentNotificationsElement
    implements ArriModel {
  String get notificationType;
  const UsersWatchUserResponseRecentNotificationsElement();

  factory UsersWatchUserResponseRecentNotificationsElement.empty() {
    return UsersWatchUserResponseRecentNotificationsElementPostLike.empty();
  }

  factory UsersWatchUserResponseRecentNotificationsElement.fromJson(
      Map<String, dynamic> _input_) {
    final notificationType =
        typeFromDynamic<String>(_input_["notificationType"], "");
    switch (notificationType) {
      case "POST_LIKE":
        return UsersWatchUserResponseRecentNotificationsElementPostLike
            .fromJson(_input_);
      case "POST_COMMENT":
        return UsersWatchUserResponseRecentNotificationsElementPostComment
            .fromJson(_input_);
      default:
        return UsersWatchUserResponseRecentNotificationsElement.empty();
    }
  }

  factory UsersWatchUserResponseRecentNotificationsElement.fromJsonString(
      String input) {
    return UsersWatchUserResponseRecentNotificationsElement.fromJson(
        json.decode(input));
  }
}

class UsersWatchUserResponseRecentNotificationsElementPostLike
    implements UsersWatchUserResponseRecentNotificationsElement {
  final String postId;
  final String userId;
  const UsersWatchUserResponseRecentNotificationsElementPostLike({
    required this.postId,
    required this.userId,
  });

  @override
  String get notificationType => "POST_LIKE";

  factory UsersWatchUserResponseRecentNotificationsElementPostLike.empty() {
    return UsersWatchUserResponseRecentNotificationsElementPostLike(
      postId: "",
      userId: "",
    );
  }

  factory UsersWatchUserResponseRecentNotificationsElementPostLike.fromJson(
      Map<String, dynamic> _input_) {
    final postId = typeFromDynamic<String>(_input_["postId"], "");
    final userId = typeFromDynamic<String>(_input_["userId"], "");
    return UsersWatchUserResponseRecentNotificationsElementPostLike(
      postId: postId,
      userId: userId,
    );
  }

  factory UsersWatchUserResponseRecentNotificationsElementPostLike.fromJsonString(
      String input) {
    return UsersWatchUserResponseRecentNotificationsElementPostLike.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "notificationType": notificationType,
      "postId": postId,
      "userId": userId,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("notificationType=$notificationType");
    _queryParts_.add("postId=$postId");
    _queryParts_.add("userId=$userId");
    return _queryParts_.join("&");
  }

  @override
  UsersWatchUserResponseRecentNotificationsElementPostLike copyWith({
    String? postId,
    String? userId,
  }) {
    return UsersWatchUserResponseRecentNotificationsElementPostLike(
      postId: postId ?? this.postId,
      userId: userId ?? this.userId,
    );
  }

  @override
  List<Object?> get props => [
        postId,
        userId,
      ];

  @override
  bool operator ==(Object other) {
    return other is UsersWatchUserResponseRecentNotificationsElementPostLike &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "UsersWatchUserResponseRecentNotificationsElementPostLike ${toJsonString()}";
  }
}

class UsersWatchUserResponseRecentNotificationsElementPostComment
    implements UsersWatchUserResponseRecentNotificationsElement {
  final String postId;
  final String userId;
  final String commentText;
  const UsersWatchUserResponseRecentNotificationsElementPostComment({
    required this.postId,
    required this.userId,
    required this.commentText,
  });

  @override
  String get notificationType => "POST_COMMENT";

  factory UsersWatchUserResponseRecentNotificationsElementPostComment.empty() {
    return UsersWatchUserResponseRecentNotificationsElementPostComment(
      postId: "",
      userId: "",
      commentText: "",
    );
  }

  factory UsersWatchUserResponseRecentNotificationsElementPostComment.fromJson(
      Map<String, dynamic> _input_) {
    final postId = typeFromDynamic<String>(_input_["postId"], "");
    final userId = typeFromDynamic<String>(_input_["userId"], "");
    final commentText = typeFromDynamic<String>(_input_["commentText"], "");
    return UsersWatchUserResponseRecentNotificationsElementPostComment(
      postId: postId,
      userId: userId,
      commentText: commentText,
    );
  }

  factory UsersWatchUserResponseRecentNotificationsElementPostComment.fromJsonString(
      String input) {
    return UsersWatchUserResponseRecentNotificationsElementPostComment.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "notificationType": notificationType,
      "postId": postId,
      "userId": userId,
      "commentText": commentText,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("notificationType=$notificationType");
    _queryParts_.add("postId=$postId");
    _queryParts_.add("userId=$userId");
    _queryParts_.add("commentText=$commentText");
    return _queryParts_.join("&");
  }

  @override
  UsersWatchUserResponseRecentNotificationsElementPostComment copyWith({
    String? postId,
    String? userId,
    String? commentText,
  }) {
    return UsersWatchUserResponseRecentNotificationsElementPostComment(
      postId: postId ?? this.postId,
      userId: userId ?? this.userId,
      commentText: commentText ?? this.commentText,
    );
  }

  @override
  List<Object?> get props => [
        postId,
        userId,
        commentText,
      ];

  @override
  bool operator ==(Object other) {
    return other
            is UsersWatchUserResponseRecentNotificationsElementPostComment &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "UsersWatchUserResponseRecentNotificationsElementPostComment ${toJsonString()}";
  }
}

class UsersWatchUserResponseBookmarksentry implements ArriModel {
  final String postId;
  final String userId;
  const UsersWatchUserResponseBookmarksentry({
    required this.postId,
    required this.userId,
  });

  factory UsersWatchUserResponseBookmarksentry.empty() {
    return UsersWatchUserResponseBookmarksentry(
      postId: "",
      userId: "",
    );
  }

  factory UsersWatchUserResponseBookmarksentry.fromJson(
      Map<String, dynamic> _input_) {
    final postId = typeFromDynamic<String>(_input_["postId"], "");
    final userId = typeFromDynamic<String>(_input_["userId"], "");
    return UsersWatchUserResponseBookmarksentry(
      postId: postId,
      userId: userId,
    );
  }

  factory UsersWatchUserResponseBookmarksentry.fromJsonString(String input) {
    return UsersWatchUserResponseBookmarksentry.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "postId": postId,
      "userId": userId,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("postId=$postId");
    _queryParts_.add("userId=$userId");
    return _queryParts_.join("&");
  }

  @override
  UsersWatchUserResponseBookmarksentry copyWith({
    String? postId,
    String? userId,
  }) {
    return UsersWatchUserResponseBookmarksentry(
      postId: postId ?? this.postId,
      userId: userId ?? this.userId,
    );
  }

  @override
  List<Object?> get props => [
        postId,
        userId,
      ];

  @override
  bool operator ==(Object other) {
    return other is UsersWatchUserResponseBookmarksentry &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "UsersWatchUserResponseBookmarksentry ${toJsonString()}";
  }
}
