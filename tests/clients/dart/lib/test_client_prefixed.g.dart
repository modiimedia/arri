// this file was autogenerated by arri
// ignore_for_file: type=lint, unused_field, unnecessary_cast
import 'dart:async';
import 'dart:convert';
import 'package:arri_client/arri_client.dart';
import 'package:http/http.dart' as http;

class TestClientPrefixed {
  final String _baseUrl;
  final String _wsConnectionUrl;

  final http.Client Function()? _createHttpClient;
  final String? _clientVersion = "10";
  final FutureOr<Map<String, String>> Function()? _headers;
  final OnErrorHook? _onError;
  final int? _retry;
  final Duration? _retryDelay;
  final double? _heartbeatTimeoutMultiplier;
  final Duration? _timeout;
  final String _defaultTransport;
  late final Map<String, Dispatcher> _dispatchers;

  TestClientPrefixed({
    required String baseUrl,
    required String wsConnectionUrl,
    http.Client Function()? createHttpClient,
    FutureOr<Map<String, String>> Function()? headers,
    OnErrorHook? onError,
    int? retry,
    Duration? retryDelay,
    double? heartbeatTimeoutMultiplier,
    Duration? timeout,
    String? defaultTransport,
    Map<String, Dispatcher>? dispatchers,
  })  : _baseUrl = baseUrl,
        _wsConnectionUrl = wsConnectionUrl,
        _createHttpClient = createHttpClient,
        _headers = headers,
        _onError = onError,
        _retry = retry,
        _retryDelay = retryDelay,
        _heartbeatTimeoutMultiplier = heartbeatTimeoutMultiplier,
        _timeout = timeout,
        _defaultTransport = defaultTransport ?? "http" {
    _dispatchers = dispatchers ?? {};
    if (_dispatchers["http"] == null) {
      _dispatchers["http"] = HttpDispatcher(
        baseUrl: baseUrl,
        createHttpClient: _createHttpClient,
      );
    }
    if (_dispatchers["ws"] == null) {
      _dispatchers["ws"] = WsDispatcher(
        connectionUrl: _wsConnectionUrl,
        heartbeatTimeoutMultiplier: _heartbeatTimeoutMultiplier,
      );
    }
  }

  Future<FooDefaultPayload> emptyParamsGetRequest({
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "emptyParamsGetRequest",
        path: "/rpcs/tests/empty-params-get-request",
        reqId: getRequestId(),
        method: HttpMethod.get,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: null,
      ),
      jsonDecoder: (data) => FooDefaultPayload.fromJsonString(data),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<FooDefaultPayload> emptyParamsPostRequest({
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "emptyParamsPostRequest",
        path: "/rpcs/tests/empty-params-post-request",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: null,
      ),
      jsonDecoder: (data) => FooDefaultPayload.fromJsonString(data),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<void> emptyResponseGetRequest(
    FooDefaultPayload input, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "emptyResponseGetRequest",
        path: "/rpcs/tests/empty-response-get-request",
        reqId: getRequestId(),
        method: HttpMethod.get,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: input,
      ),
      jsonDecoder: (_) => {},
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<void> emptyResponsePostRequest(
    FooDefaultPayload input, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "emptyResponsePostRequest",
        path: "/rpcs/tests/empty-response-post-request",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: input,
      ),
      jsonDecoder: (_) => {},
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  /// If the target language supports it. Generated code should mark this procedure as deprecated.
  @deprecated
  Future<void> deprecatedRpc(
    FooDeprecatedRpcParams input, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "deprecatedRpc",
        path: "/rpcs/tests/deprecated-rpc",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: input,
      ),
      jsonDecoder: (_) => {},
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<FooDiscriminatorWithEmptyObject> sendDiscriminatorWithEmptyObject(
    FooDiscriminatorWithEmptyObject input, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "sendDiscriminatorWithEmptyObject",
        path: "/rpcs/tests/send-discriminator-with-empty-object",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: input,
      ),
      jsonDecoder: (data) =>
          FooDiscriminatorWithEmptyObject.fromJsonString(data),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<void> sendError(
    FooSendErrorParams input, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "sendError",
        path: "/rpcs/tests/send-error",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: input,
      ),
      jsonDecoder: (_) => {},
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<FooObjectWithEveryType> sendObject(
    FooObjectWithEveryType input, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "sendObject",
        path: "/rpcs/tests/send-object",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: input,
      ),
      jsonDecoder: (data) => FooObjectWithEveryType.fromJsonString(data),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<FooObjectWithEveryNullableType> sendObjectWithNullableFields(
    FooObjectWithEveryNullableType input, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "sendObjectWithNullableFields",
        path: "/rpcs/tests/send-object-with-nullable-fields",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: input,
      ),
      jsonDecoder: (data) =>
          FooObjectWithEveryNullableType.fromJsonString(data),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<FooObjectWithPascalCaseKeys> sendObjectWithPascalCaseKeys(
    FooObjectWithPascalCaseKeys input, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "sendObjectWithPascalCaseKeys",
        path: "/rpcs/tests/send-object-with-pascal-case-keys",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: input,
      ),
      jsonDecoder: (data) => FooObjectWithPascalCaseKeys.fromJsonString(data),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<FooObjectWithSnakeCaseKeys> sendObjectWithSnakeCaseKeys(
    FooObjectWithSnakeCaseKeys input, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "sendObjectWithSnakeCaseKeys",
        path: "/rpcs/tests/send-object-with-snake-case-keys",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: input,
      ),
      jsonDecoder: (data) => FooObjectWithSnakeCaseKeys.fromJsonString(data),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<FooObjectWithEveryOptionalType> sendPartialObject(
    FooObjectWithEveryOptionalType input, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "sendPartialObject",
        path: "/rpcs/tests/send-partial-object",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: input,
      ),
      jsonDecoder: (data) =>
          FooObjectWithEveryOptionalType.fromJsonString(data),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<FooRecursiveObject> sendRecursiveObject(
    FooRecursiveObject input, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "sendRecursiveObject",
        path: "/rpcs/tests/send-recursive-object",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: input,
      ),
      jsonDecoder: (data) => FooRecursiveObject.fromJsonString(data),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<FooRecursiveUnion> sendRecursiveUnion(
    FooRecursiveUnion input, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "sendRecursiveUnion",
        path: "/rpcs/tests/send-recursive-union",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: input,
      ),
      jsonDecoder: (data) => FooRecursiveUnion.fromJsonString(data),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  ArriEventSource<FooAutoReconnectResponse> streamAutoReconnect(
    FooAutoReconnectParams input, {
    ArriEventSourceHookOnData<FooAutoReconnectResponse>? onData,
    ArriEventSourceHookOnRawData<FooAutoReconnectResponse>? onRawData,
    ArriEventSourceHookOnOpen<FooAutoReconnectResponse>? onOpen,
    ArriEventSourceHookOnClose<FooAutoReconnectResponse>? onClose,
    ArriEventSourceHookOnError<FooAutoReconnectResponse>? onError,
    Duration? timeout,
    String? transport,
    int? maxRetryCount,
    Duration? maxRetryInterval,
    String? lastMsgId,
  }) {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleOutputStreamRpc<FooAutoReconnectParams,
        FooAutoReconnectResponse>(
      req: RpcRequest(
        procedure: "streamAutoReconnect",
        path: "/rpcs/tests/stream-auto-reconnect",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: input,
      ),
      jsonDecoder: (data) => FooAutoReconnectResponse.fromJsonString(data),
      lastMsgId: lastMsgId,
      onData: onData,
      onRawData: onRawData,
      onOpen: onOpen,
      onClose: onClose,
      onError: onError,
      timeout: timeout ?? _timeout,
      maxRetryCount: maxRetryCount,
      maxRetryInterval: maxRetryInterval,
      heartbeatTimeoutMultiplier: _heartbeatTimeoutMultiplier,
    );
  }

  /// This route will always return an error. The client should automatically retry with exponential backoff.
  ArriEventSource<FooStreamConnectionErrorTestResponse>
      streamConnectionErrorTest(
    FooStreamConnectionErrorTestParams input, {
    ArriEventSourceHookOnData<FooStreamConnectionErrorTestResponse>? onData,
    ArriEventSourceHookOnRawData<FooStreamConnectionErrorTestResponse>?
        onRawData,
    ArriEventSourceHookOnOpen<FooStreamConnectionErrorTestResponse>? onOpen,
    ArriEventSourceHookOnClose<FooStreamConnectionErrorTestResponse>? onClose,
    ArriEventSourceHookOnError<FooStreamConnectionErrorTestResponse>? onError,
    Duration? timeout,
    String? transport,
    int? maxRetryCount,
    Duration? maxRetryInterval,
    String? lastMsgId,
  }) {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleOutputStreamRpc<FooStreamConnectionErrorTestParams,
        FooStreamConnectionErrorTestResponse>(
      req: RpcRequest(
        procedure: "streamConnectionErrorTest",
        path: "/rpcs/tests/stream-connection-error-test",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: input,
      ),
      jsonDecoder: (data) =>
          FooStreamConnectionErrorTestResponse.fromJsonString(data),
      lastMsgId: lastMsgId,
      onData: onData,
      onRawData: onRawData,
      onOpen: onOpen,
      onClose: onClose,
      onError: onError,
      timeout: timeout ?? _timeout,
      maxRetryCount: maxRetryCount,
      maxRetryInterval: maxRetryInterval,
      heartbeatTimeoutMultiplier: _heartbeatTimeoutMultiplier,
    );
  }

  /// Test to ensure that the client can handle receiving streams of large objects. When objects are large messages will sometimes get sent in chunks. Meaning you have to handle receiving a partial message
  ArriEventSource<FooStreamLargeObjectsResponse> streamLargeObjects({
    ArriEventSourceHookOnData<FooStreamLargeObjectsResponse>? onData,
    ArriEventSourceHookOnRawData<FooStreamLargeObjectsResponse>? onRawData,
    ArriEventSourceHookOnOpen<FooStreamLargeObjectsResponse>? onOpen,
    ArriEventSourceHookOnClose<FooStreamLargeObjectsResponse>? onClose,
    ArriEventSourceHookOnError<FooStreamLargeObjectsResponse>? onError,
    Duration? timeout,
    String? transport,
    int? maxRetryCount,
    Duration? maxRetryInterval,
    String? lastMsgId,
  }) {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher
        .handleOutputStreamRpc<Null, FooStreamLargeObjectsResponse>(
      req: RpcRequest(
        procedure: "streamLargeObjects",
        path: "/rpcs/tests/stream-large-objects",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: null,
      ),
      jsonDecoder: (data) => FooStreamLargeObjectsResponse.fromJsonString(data),
      lastMsgId: lastMsgId,
      onData: onData,
      onRawData: onRawData,
      onOpen: onOpen,
      onClose: onClose,
      onError: onError,
      timeout: timeout ?? _timeout,
      maxRetryCount: maxRetryCount,
      maxRetryInterval: maxRetryInterval,
      heartbeatTimeoutMultiplier: _heartbeatTimeoutMultiplier,
    );
  }

  ArriEventSource<FooChatMessage> streamMessages(
    FooChatMessageParams input, {
    ArriEventSourceHookOnData<FooChatMessage>? onData,
    ArriEventSourceHookOnRawData<FooChatMessage>? onRawData,
    ArriEventSourceHookOnOpen<FooChatMessage>? onOpen,
    ArriEventSourceHookOnClose<FooChatMessage>? onClose,
    ArriEventSourceHookOnError<FooChatMessage>? onError,
    Duration? timeout,
    String? transport,
    int? maxRetryCount,
    Duration? maxRetryInterval,
    String? lastMsgId,
  }) {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher
        .handleOutputStreamRpc<FooChatMessageParams, FooChatMessage>(
      req: RpcRequest(
        procedure: "streamMessages",
        path: "/rpcs/tests/stream-messages",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: input,
      ),
      jsonDecoder: (data) => FooChatMessage.fromJsonString(data),
      lastMsgId: lastMsgId,
      onData: onData,
      onRawData: onRawData,
      onOpen: onOpen,
      onClose: onClose,
      onError: onError,
      timeout: timeout ?? _timeout,
      maxRetryCount: maxRetryCount,
      maxRetryInterval: maxRetryInterval,
      heartbeatTimeoutMultiplier: _heartbeatTimeoutMultiplier,
    );
  }

  ArriEventSource<FooTestsStreamRetryWithNewCredentialsResponse>
      streamRetryWithNewCredentials({
    ArriEventSourceHookOnData<FooTestsStreamRetryWithNewCredentialsResponse>?
        onData,
    ArriEventSourceHookOnRawData<FooTestsStreamRetryWithNewCredentialsResponse>?
        onRawData,
    ArriEventSourceHookOnOpen<FooTestsStreamRetryWithNewCredentialsResponse>?
        onOpen,
    ArriEventSourceHookOnClose<FooTestsStreamRetryWithNewCredentialsResponse>?
        onClose,
    ArriEventSourceHookOnError<FooTestsStreamRetryWithNewCredentialsResponse>?
        onError,
    Duration? timeout,
    String? transport,
    int? maxRetryCount,
    Duration? maxRetryInterval,
    String? lastMsgId,
  }) {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleOutputStreamRpc<Null,
        FooTestsStreamRetryWithNewCredentialsResponse>(
      req: RpcRequest(
        procedure: "streamRetryWithNewCredentials",
        path: "/rpcs/tests/stream-retry-with-new-credentials",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: null,
      ),
      jsonDecoder: (data) =>
          FooTestsStreamRetryWithNewCredentialsResponse.fromJsonString(data),
      lastMsgId: lastMsgId,
      onData: onData,
      onRawData: onRawData,
      onOpen: onOpen,
      onClose: onClose,
      onError: onError,
      timeout: timeout ?? _timeout,
      maxRetryCount: maxRetryCount,
      maxRetryInterval: maxRetryInterval,
      heartbeatTimeoutMultiplier: _heartbeatTimeoutMultiplier,
    );
  }

  /// When the client receives the 'done' event, it should close the connection and NOT reconnect
  ArriEventSource<FooChatMessage> streamTenEventsThenEnd({
    ArriEventSourceHookOnData<FooChatMessage>? onData,
    ArriEventSourceHookOnRawData<FooChatMessage>? onRawData,
    ArriEventSourceHookOnOpen<FooChatMessage>? onOpen,
    ArriEventSourceHookOnClose<FooChatMessage>? onClose,
    ArriEventSourceHookOnError<FooChatMessage>? onError,
    Duration? timeout,
    String? transport,
    int? maxRetryCount,
    Duration? maxRetryInterval,
    String? lastMsgId,
  }) {
    final selectedTransport =
        resolveTransport(["http", "ws"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleOutputStreamRpc<Null, FooChatMessage>(
      req: RpcRequest(
        procedure: "streamTenEventsThenEnd",
        path: "/rpcs/tests/stream-ten-events-then-end",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: null,
      ),
      jsonDecoder: (data) => FooChatMessage.fromJsonString(data),
      lastMsgId: lastMsgId,
      onData: onData,
      onRawData: onRawData,
      onOpen: onOpen,
      onClose: onClose,
      onError: onError,
      timeout: timeout ?? _timeout,
      maxRetryCount: maxRetryCount,
      maxRetryInterval: maxRetryInterval,
      heartbeatTimeoutMultiplier: _heartbeatTimeoutMultiplier,
    );
  }
}

class FooManuallyAddedModel implements ArriModel {
  final String hello;
  const FooManuallyAddedModel({
    required this.hello,
  });

  factory FooManuallyAddedModel.empty() {
    return FooManuallyAddedModel(
      hello: "",
    );
  }

  factory FooManuallyAddedModel.fromJson(Map<String, dynamic> _input_) {
    final hello = typeFromDynamic<String>(_input_["hello"], "");
    return FooManuallyAddedModel(
      hello: hello,
    );
  }

  factory FooManuallyAddedModel.fromJsonString(String input) {
    return FooManuallyAddedModel.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "hello": hello,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("hello=$hello");
    return _queryParts_.join("&");
  }

  FooManuallyAddedModel copyWith({
    String? hello,
  }) {
    return FooManuallyAddedModel(
      hello: hello ?? this.hello,
    );
  }

  @override
  List<Object?> get props => [
        hello,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooManuallyAddedModel && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooManuallyAddedModel ${toJsonString()}";
  }
}

class FooDefaultPayload implements ArriModel {
  final String message;
  const FooDefaultPayload({
    required this.message,
  });

  factory FooDefaultPayload.empty() {
    return FooDefaultPayload(
      message: "",
    );
  }

  factory FooDefaultPayload.fromJson(Map<String, dynamic> _input_) {
    final message = typeFromDynamic<String>(_input_["message"], "");
    return FooDefaultPayload(
      message: message,
    );
  }

  factory FooDefaultPayload.fromJsonString(String input) {
    return FooDefaultPayload.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "message": message,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("message=$message");
    return _queryParts_.join("&");
  }

  FooDefaultPayload copyWith({
    String? message,
  }) {
    return FooDefaultPayload(
      message: message ?? this.message,
    );
  }

  @override
  List<Object?> get props => [
        message,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooDefaultPayload && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooDefaultPayload ${toJsonString()}";
  }
}

@deprecated
class FooDeprecatedRpcParams implements ArriModel {
  @deprecated
  final String deprecatedField;
  const FooDeprecatedRpcParams({
    required this.deprecatedField,
  });

  factory FooDeprecatedRpcParams.empty() {
    return FooDeprecatedRpcParams(
      deprecatedField: "",
    );
  }

  factory FooDeprecatedRpcParams.fromJson(Map<String, dynamic> _input_) {
    final deprecatedField =
        typeFromDynamic<String>(_input_["deprecatedField"], "");
    return FooDeprecatedRpcParams(
      deprecatedField: deprecatedField,
    );
  }

  factory FooDeprecatedRpcParams.fromJsonString(String input) {
    return FooDeprecatedRpcParams.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "deprecatedField": deprecatedField,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("deprecatedField=$deprecatedField");
    return _queryParts_.join("&");
  }

  FooDeprecatedRpcParams copyWith({
    String? deprecatedField,
  }) {
    return FooDeprecatedRpcParams(
      deprecatedField: deprecatedField ?? this.deprecatedField,
    );
  }

  @override
  List<Object?> get props => [
        deprecatedField,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooDeprecatedRpcParams && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooDeprecatedRpcParams ${toJsonString()}";
  }
}

sealed class FooDiscriminatorWithEmptyObject implements ArriModel {
  String get type;
  const FooDiscriminatorWithEmptyObject();

  factory FooDiscriminatorWithEmptyObject.empty() {
    return FooDiscriminatorWithEmptyObjectEmpty.empty();
  }

  factory FooDiscriminatorWithEmptyObject.fromJson(
      Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "EMPTY":
        return FooDiscriminatorWithEmptyObjectEmpty.fromJson(_input_);
      case "NOT_EMPTY":
        return FooDiscriminatorWithEmptyObjectNotEmpty.fromJson(_input_);
      default:
        return FooDiscriminatorWithEmptyObject.empty();
    }
  }

  factory FooDiscriminatorWithEmptyObject.fromJsonString(String input) {
    return FooDiscriminatorWithEmptyObject.fromJson(json.decode(input));
  }
}

class FooDiscriminatorWithEmptyObjectEmpty
    implements FooDiscriminatorWithEmptyObject {
  const FooDiscriminatorWithEmptyObjectEmpty();

  @override
  String get type => "EMPTY";

  factory FooDiscriminatorWithEmptyObjectEmpty.empty() {
    return FooDiscriminatorWithEmptyObjectEmpty();
  }

  factory FooDiscriminatorWithEmptyObjectEmpty.fromJson(
      Map<String, dynamic> _input_) {
    return FooDiscriminatorWithEmptyObjectEmpty();
  }

  factory FooDiscriminatorWithEmptyObjectEmpty.fromJsonString(String input) {
    return FooDiscriminatorWithEmptyObjectEmpty.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    return _queryParts_.join("&");
  }

  FooDiscriminatorWithEmptyObjectEmpty copyWith() {
    return FooDiscriminatorWithEmptyObjectEmpty();
  }

  @override
  List<Object?> get props => [];

  @override
  bool operator ==(Object other) {
    return other is FooDiscriminatorWithEmptyObjectEmpty &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooDiscriminatorWithEmptyObjectEmpty ${toJsonString()}";
  }
}

class FooDiscriminatorWithEmptyObjectNotEmpty
    implements FooDiscriminatorWithEmptyObject {
  final String foo;
  final double bar;
  final bool baz;
  const FooDiscriminatorWithEmptyObjectNotEmpty({
    required this.foo,
    required this.bar,
    required this.baz,
  });

  @override
  String get type => "NOT_EMPTY";

  factory FooDiscriminatorWithEmptyObjectNotEmpty.empty() {
    return FooDiscriminatorWithEmptyObjectNotEmpty(
      foo: "",
      bar: 0.0,
      baz: false,
    );
  }

  factory FooDiscriminatorWithEmptyObjectNotEmpty.fromJson(
      Map<String, dynamic> _input_) {
    final foo = typeFromDynamic<String>(_input_["foo"], "");
    final bar = doubleFromDynamic(_input_["bar"], 0.0);
    final baz = typeFromDynamic<bool>(_input_["baz"], false);
    return FooDiscriminatorWithEmptyObjectNotEmpty(
      foo: foo,
      bar: bar,
      baz: baz,
    );
  }

  factory FooDiscriminatorWithEmptyObjectNotEmpty.fromJsonString(String input) {
    return FooDiscriminatorWithEmptyObjectNotEmpty.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "foo": foo,
      "bar": bar,
      "baz": baz,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("foo=$foo");
    _queryParts_.add("bar=$bar");
    _queryParts_.add("baz=$baz");
    return _queryParts_.join("&");
  }

  FooDiscriminatorWithEmptyObjectNotEmpty copyWith({
    String? foo,
    double? bar,
    bool? baz,
  }) {
    return FooDiscriminatorWithEmptyObjectNotEmpty(
      foo: foo ?? this.foo,
      bar: bar ?? this.bar,
      baz: baz ?? this.baz,
    );
  }

  @override
  List<Object?> get props => [
        foo,
        bar,
        baz,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooDiscriminatorWithEmptyObjectNotEmpty &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooDiscriminatorWithEmptyObjectNotEmpty ${toJsonString()}";
  }
}

class FooSendErrorParams implements ArriModel {
  final int code;
  final String message;
  const FooSendErrorParams({
    required this.code,
    required this.message,
  });

  factory FooSendErrorParams.empty() {
    return FooSendErrorParams(
      code: 0,
      message: "",
    );
  }

  factory FooSendErrorParams.fromJson(Map<String, dynamic> _input_) {
    final code = intFromDynamic(_input_["code"], 0);
    final message = typeFromDynamic<String>(_input_["message"], "");
    return FooSendErrorParams(
      code: code,
      message: message,
    );
  }

  factory FooSendErrorParams.fromJsonString(String input) {
    return FooSendErrorParams.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "code": code,
      "message": message,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("code=$code");
    _queryParts_.add("message=$message");
    return _queryParts_.join("&");
  }

  FooSendErrorParams copyWith({
    int? code,
    String? message,
  }) {
    return FooSendErrorParams(
      code: code ?? this.code,
      message: message ?? this.message,
    );
  }

  @override
  List<Object?> get props => [
        code,
        message,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooSendErrorParams && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooSendErrorParams ${toJsonString()}";
  }
}

class FooObjectWithEveryType implements ArriModel {
  final dynamic any;
  final bool boolean;
  final String string;
  final DateTime timestamp;
  final double float32;
  final double float64;
  final int int8;
  final int uint8;
  final int int16;
  final int uint16;
  final int int32;
  final int uint32;
  final BigInt int64;
  final BigInt uint64;
  final FooObjectWithEveryTypeEnumerator enumerator;
  final List<bool> array;
  final FooObjectWithEveryTypeObject object;
  final Map<String, BigInt> record;
  final FooObjectWithEveryTypeDiscriminator discriminator;
  final FooObjectWithEveryTypeNestedObject nestedObject;
  final List<List<FooObjectWithEveryTypeNestedArrayElementElement>> nestedArray;
  const FooObjectWithEveryType({
    required this.any,
    required this.boolean,
    required this.string,
    required this.timestamp,
    required this.float32,
    required this.float64,
    required this.int8,
    required this.uint8,
    required this.int16,
    required this.uint16,
    required this.int32,
    required this.uint32,
    required this.int64,
    required this.uint64,
    required this.enumerator,
    required this.array,
    required this.object,
    required this.record,
    required this.discriminator,
    required this.nestedObject,
    required this.nestedArray,
  });

  factory FooObjectWithEveryType.empty() {
    return FooObjectWithEveryType(
      any: null,
      boolean: false,
      string: "",
      timestamp: DateTime(0),
      float32: 0.0,
      float64: 0.0,
      int8: 0,
      uint8: 0,
      int16: 0,
      uint16: 0,
      int32: 0,
      uint32: 0,
      int64: BigInt.zero,
      uint64: BigInt.zero,
      enumerator: FooObjectWithEveryTypeEnumerator.a,
      array: [],
      object: FooObjectWithEveryTypeObject.empty(),
      record: {},
      discriminator: FooObjectWithEveryTypeDiscriminator.empty(),
      nestedObject: FooObjectWithEveryTypeNestedObject.empty(),
      nestedArray: [],
    );
  }

  factory FooObjectWithEveryType.fromJson(Map<String, dynamic> _input_) {
    final any = _input_["any"];
    final boolean = typeFromDynamic<bool>(_input_["boolean"], false);
    final string = typeFromDynamic<String>(_input_["string"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime(0));
    final float32 = doubleFromDynamic(_input_["float32"], 0.0);
    final float64 = doubleFromDynamic(_input_["float64"], 0.0);
    final int8 = intFromDynamic(_input_["int8"], 0);
    final uint8 = intFromDynamic(_input_["uint8"], 0);
    final int16 = intFromDynamic(_input_["int16"], 0);
    final uint16 = intFromDynamic(_input_["uint16"], 0);
    final int32 = intFromDynamic(_input_["int32"], 0);
    final uint32 = intFromDynamic(_input_["uint32"], 0);
    final int64 = bigIntFromDynamic(_input_["int64"], BigInt.zero);
    final uint64 = bigIntFromDynamic(_input_["uint64"], BigInt.zero);
    final enumerator = FooObjectWithEveryTypeEnumerator.fromString(
        typeFromDynamic<String>(_input_["enumerator"], ""));
    final array = _input_["array"] is List
        ? (_input_["array"] as List)
            .map((_el_) => typeFromDynamic<bool>(_el_, false))
            .toList()
        : <bool>[];
    final object = _input_["object"] is Map<String, dynamic>
        ? FooObjectWithEveryTypeObject.fromJson(_input_["object"])
        : FooObjectWithEveryTypeObject.empty();
    final record = _input_["record"] is Map<String, dynamic>
        ? (_input_["record"] as Map<String, dynamic>).map(
            (_key_, _val_) => MapEntry(
              _key_,
              bigIntFromDynamic(_val_, BigInt.zero),
            ),
          )
        : <String, BigInt>{};
    final discriminator = _input_["discriminator"] is Map<String, dynamic>
        ? FooObjectWithEveryTypeDiscriminator.fromJson(_input_["discriminator"])
        : FooObjectWithEveryTypeDiscriminator.empty();
    final nestedObject = _input_["nestedObject"] is Map<String, dynamic>
        ? FooObjectWithEveryTypeNestedObject.fromJson(_input_["nestedObject"])
        : FooObjectWithEveryTypeNestedObject.empty();
    final nestedArray = _input_["nestedArray"] is List
        ? (_input_["nestedArray"] as List)
            .map((_el_) => _el_ is List
                ? (_el_ as List)
                    .map((_el_) => _el_ is Map<String, dynamic>
                        ? FooObjectWithEveryTypeNestedArrayElementElement
                            .fromJson(_el_)
                        : FooObjectWithEveryTypeNestedArrayElementElement
                            .empty())
                    .toList()
                : <FooObjectWithEveryTypeNestedArrayElementElement>[])
            .toList()
        : <List<FooObjectWithEveryTypeNestedArrayElementElement>>[];
    return FooObjectWithEveryType(
      any: any,
      boolean: boolean,
      string: string,
      timestamp: timestamp,
      float32: float32,
      float64: float64,
      int8: int8,
      uint8: uint8,
      int16: int16,
      uint16: uint16,
      int32: int32,
      uint32: uint32,
      int64: int64,
      uint64: uint64,
      enumerator: enumerator,
      array: array,
      object: object,
      record: record,
      discriminator: discriminator,
      nestedObject: nestedObject,
      nestedArray: nestedArray,
    );
  }

  factory FooObjectWithEveryType.fromJsonString(String input) {
    return FooObjectWithEveryType.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "any": any,
      "boolean": boolean,
      "string": string,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "float32": float32,
      "float64": float64,
      "int8": int8,
      "uint8": uint8,
      "int16": int16,
      "uint16": uint16,
      "int32": int32,
      "uint32": uint32,
      "int64": int64.toString(),
      "uint64": uint64.toString(),
      "enumerator": enumerator.serialValue,
      "array": array.map((_el_) => _el_).toList(),
      "object": object.toJson(),
      "record": record.map(
        (_key_, _val_) => MapEntry(
          _key_,
          _val_.toString(),
        ),
      ),
      "discriminator": discriminator.toJson(),
      "nestedObject": nestedObject.toJson(),
      "nestedArray": nestedArray
          .map((_el_) => _el_.map((_el_) => _el_.toJson()).toList())
          .toList(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    print(
        "[WARNING] any's cannot be serialized to query params. Skipping field at /ObjectWithEveryType/any.");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("string=$string");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    _queryParts_.add("float32=$float32");
    _queryParts_.add("float64=$float64");
    _queryParts_.add("int8=$int8");
    _queryParts_.add("uint8=$uint8");
    _queryParts_.add("int16=$int16");
    _queryParts_.add("uint16=$uint16");
    _queryParts_.add("int32=$int32");
    _queryParts_.add("uint32=$uint32");
    _queryParts_.add("int64=$int64");
    _queryParts_.add("uint64=$uint64");
    _queryParts_.add("enumerator=${enumerator.serialValue}");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryType/array.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryType/object.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryType/record.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryType/discriminator.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryType/nestedObject.");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryType/nestedArray.");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryType copyWith({
    dynamic any,
    bool? boolean,
    String? string,
    DateTime? timestamp,
    double? float32,
    double? float64,
    int? int8,
    int? uint8,
    int? int16,
    int? uint16,
    int? int32,
    int? uint32,
    BigInt? int64,
    BigInt? uint64,
    FooObjectWithEveryTypeEnumerator? enumerator,
    List<bool>? array,
    FooObjectWithEveryTypeObject? object,
    Map<String, BigInt>? record,
    FooObjectWithEveryTypeDiscriminator? discriminator,
    FooObjectWithEveryTypeNestedObject? nestedObject,
    List<List<FooObjectWithEveryTypeNestedArrayElementElement>>? nestedArray,
  }) {
    return FooObjectWithEveryType(
      any: any ?? this.any,
      boolean: boolean ?? this.boolean,
      string: string ?? this.string,
      timestamp: timestamp ?? this.timestamp,
      float32: float32 ?? this.float32,
      float64: float64 ?? this.float64,
      int8: int8 ?? this.int8,
      uint8: uint8 ?? this.uint8,
      int16: int16 ?? this.int16,
      uint16: uint16 ?? this.uint16,
      int32: int32 ?? this.int32,
      uint32: uint32 ?? this.uint32,
      int64: int64 ?? this.int64,
      uint64: uint64 ?? this.uint64,
      enumerator: enumerator ?? this.enumerator,
      array: array ?? this.array,
      object: object ?? this.object,
      record: record ?? this.record,
      discriminator: discriminator ?? this.discriminator,
      nestedObject: nestedObject ?? this.nestedObject,
      nestedArray: nestedArray ?? this.nestedArray,
    );
  }

  @override
  List<Object?> get props => [
        any,
        boolean,
        string,
        timestamp,
        float32,
        float64,
        int8,
        uint8,
        int16,
        uint16,
        int32,
        uint32,
        int64,
        uint64,
        enumerator,
        array,
        object,
        record,
        discriminator,
        nestedObject,
        nestedArray,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryType && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryType ${toJsonString()}";
  }
}

enum FooObjectWithEveryTypeEnumerator
    implements Comparable<FooObjectWithEveryTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const FooObjectWithEveryTypeEnumerator(this.serialValue);
  final String serialValue;

  factory FooObjectWithEveryTypeEnumerator.fromString(String input) {
    for (final val in values) {
      if (val.serialValue == input) {
        return val;
      }
    }
    return a;
  }

  @override
  int compareTo(FooObjectWithEveryTypeEnumerator other) =>
      name.compareTo(other.name);
}

class FooObjectWithEveryTypeObject implements ArriModel {
  final String string;
  final bool boolean;
  final DateTime timestamp;
  const FooObjectWithEveryTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });

  factory FooObjectWithEveryTypeObject.empty() {
    return FooObjectWithEveryTypeObject(
      string: "",
      boolean: false,
      timestamp: DateTime(0),
    );
  }

  factory FooObjectWithEveryTypeObject.fromJson(Map<String, dynamic> _input_) {
    final string = typeFromDynamic<String>(_input_["string"], "");
    final boolean = typeFromDynamic<bool>(_input_["boolean"], false);
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime(0));
    return FooObjectWithEveryTypeObject(
      string: string,
      boolean: boolean,
      timestamp: timestamp,
    );
  }

  factory FooObjectWithEveryTypeObject.fromJsonString(String input) {
    return FooObjectWithEveryTypeObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("string=$string");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryTypeObject copyWith({
    String? string,
    bool? boolean,
    DateTime? timestamp,
  }) {
    return FooObjectWithEveryTypeObject(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        string,
        boolean,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryTypeObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryTypeObject ${toJsonString()}";
  }
}

sealed class FooObjectWithEveryTypeDiscriminator implements ArriModel {
  String get type;
  const FooObjectWithEveryTypeDiscriminator();

  factory FooObjectWithEveryTypeDiscriminator.empty() {
    return FooObjectWithEveryTypeDiscriminatorA.empty();
  }

  factory FooObjectWithEveryTypeDiscriminator.fromJson(
      Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "A":
        return FooObjectWithEveryTypeDiscriminatorA.fromJson(_input_);
      case "B":
        return FooObjectWithEveryTypeDiscriminatorB.fromJson(_input_);
      default:
        return FooObjectWithEveryTypeDiscriminator.empty();
    }
  }

  factory FooObjectWithEveryTypeDiscriminator.fromJsonString(String input) {
    return FooObjectWithEveryTypeDiscriminator.fromJson(json.decode(input));
  }
}

class FooObjectWithEveryTypeDiscriminatorA
    implements FooObjectWithEveryTypeDiscriminator {
  final String title;
  const FooObjectWithEveryTypeDiscriminatorA({
    required this.title,
  });

  @override
  String get type => "A";

  factory FooObjectWithEveryTypeDiscriminatorA.empty() {
    return FooObjectWithEveryTypeDiscriminatorA(
      title: "",
    );
  }

  factory FooObjectWithEveryTypeDiscriminatorA.fromJson(
      Map<String, dynamic> _input_) {
    final title = typeFromDynamic<String>(_input_["title"], "");
    return FooObjectWithEveryTypeDiscriminatorA(
      title: title,
    );
  }

  factory FooObjectWithEveryTypeDiscriminatorA.fromJsonString(String input) {
    return FooObjectWithEveryTypeDiscriminatorA.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryTypeDiscriminatorA copyWith({
    String? title,
  }) {
    return FooObjectWithEveryTypeDiscriminatorA(
      title: title ?? this.title,
    );
  }

  @override
  List<Object?> get props => [
        title,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryTypeDiscriminatorA &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryTypeDiscriminatorA ${toJsonString()}";
  }
}

class FooObjectWithEveryTypeDiscriminatorB
    implements FooObjectWithEveryTypeDiscriminator {
  final String title;
  final String description;
  const FooObjectWithEveryTypeDiscriminatorB({
    required this.title,
    required this.description,
  });

  @override
  String get type => "B";

  factory FooObjectWithEveryTypeDiscriminatorB.empty() {
    return FooObjectWithEveryTypeDiscriminatorB(
      title: "",
      description: "",
    );
  }

  factory FooObjectWithEveryTypeDiscriminatorB.fromJson(
      Map<String, dynamic> _input_) {
    final title = typeFromDynamic<String>(_input_["title"], "");
    final description = typeFromDynamic<String>(_input_["description"], "");
    return FooObjectWithEveryTypeDiscriminatorB(
      title: title,
      description: description,
    );
  }

  factory FooObjectWithEveryTypeDiscriminatorB.fromJsonString(String input) {
    return FooObjectWithEveryTypeDiscriminatorB.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    _queryParts_.add("description=$description");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryTypeDiscriminatorB copyWith({
    String? title,
    String? description,
  }) {
    return FooObjectWithEveryTypeDiscriminatorB(
      title: title ?? this.title,
      description: description ?? this.description,
    );
  }

  @override
  List<Object?> get props => [
        title,
        description,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryTypeDiscriminatorB &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryTypeDiscriminatorB ${toJsonString()}";
  }
}

class FooObjectWithEveryTypeNestedObject implements ArriModel {
  final String id;
  final DateTime timestamp;
  final FooObjectWithEveryTypeNestedObjectData data;
  const FooObjectWithEveryTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory FooObjectWithEveryTypeNestedObject.empty() {
    return FooObjectWithEveryTypeNestedObject(
      id: "",
      timestamp: DateTime(0),
      data: FooObjectWithEveryTypeNestedObjectData.empty(),
    );
  }

  factory FooObjectWithEveryTypeNestedObject.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime(0));
    final data = _input_["data"] is Map<String, dynamic>
        ? FooObjectWithEveryTypeNestedObjectData.fromJson(_input_["data"])
        : FooObjectWithEveryTypeNestedObjectData.empty();
    return FooObjectWithEveryTypeNestedObject(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory FooObjectWithEveryTypeNestedObject.fromJsonString(String input) {
    return FooObjectWithEveryTypeNestedObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryTypeNestedObject/data.");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryTypeNestedObject copyWith({
    String? id,
    DateTime? timestamp,
    FooObjectWithEveryTypeNestedObjectData? data,
  }) {
    return FooObjectWithEveryTypeNestedObject(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryTypeNestedObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryTypeNestedObject ${toJsonString()}";
  }
}

class FooObjectWithEveryTypeNestedObjectData implements ArriModel {
  final String id;
  final DateTime timestamp;
  final FooObjectWithEveryTypeNestedObjectDataData data;
  const FooObjectWithEveryTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory FooObjectWithEveryTypeNestedObjectData.empty() {
    return FooObjectWithEveryTypeNestedObjectData(
      id: "",
      timestamp: DateTime(0),
      data: FooObjectWithEveryTypeNestedObjectDataData.empty(),
    );
  }

  factory FooObjectWithEveryTypeNestedObjectData.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime(0));
    final data = _input_["data"] is Map<String, dynamic>
        ? FooObjectWithEveryTypeNestedObjectDataData.fromJson(_input_["data"])
        : FooObjectWithEveryTypeNestedObjectDataData.empty();
    return FooObjectWithEveryTypeNestedObjectData(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory FooObjectWithEveryTypeNestedObjectData.fromJsonString(String input) {
    return FooObjectWithEveryTypeNestedObjectData.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryTypeNestedObjectData/data.");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryTypeNestedObjectData copyWith({
    String? id,
    DateTime? timestamp,
    FooObjectWithEveryTypeNestedObjectDataData? data,
  }) {
    return FooObjectWithEveryTypeNestedObjectData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryTypeNestedObjectData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryTypeNestedObjectData ${toJsonString()}";
  }
}

class FooObjectWithEveryTypeNestedObjectDataData implements ArriModel {
  final String id;
  final DateTime timestamp;
  const FooObjectWithEveryTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });

  factory FooObjectWithEveryTypeNestedObjectDataData.empty() {
    return FooObjectWithEveryTypeNestedObjectDataData(
      id: "",
      timestamp: DateTime(0),
    );
  }

  factory FooObjectWithEveryTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime(0));
    return FooObjectWithEveryTypeNestedObjectDataData(
      id: id,
      timestamp: timestamp,
    );
  }

  factory FooObjectWithEveryTypeNestedObjectDataData.fromJsonString(
      String input) {
    return FooObjectWithEveryTypeNestedObjectDataData.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryTypeNestedObjectDataData copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return FooObjectWithEveryTypeNestedObjectDataData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryTypeNestedObjectDataData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryTypeNestedObjectDataData ${toJsonString()}";
  }
}

class FooObjectWithEveryTypeNestedArrayElementElement implements ArriModel {
  final String id;
  final DateTime timestamp;
  const FooObjectWithEveryTypeNestedArrayElementElement({
    required this.id,
    required this.timestamp,
  });

  factory FooObjectWithEveryTypeNestedArrayElementElement.empty() {
    return FooObjectWithEveryTypeNestedArrayElementElement(
      id: "",
      timestamp: DateTime(0),
    );
  }

  factory FooObjectWithEveryTypeNestedArrayElementElement.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime(0));
    return FooObjectWithEveryTypeNestedArrayElementElement(
      id: id,
      timestamp: timestamp,
    );
  }

  factory FooObjectWithEveryTypeNestedArrayElementElement.fromJsonString(
      String input) {
    return FooObjectWithEveryTypeNestedArrayElementElement.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryTypeNestedArrayElementElement copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return FooObjectWithEveryTypeNestedArrayElementElement(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryTypeNestedArrayElementElement &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryTypeNestedArrayElementElement ${toJsonString()}";
  }
}

class FooObjectWithEveryNullableType implements ArriModel {
  final dynamic any;
  final bool? boolean;
  final String? string;
  final DateTime? timestamp;
  final double? float32;
  final double? float64;
  final int? int8;
  final int? uint8;
  final int? int16;
  final int? uint16;
  final int? int32;
  final int? uint32;
  final BigInt? int64;
  final BigInt? uint64;
  final FooObjectWithEveryNullableTypeEnumerator? enumerator;
  final List<bool?>? array;
  final FooObjectWithEveryNullableTypeObject? object;
  final Map<String, BigInt?>? record;
  final FooObjectWithEveryNullableTypeDiscriminator? discriminator;
  final FooObjectWithEveryNullableTypeNestedObject? nestedObject;
  final List<List<FooObjectWithEveryNullableTypeNestedArrayElementElement?>?>?
      nestedArray;
  const FooObjectWithEveryNullableType({
    required this.any,
    required this.boolean,
    required this.string,
    required this.timestamp,
    required this.float32,
    required this.float64,
    required this.int8,
    required this.uint8,
    required this.int16,
    required this.uint16,
    required this.int32,
    required this.uint32,
    required this.int64,
    required this.uint64,
    required this.enumerator,
    required this.array,
    required this.object,
    required this.record,
    required this.discriminator,
    required this.nestedObject,
    required this.nestedArray,
  });

  factory FooObjectWithEveryNullableType.empty() {
    return FooObjectWithEveryNullableType(
      any: null,
      boolean: null,
      string: null,
      timestamp: null,
      float32: null,
      float64: null,
      int8: null,
      uint8: null,
      int16: null,
      uint16: null,
      int32: null,
      uint32: null,
      int64: null,
      uint64: null,
      enumerator: null,
      array: null,
      object: null,
      record: null,
      discriminator: null,
      nestedObject: null,
      nestedArray: null,
    );
  }

  factory FooObjectWithEveryNullableType.fromJson(
      Map<String, dynamic> _input_) {
    final any = _input_["any"];
    final boolean = nullableTypeFromDynamic<bool>(_input_["boolean"]);
    final string = nullableTypeFromDynamic<String>(_input_["string"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    final float32 = nullableDoubleFromDynamic(_input_["float32"]);
    final float64 = nullableDoubleFromDynamic(_input_["float64"]);
    final int8 = nullableIntFromDynamic(_input_["int8"]);
    final uint8 = nullableIntFromDynamic(_input_["uint8"]);
    final int16 = nullableIntFromDynamic(_input_["int16"]);
    final uint16 = nullableIntFromDynamic(_input_["uint16"]);
    final int32 = nullableIntFromDynamic(_input_["int32"]);
    final uint32 = nullableIntFromDynamic(_input_["uint32"]);
    final int64 = nullableBigIntFromDynamic(_input_["int64"]);
    final uint64 = nullableBigIntFromDynamic(_input_["uint64"]);
    final enumerator = _input_["enumerator"] is String
        ? FooObjectWithEveryNullableTypeEnumerator.fromString(
            _input_["enumerator"])
        : null;
    final array = _input_["array"] is List
        ? (_input_["array"] as List)
            .map((_el_) => nullableTypeFromDynamic<bool>(_el_))
            .toList()
        : null;
    final object = _input_["object"] is Map<String, dynamic>
        ? FooObjectWithEveryNullableTypeObject.fromJson(_input_["object"])
        : null;
    final record = _input_["record"] is Map<String, dynamic>
        ? (_input_["record"] as Map<String, dynamic>).map(
            (_key_, _val_) => MapEntry(
              _key_,
              nullableBigIntFromDynamic(_val_),
            ),
          )
        : null;
    final discriminator = _input_["discriminator"] is Map<String, dynamic>
        ? FooObjectWithEveryNullableTypeDiscriminator.fromJson(
            _input_["discriminator"])
        : null;
    final nestedObject = _input_["nestedObject"] is Map<String, dynamic>
        ? FooObjectWithEveryNullableTypeNestedObject.fromJson(
            _input_["nestedObject"])
        : null;
    final nestedArray = _input_["nestedArray"] is List
        ? (_input_["nestedArray"] as List)
            .map((_el_) => _el_ is List
                ? (_el_ as List)
                    .map((_el_) => _el_ is Map<String, dynamic>
                        ? FooObjectWithEveryNullableTypeNestedArrayElementElement
                            .fromJson(_el_)
                        : null)
                    .toList()
                : null)
            .toList()
        : null;
    return FooObjectWithEveryNullableType(
      any: any,
      boolean: boolean,
      string: string,
      timestamp: timestamp,
      float32: float32,
      float64: float64,
      int8: int8,
      uint8: uint8,
      int16: int16,
      uint16: uint16,
      int32: int32,
      uint32: uint32,
      int64: int64,
      uint64: uint64,
      enumerator: enumerator,
      array: array,
      object: object,
      record: record,
      discriminator: discriminator,
      nestedObject: nestedObject,
      nestedArray: nestedArray,
    );
  }

  factory FooObjectWithEveryNullableType.fromJsonString(String input) {
    return FooObjectWithEveryNullableType.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "any": any,
      "boolean": boolean,
      "string": string,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "float32": float32,
      "float64": float64,
      "int8": int8,
      "uint8": uint8,
      "int16": int16,
      "uint16": uint16,
      "int32": int32,
      "uint32": uint32,
      "int64": int64?.toString(),
      "uint64": uint64?.toString(),
      "enumerator": enumerator?.serialValue,
      "array": array?.map((_el_) => _el_).toList(),
      "object": object?.toJson(),
      "record": record?.map(
        (_key_, _val_) => MapEntry(
          _key_,
          _val_?.toString(),
        ),
      ),
      "discriminator": discriminator?.toJson(),
      "nestedObject": nestedObject?.toJson(),
      "nestedArray": nestedArray
          ?.map((_el_) => _el_?.map((_el_) => _el_?.toJson()).toList())
          .toList(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    print(
        "[WARNING] any's cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/any.");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("string=$string");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    _queryParts_.add("float32=$float32");
    _queryParts_.add("float64=$float64");
    _queryParts_.add("int8=$int8");
    _queryParts_.add("uint8=$uint8");
    _queryParts_.add("int16=$int16");
    _queryParts_.add("uint16=$uint16");
    _queryParts_.add("int32=$int32");
    _queryParts_.add("uint32=$uint32");
    _queryParts_.add("int64=$int64");
    _queryParts_.add("uint64=$uint64");
    _queryParts_.add("enumerator=${enumerator?.serialValue}");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/array.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/object.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/record.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/discriminator.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/nestedObject.");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/nestedArray.");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryNullableType copyWith({
    dynamic Function()? any,
    bool? Function()? boolean,
    String? Function()? string,
    DateTime? Function()? timestamp,
    double? Function()? float32,
    double? Function()? float64,
    int? Function()? int8,
    int? Function()? uint8,
    int? Function()? int16,
    int? Function()? uint16,
    int? Function()? int32,
    int? Function()? uint32,
    BigInt? Function()? int64,
    BigInt? Function()? uint64,
    FooObjectWithEveryNullableTypeEnumerator? Function()? enumerator,
    List<bool?>? Function()? array,
    FooObjectWithEveryNullableTypeObject? Function()? object,
    Map<String, BigInt?>? Function()? record,
    FooObjectWithEveryNullableTypeDiscriminator? Function()? discriminator,
    FooObjectWithEveryNullableTypeNestedObject? Function()? nestedObject,
    List<List<FooObjectWithEveryNullableTypeNestedArrayElementElement?>?>?
            Function()?
        nestedArray,
  }) {
    return FooObjectWithEveryNullableType(
      any: any != null ? any() : this.any,
      boolean: boolean != null ? boolean() : this.boolean,
      string: string != null ? string() : this.string,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
      float32: float32 != null ? float32() : this.float32,
      float64: float64 != null ? float64() : this.float64,
      int8: int8 != null ? int8() : this.int8,
      uint8: uint8 != null ? uint8() : this.uint8,
      int16: int16 != null ? int16() : this.int16,
      uint16: uint16 != null ? uint16() : this.uint16,
      int32: int32 != null ? int32() : this.int32,
      uint32: uint32 != null ? uint32() : this.uint32,
      int64: int64 != null ? int64() : this.int64,
      uint64: uint64 != null ? uint64() : this.uint64,
      enumerator: enumerator != null ? enumerator() : this.enumerator,
      array: array != null ? array() : this.array,
      object: object != null ? object() : this.object,
      record: record != null ? record() : this.record,
      discriminator:
          discriminator != null ? discriminator() : this.discriminator,
      nestedObject: nestedObject != null ? nestedObject() : this.nestedObject,
      nestedArray: nestedArray != null ? nestedArray() : this.nestedArray,
    );
  }

  @override
  List<Object?> get props => [
        any,
        boolean,
        string,
        timestamp,
        float32,
        float64,
        int8,
        uint8,
        int16,
        uint16,
        int32,
        uint32,
        int64,
        uint64,
        enumerator,
        array,
        object,
        record,
        discriminator,
        nestedObject,
        nestedArray,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryNullableType &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryNullableType ${toJsonString()}";
  }
}

enum FooObjectWithEveryNullableTypeEnumerator
    implements Comparable<FooObjectWithEveryNullableTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const FooObjectWithEveryNullableTypeEnumerator(this.serialValue);
  final String serialValue;

  factory FooObjectWithEveryNullableTypeEnumerator.fromString(String input) {
    for (final val in values) {
      if (val.serialValue == input) {
        return val;
      }
    }
    return a;
  }

  @override
  int compareTo(FooObjectWithEveryNullableTypeEnumerator other) =>
      name.compareTo(other.name);
}

class FooObjectWithEveryNullableTypeObject implements ArriModel {
  final String? string;
  final bool? boolean;
  final DateTime? timestamp;
  const FooObjectWithEveryNullableTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });

  factory FooObjectWithEveryNullableTypeObject.empty() {
    return FooObjectWithEveryNullableTypeObject(
      string: null,
      boolean: null,
      timestamp: null,
    );
  }

  factory FooObjectWithEveryNullableTypeObject.fromJson(
      Map<String, dynamic> _input_) {
    final string = nullableTypeFromDynamic<String>(_input_["string"]);
    final boolean = nullableTypeFromDynamic<bool>(_input_["boolean"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    return FooObjectWithEveryNullableTypeObject(
      string: string,
      boolean: boolean,
      timestamp: timestamp,
    );
  }

  factory FooObjectWithEveryNullableTypeObject.fromJsonString(String input) {
    return FooObjectWithEveryNullableTypeObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("string=$string");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryNullableTypeObject copyWith({
    String? Function()? string,
    bool? Function()? boolean,
    DateTime? Function()? timestamp,
  }) {
    return FooObjectWithEveryNullableTypeObject(
      string: string != null ? string() : this.string,
      boolean: boolean != null ? boolean() : this.boolean,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        string,
        boolean,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryNullableTypeObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryNullableTypeObject ${toJsonString()}";
  }
}

sealed class FooObjectWithEveryNullableTypeDiscriminator implements ArriModel {
  String get type;
  const FooObjectWithEveryNullableTypeDiscriminator();

  factory FooObjectWithEveryNullableTypeDiscriminator.empty() {
    return FooObjectWithEveryNullableTypeDiscriminatorA.empty();
  }

  factory FooObjectWithEveryNullableTypeDiscriminator.fromJson(
      Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "A":
        return FooObjectWithEveryNullableTypeDiscriminatorA.fromJson(_input_);
      case "B":
        return FooObjectWithEveryNullableTypeDiscriminatorB.fromJson(_input_);
      default:
        return FooObjectWithEveryNullableTypeDiscriminator.empty();
    }
  }

  factory FooObjectWithEveryNullableTypeDiscriminator.fromJsonString(
      String input) {
    return FooObjectWithEveryNullableTypeDiscriminator.fromJson(
        json.decode(input));
  }
}

class FooObjectWithEveryNullableTypeDiscriminatorA
    implements FooObjectWithEveryNullableTypeDiscriminator {
  final String? title;
  const FooObjectWithEveryNullableTypeDiscriminatorA({
    required this.title,
  });

  @override
  String get type => "A";

  factory FooObjectWithEveryNullableTypeDiscriminatorA.empty() {
    return FooObjectWithEveryNullableTypeDiscriminatorA(
      title: null,
    );
  }

  factory FooObjectWithEveryNullableTypeDiscriminatorA.fromJson(
      Map<String, dynamic> _input_) {
    final title = nullableTypeFromDynamic<String>(_input_["title"]);
    return FooObjectWithEveryNullableTypeDiscriminatorA(
      title: title,
    );
  }

  factory FooObjectWithEveryNullableTypeDiscriminatorA.fromJsonString(
      String input) {
    return FooObjectWithEveryNullableTypeDiscriminatorA.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryNullableTypeDiscriminatorA copyWith({
    String? Function()? title,
  }) {
    return FooObjectWithEveryNullableTypeDiscriminatorA(
      title: title != null ? title() : this.title,
    );
  }

  @override
  List<Object?> get props => [
        title,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryNullableTypeDiscriminatorA &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryNullableTypeDiscriminatorA ${toJsonString()}";
  }
}

class FooObjectWithEveryNullableTypeDiscriminatorB
    implements FooObjectWithEveryNullableTypeDiscriminator {
  final String? title;
  final String? description;
  const FooObjectWithEveryNullableTypeDiscriminatorB({
    required this.title,
    required this.description,
  });

  @override
  String get type => "B";

  factory FooObjectWithEveryNullableTypeDiscriminatorB.empty() {
    return FooObjectWithEveryNullableTypeDiscriminatorB(
      title: null,
      description: null,
    );
  }

  factory FooObjectWithEveryNullableTypeDiscriminatorB.fromJson(
      Map<String, dynamic> _input_) {
    final title = nullableTypeFromDynamic<String>(_input_["title"]);
    final description = nullableTypeFromDynamic<String>(_input_["description"]);
    return FooObjectWithEveryNullableTypeDiscriminatorB(
      title: title,
      description: description,
    );
  }

  factory FooObjectWithEveryNullableTypeDiscriminatorB.fromJsonString(
      String input) {
    return FooObjectWithEveryNullableTypeDiscriminatorB.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    _queryParts_.add("description=$description");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryNullableTypeDiscriminatorB copyWith({
    String? Function()? title,
    String? Function()? description,
  }) {
    return FooObjectWithEveryNullableTypeDiscriminatorB(
      title: title != null ? title() : this.title,
      description: description != null ? description() : this.description,
    );
  }

  @override
  List<Object?> get props => [
        title,
        description,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryNullableTypeDiscriminatorB &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryNullableTypeDiscriminatorB ${toJsonString()}";
  }
}

class FooObjectWithEveryNullableTypeNestedObject implements ArriModel {
  final String? id;
  final DateTime? timestamp;
  final FooObjectWithEveryNullableTypeNestedObjectData? data;
  const FooObjectWithEveryNullableTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory FooObjectWithEveryNullableTypeNestedObject.empty() {
    return FooObjectWithEveryNullableTypeNestedObject(
      id: null,
      timestamp: null,
      data: null,
    );
  }

  factory FooObjectWithEveryNullableTypeNestedObject.fromJson(
      Map<String, dynamic> _input_) {
    final id = nullableTypeFromDynamic<String>(_input_["id"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    final data = _input_["data"] is Map<String, dynamic>
        ? FooObjectWithEveryNullableTypeNestedObjectData.fromJson(
            _input_["data"])
        : null;
    return FooObjectWithEveryNullableTypeNestedObject(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory FooObjectWithEveryNullableTypeNestedObject.fromJsonString(
      String input) {
    return FooObjectWithEveryNullableTypeNestedObject.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "data": data?.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableTypeNestedObject/data.");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryNullableTypeNestedObject copyWith({
    String? Function()? id,
    DateTime? Function()? timestamp,
    FooObjectWithEveryNullableTypeNestedObjectData? Function()? data,
  }) {
    return FooObjectWithEveryNullableTypeNestedObject(
      id: id != null ? id() : this.id,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
      data: data != null ? data() : this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryNullableTypeNestedObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryNullableTypeNestedObject ${toJsonString()}";
  }
}

class FooObjectWithEveryNullableTypeNestedObjectData implements ArriModel {
  final String? id;
  final DateTime? timestamp;
  final FooObjectWithEveryNullableTypeNestedObjectDataData? data;
  const FooObjectWithEveryNullableTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory FooObjectWithEveryNullableTypeNestedObjectData.empty() {
    return FooObjectWithEveryNullableTypeNestedObjectData(
      id: null,
      timestamp: null,
      data: null,
    );
  }

  factory FooObjectWithEveryNullableTypeNestedObjectData.fromJson(
      Map<String, dynamic> _input_) {
    final id = nullableTypeFromDynamic<String>(_input_["id"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    final data = _input_["data"] is Map<String, dynamic>
        ? FooObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
            _input_["data"])
        : null;
    return FooObjectWithEveryNullableTypeNestedObjectData(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory FooObjectWithEveryNullableTypeNestedObjectData.fromJsonString(
      String input) {
    return FooObjectWithEveryNullableTypeNestedObjectData.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "data": data?.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableTypeNestedObjectData/data.");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryNullableTypeNestedObjectData copyWith({
    String? Function()? id,
    DateTime? Function()? timestamp,
    FooObjectWithEveryNullableTypeNestedObjectDataData? Function()? data,
  }) {
    return FooObjectWithEveryNullableTypeNestedObjectData(
      id: id != null ? id() : this.id,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
      data: data != null ? data() : this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryNullableTypeNestedObjectData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryNullableTypeNestedObjectData ${toJsonString()}";
  }
}

class FooObjectWithEveryNullableTypeNestedObjectDataData implements ArriModel {
  final String? id;
  final DateTime? timestamp;
  const FooObjectWithEveryNullableTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });

  factory FooObjectWithEveryNullableTypeNestedObjectDataData.empty() {
    return FooObjectWithEveryNullableTypeNestedObjectDataData(
      id: null,
      timestamp: null,
    );
  }

  factory FooObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> _input_) {
    final id = nullableTypeFromDynamic<String>(_input_["id"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    return FooObjectWithEveryNullableTypeNestedObjectDataData(
      id: id,
      timestamp: timestamp,
    );
  }

  factory FooObjectWithEveryNullableTypeNestedObjectDataData.fromJsonString(
      String input) {
    return FooObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryNullableTypeNestedObjectDataData copyWith({
    String? Function()? id,
    DateTime? Function()? timestamp,
  }) {
    return FooObjectWithEveryNullableTypeNestedObjectDataData(
      id: id != null ? id() : this.id,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryNullableTypeNestedObjectDataData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryNullableTypeNestedObjectDataData ${toJsonString()}";
  }
}

class FooObjectWithEveryNullableTypeNestedArrayElementElement
    implements ArriModel {
  final String? id;
  final DateTime? timestamp;
  const FooObjectWithEveryNullableTypeNestedArrayElementElement({
    required this.id,
    required this.timestamp,
  });

  factory FooObjectWithEveryNullableTypeNestedArrayElementElement.empty() {
    return FooObjectWithEveryNullableTypeNestedArrayElementElement(
      id: null,
      timestamp: null,
    );
  }

  factory FooObjectWithEveryNullableTypeNestedArrayElementElement.fromJson(
      Map<String, dynamic> _input_) {
    final id = nullableTypeFromDynamic<String>(_input_["id"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    return FooObjectWithEveryNullableTypeNestedArrayElementElement(
      id: id,
      timestamp: timestamp,
    );
  }

  factory FooObjectWithEveryNullableTypeNestedArrayElementElement.fromJsonString(
      String input) {
    return FooObjectWithEveryNullableTypeNestedArrayElementElement.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryNullableTypeNestedArrayElementElement copyWith({
    String? Function()? id,
    DateTime? Function()? timestamp,
  }) {
    return FooObjectWithEveryNullableTypeNestedArrayElementElement(
      id: id != null ? id() : this.id,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryNullableTypeNestedArrayElementElement &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryNullableTypeNestedArrayElementElement ${toJsonString()}";
  }
}

class FooObjectWithPascalCaseKeys implements ArriModel {
  final DateTime createdAt;
  final String displayName;
  final String? phoneNumber;
  final String? emailAddress;
  final bool? isAdmin;
  const FooObjectWithPascalCaseKeys({
    required this.createdAt,
    required this.displayName,
    required this.phoneNumber,
    this.emailAddress,
    this.isAdmin,
  });

  factory FooObjectWithPascalCaseKeys.empty() {
    return FooObjectWithPascalCaseKeys(
      createdAt: DateTime(0),
      displayName: "",
      phoneNumber: null,
    );
  }

  factory FooObjectWithPascalCaseKeys.fromJson(Map<String, dynamic> _input_) {
    final createdAt = dateTimeFromDynamic(_input_["CreatedAt"], DateTime(0));
    final displayName = typeFromDynamic<String>(_input_["DisplayName"], "");
    final phoneNumber = nullableTypeFromDynamic<String>(_input_["PhoneNumber"]);
    final emailAddress =
        nullableTypeFromDynamic<String>(_input_["EmailAddress"]);
    final isAdmin = nullableTypeFromDynamic<bool>(_input_["IsAdmin"]);
    return FooObjectWithPascalCaseKeys(
      createdAt: createdAt,
      displayName: displayName,
      phoneNumber: phoneNumber,
      emailAddress: emailAddress,
      isAdmin: isAdmin,
    );
  }

  factory FooObjectWithPascalCaseKeys.fromJsonString(String input) {
    return FooObjectWithPascalCaseKeys.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "CreatedAt": createdAt.toUtc().toIso8601String(),
      "DisplayName": displayName,
      "PhoneNumber": phoneNumber,
    };
    if (emailAddress != null) _output_["EmailAddress"] = emailAddress;
    if (isAdmin != null) _output_["IsAdmin"] = isAdmin;
    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("CreatedAt=${createdAt.toUtc().toIso8601String()}");
    _queryParts_.add("DisplayName=$displayName");
    _queryParts_.add("PhoneNumber=$phoneNumber");
    if (emailAddress != null) _queryParts_.add("EmailAddress=$emailAddress");
    if (isAdmin != null) _queryParts_.add("IsAdmin=$isAdmin");
    return _queryParts_.join("&");
  }

  FooObjectWithPascalCaseKeys copyWith({
    DateTime? createdAt,
    String? displayName,
    String? Function()? phoneNumber,
    String? Function()? emailAddress,
    bool? Function()? isAdmin,
  }) {
    return FooObjectWithPascalCaseKeys(
      createdAt: createdAt ?? this.createdAt,
      displayName: displayName ?? this.displayName,
      phoneNumber: phoneNumber != null ? phoneNumber() : this.phoneNumber,
      emailAddress: emailAddress != null ? emailAddress() : this.emailAddress,
      isAdmin: isAdmin != null ? isAdmin() : this.isAdmin,
    );
  }

  @override
  List<Object?> get props => [
        createdAt,
        displayName,
        phoneNumber,
        emailAddress,
        isAdmin,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithPascalCaseKeys &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithPascalCaseKeys ${toJsonString()}";
  }
}

class FooObjectWithSnakeCaseKeys implements ArriModel {
  final DateTime createdAt;
  final String displayName;
  final String? phoneNumber;
  final String? emailAddress;
  final bool? isAdmin;
  const FooObjectWithSnakeCaseKeys({
    required this.createdAt,
    required this.displayName,
    required this.phoneNumber,
    this.emailAddress,
    this.isAdmin,
  });

  factory FooObjectWithSnakeCaseKeys.empty() {
    return FooObjectWithSnakeCaseKeys(
      createdAt: DateTime(0),
      displayName: "",
      phoneNumber: null,
    );
  }

  factory FooObjectWithSnakeCaseKeys.fromJson(Map<String, dynamic> _input_) {
    final createdAt = dateTimeFromDynamic(_input_["created_at"], DateTime(0));
    final displayName = typeFromDynamic<String>(_input_["display_name"], "");
    final phoneNumber =
        nullableTypeFromDynamic<String>(_input_["phone_number"]);
    final emailAddress =
        nullableTypeFromDynamic<String>(_input_["email_address"]);
    final isAdmin = nullableTypeFromDynamic<bool>(_input_["is_admin"]);
    return FooObjectWithSnakeCaseKeys(
      createdAt: createdAt,
      displayName: displayName,
      phoneNumber: phoneNumber,
      emailAddress: emailAddress,
      isAdmin: isAdmin,
    );
  }

  factory FooObjectWithSnakeCaseKeys.fromJsonString(String input) {
    return FooObjectWithSnakeCaseKeys.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "created_at": createdAt.toUtc().toIso8601String(),
      "display_name": displayName,
      "phone_number": phoneNumber,
    };
    if (emailAddress != null) _output_["email_address"] = emailAddress;
    if (isAdmin != null) _output_["is_admin"] = isAdmin;
    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("created_at=${createdAt.toUtc().toIso8601String()}");
    _queryParts_.add("display_name=$displayName");
    _queryParts_.add("phone_number=$phoneNumber");
    if (emailAddress != null) _queryParts_.add("email_address=$emailAddress");
    if (isAdmin != null) _queryParts_.add("is_admin=$isAdmin");
    return _queryParts_.join("&");
  }

  FooObjectWithSnakeCaseKeys copyWith({
    DateTime? createdAt,
    String? displayName,
    String? Function()? phoneNumber,
    String? Function()? emailAddress,
    bool? Function()? isAdmin,
  }) {
    return FooObjectWithSnakeCaseKeys(
      createdAt: createdAt ?? this.createdAt,
      displayName: displayName ?? this.displayName,
      phoneNumber: phoneNumber != null ? phoneNumber() : this.phoneNumber,
      emailAddress: emailAddress != null ? emailAddress() : this.emailAddress,
      isAdmin: isAdmin != null ? isAdmin() : this.isAdmin,
    );
  }

  @override
  List<Object?> get props => [
        createdAt,
        displayName,
        phoneNumber,
        emailAddress,
        isAdmin,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithSnakeCaseKeys &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithSnakeCaseKeys ${toJsonString()}";
  }
}

class FooObjectWithEveryOptionalType implements ArriModel {
  final dynamic any;
  final bool? boolean;
  final String? string;
  final DateTime? timestamp;
  final double? float32;
  final double? float64;
  final int? int8;
  final int? uint8;
  final int? int16;
  final int? uint16;
  final int? int32;
  final int? uint32;
  final BigInt? int64;
  final BigInt? uint64;
  final FooObjectWithEveryOptionalTypeEnumerator? enumerator;
  final List<bool>? array;
  final FooObjectWithEveryOptionalTypeObject? object;
  final Map<String, BigInt>? record;
  final FooObjectWithEveryOptionalTypeDiscriminator? discriminator;
  final FooObjectWithEveryOptionalTypeNestedObject? nestedObject;
  final List<List<FooObjectWithEveryOptionalTypeNestedArrayElementElement>>?
      nestedArray;
  const FooObjectWithEveryOptionalType({
    this.any,
    this.boolean,
    this.string,
    this.timestamp,
    this.float32,
    this.float64,
    this.int8,
    this.uint8,
    this.int16,
    this.uint16,
    this.int32,
    this.uint32,
    this.int64,
    this.uint64,
    this.enumerator,
    this.array,
    this.object,
    this.record,
    this.discriminator,
    this.nestedObject,
    this.nestedArray,
  });

  factory FooObjectWithEveryOptionalType.empty() {
    return FooObjectWithEveryOptionalType();
  }

  factory FooObjectWithEveryOptionalType.fromJson(
      Map<String, dynamic> _input_) {
    final any = _input_["any"];
    final boolean = nullableTypeFromDynamic<bool>(_input_["boolean"]);
    final string = nullableTypeFromDynamic<String>(_input_["string"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    final float32 = nullableDoubleFromDynamic(_input_["float32"]);
    final float64 = nullableDoubleFromDynamic(_input_["float64"]);
    final int8 = nullableIntFromDynamic(_input_["int8"]);
    final uint8 = nullableIntFromDynamic(_input_["uint8"]);
    final int16 = nullableIntFromDynamic(_input_["int16"]);
    final uint16 = nullableIntFromDynamic(_input_["uint16"]);
    final int32 = nullableIntFromDynamic(_input_["int32"]);
    final uint32 = nullableIntFromDynamic(_input_["uint32"]);
    final int64 = nullableBigIntFromDynamic(_input_["int64"]);
    final uint64 = nullableBigIntFromDynamic(_input_["uint64"]);
    final enumerator = _input_["enumerator"] is String
        ? FooObjectWithEveryOptionalTypeEnumerator.fromString(
            _input_["enumerator"])
        : null;
    final array = _input_["array"] is List
        ? (_input_["array"] as List)
            .map((_el_) => typeFromDynamic<bool>(_el_, false))
            .toList()
        : null;
    final object = _input_["object"] is Map<String, dynamic>
        ? FooObjectWithEveryOptionalTypeObject.fromJson(_input_["object"])
        : null;
    final record = _input_["record"] is Map<String, dynamic>
        ? (_input_["record"] as Map<String, dynamic>).map(
            (_key_, _val_) => MapEntry(
              _key_,
              bigIntFromDynamic(_val_, BigInt.zero),
            ),
          )
        : null;
    final discriminator = _input_["discriminator"] is Map<String, dynamic>
        ? FooObjectWithEveryOptionalTypeDiscriminator.fromJson(
            _input_["discriminator"])
        : null;
    final nestedObject = _input_["nestedObject"] is Map<String, dynamic>
        ? FooObjectWithEveryOptionalTypeNestedObject.fromJson(
            _input_["nestedObject"])
        : null;
    final nestedArray = _input_["nestedArray"] is List
        ? (_input_["nestedArray"] as List)
            .map((_el_) => _el_ is List
                ? (_el_ as List)
                    .map((_el_) => _el_ is Map<String, dynamic>
                        ? FooObjectWithEveryOptionalTypeNestedArrayElementElement
                            .fromJson(_el_)
                        : FooObjectWithEveryOptionalTypeNestedArrayElementElement
                            .empty())
                    .toList()
                : <FooObjectWithEveryOptionalTypeNestedArrayElementElement>[])
            .toList()
        : null;
    return FooObjectWithEveryOptionalType(
      any: any,
      boolean: boolean,
      string: string,
      timestamp: timestamp,
      float32: float32,
      float64: float64,
      int8: int8,
      uint8: uint8,
      int16: int16,
      uint16: uint16,
      int32: int32,
      uint32: uint32,
      int64: int64,
      uint64: uint64,
      enumerator: enumerator,
      array: array,
      object: object,
      record: record,
      discriminator: discriminator,
      nestedObject: nestedObject,
      nestedArray: nestedArray,
    );
  }

  factory FooObjectWithEveryOptionalType.fromJsonString(String input) {
    return FooObjectWithEveryOptionalType.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{};
    if (any != null) _output_["any"] = any;
    if (boolean != null) _output_["boolean"] = boolean;
    if (string != null) _output_["string"] = string;
    if (timestamp != null)
      _output_["timestamp"] = timestamp!.toUtc().toIso8601String();
    if (float32 != null) _output_["float32"] = float32;
    if (float64 != null) _output_["float64"] = float64;
    if (int8 != null) _output_["int8"] = int8;
    if (uint8 != null) _output_["uint8"] = uint8;
    if (int16 != null) _output_["int16"] = int16;
    if (uint16 != null) _output_["uint16"] = uint16;
    if (int32 != null) _output_["int32"] = int32;
    if (uint32 != null) _output_["uint32"] = uint32;
    if (int64 != null) _output_["int64"] = int64!.toString();
    if (uint64 != null) _output_["uint64"] = uint64!.toString();
    if (enumerator != null) _output_["enumerator"] = enumerator!.serialValue;
    if (array != null) _output_["array"] = array!.map((_el_) => _el_).toList();
    if (object != null) _output_["object"] = object!.toJson();
    if (record != null)
      _output_["record"] = record!.map(
        (_key_, _val_) => MapEntry(
          _key_,
          _val_.toString(),
        ),
      );
    if (discriminator != null)
      _output_["discriminator"] = discriminator!.toJson();
    if (nestedObject != null) _output_["nestedObject"] = nestedObject!.toJson();
    if (nestedArray != null)
      _output_["nestedArray"] = nestedArray!
          .map((_el_) => _el_.map((_el_) => _el_.toJson()).toList())
          .toList();
    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    print(
        "[WARNING] any's cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/any.");
    if (boolean != null) _queryParts_.add("boolean=$boolean");
    if (string != null) _queryParts_.add("string=$string");
    if (timestamp != null)
      _queryParts_.add("timestamp=${timestamp!.toUtc().toIso8601String()}");
    if (float32 != null) _queryParts_.add("float32=$float32");
    if (float64 != null) _queryParts_.add("float64=$float64");
    if (int8 != null) _queryParts_.add("int8=$int8");
    if (uint8 != null) _queryParts_.add("uint8=$uint8");
    if (int16 != null) _queryParts_.add("int16=$int16");
    if (uint16 != null) _queryParts_.add("uint16=$uint16");
    if (int32 != null) _queryParts_.add("int32=$int32");
    if (uint32 != null) _queryParts_.add("uint32=$uint32");
    if (int64 != null) _queryParts_.add("int64=$int64");
    if (uint64 != null) _queryParts_.add("uint64=$uint64");
    if (enumerator != null)
      _queryParts_.add("enumerator=${enumerator!.serialValue}");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/array.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/object.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/record.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/discriminator.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/nestedObject.");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/nestedArray.");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryOptionalType copyWith({
    dynamic Function()? any,
    bool? Function()? boolean,
    String? Function()? string,
    DateTime? Function()? timestamp,
    double? Function()? float32,
    double? Function()? float64,
    int? Function()? int8,
    int? Function()? uint8,
    int? Function()? int16,
    int? Function()? uint16,
    int? Function()? int32,
    int? Function()? uint32,
    BigInt? Function()? int64,
    BigInt? Function()? uint64,
    FooObjectWithEveryOptionalTypeEnumerator? Function()? enumerator,
    List<bool>? Function()? array,
    FooObjectWithEveryOptionalTypeObject? Function()? object,
    Map<String, BigInt>? Function()? record,
    FooObjectWithEveryOptionalTypeDiscriminator? Function()? discriminator,
    FooObjectWithEveryOptionalTypeNestedObject? Function()? nestedObject,
    List<List<FooObjectWithEveryOptionalTypeNestedArrayElementElement>>?
            Function()?
        nestedArray,
  }) {
    return FooObjectWithEveryOptionalType(
      any: any != null ? any() : this.any,
      boolean: boolean != null ? boolean() : this.boolean,
      string: string != null ? string() : this.string,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
      float32: float32 != null ? float32() : this.float32,
      float64: float64 != null ? float64() : this.float64,
      int8: int8 != null ? int8() : this.int8,
      uint8: uint8 != null ? uint8() : this.uint8,
      int16: int16 != null ? int16() : this.int16,
      uint16: uint16 != null ? uint16() : this.uint16,
      int32: int32 != null ? int32() : this.int32,
      uint32: uint32 != null ? uint32() : this.uint32,
      int64: int64 != null ? int64() : this.int64,
      uint64: uint64 != null ? uint64() : this.uint64,
      enumerator: enumerator != null ? enumerator() : this.enumerator,
      array: array != null ? array() : this.array,
      object: object != null ? object() : this.object,
      record: record != null ? record() : this.record,
      discriminator:
          discriminator != null ? discriminator() : this.discriminator,
      nestedObject: nestedObject != null ? nestedObject() : this.nestedObject,
      nestedArray: nestedArray != null ? nestedArray() : this.nestedArray,
    );
  }

  @override
  List<Object?> get props => [
        any,
        boolean,
        string,
        timestamp,
        float32,
        float64,
        int8,
        uint8,
        int16,
        uint16,
        int32,
        uint32,
        int64,
        uint64,
        enumerator,
        array,
        object,
        record,
        discriminator,
        nestedObject,
        nestedArray,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryOptionalType &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryOptionalType ${toJsonString()}";
  }
}

enum FooObjectWithEveryOptionalTypeEnumerator
    implements Comparable<FooObjectWithEveryOptionalTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const FooObjectWithEveryOptionalTypeEnumerator(this.serialValue);
  final String serialValue;

  factory FooObjectWithEveryOptionalTypeEnumerator.fromString(String input) {
    for (final val in values) {
      if (val.serialValue == input) {
        return val;
      }
    }
    return a;
  }

  @override
  int compareTo(FooObjectWithEveryOptionalTypeEnumerator other) =>
      name.compareTo(other.name);
}

class FooObjectWithEveryOptionalTypeObject implements ArriModel {
  final String string;
  final bool boolean;
  final DateTime timestamp;
  const FooObjectWithEveryOptionalTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });

  factory FooObjectWithEveryOptionalTypeObject.empty() {
    return FooObjectWithEveryOptionalTypeObject(
      string: "",
      boolean: false,
      timestamp: DateTime(0),
    );
  }

  factory FooObjectWithEveryOptionalTypeObject.fromJson(
      Map<String, dynamic> _input_) {
    final string = typeFromDynamic<String>(_input_["string"], "");
    final boolean = typeFromDynamic<bool>(_input_["boolean"], false);
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime(0));
    return FooObjectWithEveryOptionalTypeObject(
      string: string,
      boolean: boolean,
      timestamp: timestamp,
    );
  }

  factory FooObjectWithEveryOptionalTypeObject.fromJsonString(String input) {
    return FooObjectWithEveryOptionalTypeObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("string=$string");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryOptionalTypeObject copyWith({
    String? string,
    bool? boolean,
    DateTime? timestamp,
  }) {
    return FooObjectWithEveryOptionalTypeObject(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        string,
        boolean,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryOptionalTypeObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryOptionalTypeObject ${toJsonString()}";
  }
}

sealed class FooObjectWithEveryOptionalTypeDiscriminator implements ArriModel {
  String get type;
  const FooObjectWithEveryOptionalTypeDiscriminator();

  factory FooObjectWithEveryOptionalTypeDiscriminator.empty() {
    return FooObjectWithEveryOptionalTypeDiscriminatorA.empty();
  }

  factory FooObjectWithEveryOptionalTypeDiscriminator.fromJson(
      Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "A":
        return FooObjectWithEveryOptionalTypeDiscriminatorA.fromJson(_input_);
      case "B":
        return FooObjectWithEveryOptionalTypeDiscriminatorB.fromJson(_input_);
      default:
        return FooObjectWithEveryOptionalTypeDiscriminator.empty();
    }
  }

  factory FooObjectWithEveryOptionalTypeDiscriminator.fromJsonString(
      String input) {
    return FooObjectWithEveryOptionalTypeDiscriminator.fromJson(
        json.decode(input));
  }
}

class FooObjectWithEveryOptionalTypeDiscriminatorA
    implements FooObjectWithEveryOptionalTypeDiscriminator {
  final String title;
  const FooObjectWithEveryOptionalTypeDiscriminatorA({
    required this.title,
  });

  @override
  String get type => "A";

  factory FooObjectWithEveryOptionalTypeDiscriminatorA.empty() {
    return FooObjectWithEveryOptionalTypeDiscriminatorA(
      title: "",
    );
  }

  factory FooObjectWithEveryOptionalTypeDiscriminatorA.fromJson(
      Map<String, dynamic> _input_) {
    final title = typeFromDynamic<String>(_input_["title"], "");
    return FooObjectWithEveryOptionalTypeDiscriminatorA(
      title: title,
    );
  }

  factory FooObjectWithEveryOptionalTypeDiscriminatorA.fromJsonString(
      String input) {
    return FooObjectWithEveryOptionalTypeDiscriminatorA.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryOptionalTypeDiscriminatorA copyWith({
    String? title,
  }) {
    return FooObjectWithEveryOptionalTypeDiscriminatorA(
      title: title ?? this.title,
    );
  }

  @override
  List<Object?> get props => [
        title,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryOptionalTypeDiscriminatorA &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryOptionalTypeDiscriminatorA ${toJsonString()}";
  }
}

class FooObjectWithEveryOptionalTypeDiscriminatorB
    implements FooObjectWithEveryOptionalTypeDiscriminator {
  final String title;
  final String description;
  const FooObjectWithEveryOptionalTypeDiscriminatorB({
    required this.title,
    required this.description,
  });

  @override
  String get type => "B";

  factory FooObjectWithEveryOptionalTypeDiscriminatorB.empty() {
    return FooObjectWithEveryOptionalTypeDiscriminatorB(
      title: "",
      description: "",
    );
  }

  factory FooObjectWithEveryOptionalTypeDiscriminatorB.fromJson(
      Map<String, dynamic> _input_) {
    final title = typeFromDynamic<String>(_input_["title"], "");
    final description = typeFromDynamic<String>(_input_["description"], "");
    return FooObjectWithEveryOptionalTypeDiscriminatorB(
      title: title,
      description: description,
    );
  }

  factory FooObjectWithEveryOptionalTypeDiscriminatorB.fromJsonString(
      String input) {
    return FooObjectWithEveryOptionalTypeDiscriminatorB.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    _queryParts_.add("description=$description");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryOptionalTypeDiscriminatorB copyWith({
    String? title,
    String? description,
  }) {
    return FooObjectWithEveryOptionalTypeDiscriminatorB(
      title: title ?? this.title,
      description: description ?? this.description,
    );
  }

  @override
  List<Object?> get props => [
        title,
        description,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryOptionalTypeDiscriminatorB &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryOptionalTypeDiscriminatorB ${toJsonString()}";
  }
}

class FooObjectWithEveryOptionalTypeNestedObject implements ArriModel {
  final String id;
  final DateTime timestamp;
  final FooObjectWithEveryOptionalTypeNestedObjectData data;
  const FooObjectWithEveryOptionalTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory FooObjectWithEveryOptionalTypeNestedObject.empty() {
    return FooObjectWithEveryOptionalTypeNestedObject(
      id: "",
      timestamp: DateTime(0),
      data: FooObjectWithEveryOptionalTypeNestedObjectData.empty(),
    );
  }

  factory FooObjectWithEveryOptionalTypeNestedObject.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime(0));
    final data = _input_["data"] is Map<String, dynamic>
        ? FooObjectWithEveryOptionalTypeNestedObjectData.fromJson(
            _input_["data"])
        : FooObjectWithEveryOptionalTypeNestedObjectData.empty();
    return FooObjectWithEveryOptionalTypeNestedObject(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory FooObjectWithEveryOptionalTypeNestedObject.fromJsonString(
      String input) {
    return FooObjectWithEveryOptionalTypeNestedObject.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalTypeNestedObject/data.");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryOptionalTypeNestedObject copyWith({
    String? id,
    DateTime? timestamp,
    FooObjectWithEveryOptionalTypeNestedObjectData? data,
  }) {
    return FooObjectWithEveryOptionalTypeNestedObject(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryOptionalTypeNestedObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryOptionalTypeNestedObject ${toJsonString()}";
  }
}

class FooObjectWithEveryOptionalTypeNestedObjectData implements ArriModel {
  final String id;
  final DateTime timestamp;
  final FooObjectWithEveryOptionalTypeNestedObjectDataData data;
  const FooObjectWithEveryOptionalTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory FooObjectWithEveryOptionalTypeNestedObjectData.empty() {
    return FooObjectWithEveryOptionalTypeNestedObjectData(
      id: "",
      timestamp: DateTime(0),
      data: FooObjectWithEveryOptionalTypeNestedObjectDataData.empty(),
    );
  }

  factory FooObjectWithEveryOptionalTypeNestedObjectData.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime(0));
    final data = _input_["data"] is Map<String, dynamic>
        ? FooObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
            _input_["data"])
        : FooObjectWithEveryOptionalTypeNestedObjectDataData.empty();
    return FooObjectWithEveryOptionalTypeNestedObjectData(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory FooObjectWithEveryOptionalTypeNestedObjectData.fromJsonString(
      String input) {
    return FooObjectWithEveryOptionalTypeNestedObjectData.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalTypeNestedObjectData/data.");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryOptionalTypeNestedObjectData copyWith({
    String? id,
    DateTime? timestamp,
    FooObjectWithEveryOptionalTypeNestedObjectDataData? data,
  }) {
    return FooObjectWithEveryOptionalTypeNestedObjectData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryOptionalTypeNestedObjectData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryOptionalTypeNestedObjectData ${toJsonString()}";
  }
}

class FooObjectWithEveryOptionalTypeNestedObjectDataData implements ArriModel {
  final String id;
  final DateTime timestamp;
  const FooObjectWithEveryOptionalTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });

  factory FooObjectWithEveryOptionalTypeNestedObjectDataData.empty() {
    return FooObjectWithEveryOptionalTypeNestedObjectDataData(
      id: "",
      timestamp: DateTime(0),
    );
  }

  factory FooObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime(0));
    return FooObjectWithEveryOptionalTypeNestedObjectDataData(
      id: id,
      timestamp: timestamp,
    );
  }

  factory FooObjectWithEveryOptionalTypeNestedObjectDataData.fromJsonString(
      String input) {
    return FooObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryOptionalTypeNestedObjectDataData copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return FooObjectWithEveryOptionalTypeNestedObjectDataData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryOptionalTypeNestedObjectDataData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryOptionalTypeNestedObjectDataData ${toJsonString()}";
  }
}

class FooObjectWithEveryOptionalTypeNestedArrayElementElement
    implements ArriModel {
  final String id;
  final DateTime timestamp;
  const FooObjectWithEveryOptionalTypeNestedArrayElementElement({
    required this.id,
    required this.timestamp,
  });

  factory FooObjectWithEveryOptionalTypeNestedArrayElementElement.empty() {
    return FooObjectWithEveryOptionalTypeNestedArrayElementElement(
      id: "",
      timestamp: DateTime(0),
    );
  }

  factory FooObjectWithEveryOptionalTypeNestedArrayElementElement.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime(0));
    return FooObjectWithEveryOptionalTypeNestedArrayElementElement(
      id: id,
      timestamp: timestamp,
    );
  }

  factory FooObjectWithEveryOptionalTypeNestedArrayElementElement.fromJsonString(
      String input) {
    return FooObjectWithEveryOptionalTypeNestedArrayElementElement.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryOptionalTypeNestedArrayElementElement copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return FooObjectWithEveryOptionalTypeNestedArrayElementElement(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryOptionalTypeNestedArrayElementElement &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryOptionalTypeNestedArrayElementElement ${toJsonString()}";
  }
}

class FooRecursiveObject implements ArriModel {
  final FooRecursiveObject? left;
  final FooRecursiveObject? right;
  final String value;
  const FooRecursiveObject({
    required this.left,
    required this.right,
    required this.value,
  });

  factory FooRecursiveObject.empty() {
    return FooRecursiveObject(
      left: null,
      right: null,
      value: "",
    );
  }

  factory FooRecursiveObject.fromJson(Map<String, dynamic> _input_) {
    final left = _input_["left"] is Map<String, dynamic>
        ? FooRecursiveObject.fromJson(_input_["left"])
        : null;
    final right = _input_["right"] is Map<String, dynamic>
        ? FooRecursiveObject.fromJson(_input_["right"])
        : null;
    final value = typeFromDynamic<String>(_input_["value"], "");
    return FooRecursiveObject(
      left: left,
      right: right,
      value: value,
    );
  }

  factory FooRecursiveObject.fromJsonString(String input) {
    return FooRecursiveObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "left": left?.toJson(),
      "right": right?.toJson(),
      "value": value,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /RecursiveObject/left.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /RecursiveObject/right.");
    _queryParts_.add("value=$value");
    return _queryParts_.join("&");
  }

  FooRecursiveObject copyWith({
    FooRecursiveObject? Function()? left,
    FooRecursiveObject? Function()? right,
    String? value,
  }) {
    return FooRecursiveObject(
      left: left != null ? left() : this.left,
      right: right != null ? right() : this.right,
      value: value ?? this.value,
    );
  }

  @override
  List<Object?> get props => [
        left,
        right,
        value,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooRecursiveObject && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooRecursiveObject ${toJsonString()}";
  }
}

sealed class FooRecursiveUnion implements ArriModel {
  String get type;
  const FooRecursiveUnion();

  factory FooRecursiveUnion.empty() {
    return FooRecursiveUnionChild.empty();
  }

  factory FooRecursiveUnion.fromJson(Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "CHILD":
        return FooRecursiveUnionChild.fromJson(_input_);
      case "CHILDREN":
        return FooRecursiveUnionChildren.fromJson(_input_);
      case "TEXT":
        return FooRecursiveUnionText.fromJson(_input_);
      case "SHAPE":
        return FooRecursiveUnionShape.fromJson(_input_);
      default:
        return FooRecursiveUnion.empty();
    }
  }

  factory FooRecursiveUnion.fromJsonString(String input) {
    return FooRecursiveUnion.fromJson(json.decode(input));
  }
}

/// Child node
class FooRecursiveUnionChild implements FooRecursiveUnion {
  final FooRecursiveUnion data;
  const FooRecursiveUnionChild({
    required this.data,
  });

  @override
  String get type => "CHILD";

  factory FooRecursiveUnionChild.empty() {
    return FooRecursiveUnionChild(
      data: FooRecursiveUnion.empty(),
    );
  }

  factory FooRecursiveUnionChild.fromJson(Map<String, dynamic> _input_) {
    final data = _input_["data"] is Map<String, dynamic>
        ? FooRecursiveUnion.fromJson(_input_["data"])
        : FooRecursiveUnion.empty();
    return FooRecursiveUnionChild(
      data: data,
    );
  }

  factory FooRecursiveUnionChild.fromJsonString(String input) {
    return FooRecursiveUnionChild.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /RecursiveUnionChild/data.");
    return _queryParts_.join("&");
  }

  FooRecursiveUnionChild copyWith({
    FooRecursiveUnion? data,
  }) {
    return FooRecursiveUnionChild(
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooRecursiveUnionChild && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooRecursiveUnionChild ${toJsonString()}";
  }
}

/// List of children node
class FooRecursiveUnionChildren implements FooRecursiveUnion {
  final List<FooRecursiveUnion> data;
  const FooRecursiveUnionChildren({
    required this.data,
  });

  @override
  String get type => "CHILDREN";

  factory FooRecursiveUnionChildren.empty() {
    return FooRecursiveUnionChildren(
      data: [],
    );
  }

  factory FooRecursiveUnionChildren.fromJson(Map<String, dynamic> _input_) {
    final data = _input_["data"] is List
        ? (_input_["data"] as List)
            .map((_el_) => _el_ is Map<String, dynamic>
                ? FooRecursiveUnion.fromJson(_el_)
                : FooRecursiveUnion.empty())
            .toList()
        : <FooRecursiveUnion>[];
    return FooRecursiveUnionChildren(
      data: data,
    );
  }

  factory FooRecursiveUnionChildren.fromJsonString(String input) {
    return FooRecursiveUnionChildren.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "data": data.map((_el_) => _el_.toJson()).toList(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /RecursiveUnionChildren/data.");
    return _queryParts_.join("&");
  }

  FooRecursiveUnionChildren copyWith({
    List<FooRecursiveUnion>? data,
  }) {
    return FooRecursiveUnionChildren(
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooRecursiveUnionChildren &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooRecursiveUnionChildren ${toJsonString()}";
  }
}

/// Text node
class FooRecursiveUnionText implements FooRecursiveUnion {
  final String data;
  const FooRecursiveUnionText({
    required this.data,
  });

  @override
  String get type => "TEXT";

  factory FooRecursiveUnionText.empty() {
    return FooRecursiveUnionText(
      data: "",
    );
  }

  factory FooRecursiveUnionText.fromJson(Map<String, dynamic> _input_) {
    final data = typeFromDynamic<String>(_input_["data"], "");
    return FooRecursiveUnionText(
      data: data,
    );
  }

  factory FooRecursiveUnionText.fromJsonString(String input) {
    return FooRecursiveUnionText.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "data": data,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("data=$data");
    return _queryParts_.join("&");
  }

  FooRecursiveUnionText copyWith({
    String? data,
  }) {
    return FooRecursiveUnionText(
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooRecursiveUnionText && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooRecursiveUnionText ${toJsonString()}";
  }
}

/// Shape node
class FooRecursiveUnionShape implements FooRecursiveUnion {
  final FooRecursiveUnionShapeData data;
  const FooRecursiveUnionShape({
    required this.data,
  });

  @override
  String get type => "SHAPE";

  factory FooRecursiveUnionShape.empty() {
    return FooRecursiveUnionShape(
      data: FooRecursiveUnionShapeData.empty(),
    );
  }

  factory FooRecursiveUnionShape.fromJson(Map<String, dynamic> _input_) {
    final data = _input_["data"] is Map<String, dynamic>
        ? FooRecursiveUnionShapeData.fromJson(_input_["data"])
        : FooRecursiveUnionShapeData.empty();
    return FooRecursiveUnionShape(
      data: data,
    );
  }

  factory FooRecursiveUnionShape.fromJsonString(String input) {
    return FooRecursiveUnionShape.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /RecursiveUnionShape/data.");
    return _queryParts_.join("&");
  }

  FooRecursiveUnionShape copyWith({
    FooRecursiveUnionShapeData? data,
  }) {
    return FooRecursiveUnionShape(
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooRecursiveUnionShape && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooRecursiveUnionShape ${toJsonString()}";
  }
}

class FooRecursiveUnionShapeData implements ArriModel {
  final double width;
  final double height;
  final String color;
  const FooRecursiveUnionShapeData({
    required this.width,
    required this.height,
    required this.color,
  });

  factory FooRecursiveUnionShapeData.empty() {
    return FooRecursiveUnionShapeData(
      width: 0.0,
      height: 0.0,
      color: "",
    );
  }

  factory FooRecursiveUnionShapeData.fromJson(Map<String, dynamic> _input_) {
    final width = doubleFromDynamic(_input_["width"], 0.0);
    final height = doubleFromDynamic(_input_["height"], 0.0);
    final color = typeFromDynamic<String>(_input_["color"], "");
    return FooRecursiveUnionShapeData(
      width: width,
      height: height,
      color: color,
    );
  }

  factory FooRecursiveUnionShapeData.fromJsonString(String input) {
    return FooRecursiveUnionShapeData.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "width": width,
      "height": height,
      "color": color,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("width=$width");
    _queryParts_.add("height=$height");
    _queryParts_.add("color=$color");
    return _queryParts_.join("&");
  }

  FooRecursiveUnionShapeData copyWith({
    double? width,
    double? height,
    String? color,
  }) {
    return FooRecursiveUnionShapeData(
      width: width ?? this.width,
      height: height ?? this.height,
      color: color ?? this.color,
    );
  }

  @override
  List<Object?> get props => [
        width,
        height,
        color,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooRecursiveUnionShapeData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooRecursiveUnionShapeData ${toJsonString()}";
  }
}

class FooAutoReconnectParams implements ArriModel {
  final int messageCount;
  const FooAutoReconnectParams({
    required this.messageCount,
  });

  factory FooAutoReconnectParams.empty() {
    return FooAutoReconnectParams(
      messageCount: 0,
    );
  }

  factory FooAutoReconnectParams.fromJson(Map<String, dynamic> _input_) {
    final messageCount = intFromDynamic(_input_["messageCount"], 0);
    return FooAutoReconnectParams(
      messageCount: messageCount,
    );
  }

  factory FooAutoReconnectParams.fromJsonString(String input) {
    return FooAutoReconnectParams.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "messageCount": messageCount,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("messageCount=$messageCount");
    return _queryParts_.join("&");
  }

  FooAutoReconnectParams copyWith({
    int? messageCount,
  }) {
    return FooAutoReconnectParams(
      messageCount: messageCount ?? this.messageCount,
    );
  }

  @override
  List<Object?> get props => [
        messageCount,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooAutoReconnectParams && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooAutoReconnectParams ${toJsonString()}";
  }
}

class FooAutoReconnectResponse implements ArriModel {
  final int count;
  final String message;
  const FooAutoReconnectResponse({
    required this.count,
    required this.message,
  });

  factory FooAutoReconnectResponse.empty() {
    return FooAutoReconnectResponse(
      count: 0,
      message: "",
    );
  }

  factory FooAutoReconnectResponse.fromJson(Map<String, dynamic> _input_) {
    final count = intFromDynamic(_input_["count"], 0);
    final message = typeFromDynamic<String>(_input_["message"], "");
    return FooAutoReconnectResponse(
      count: count,
      message: message,
    );
  }

  factory FooAutoReconnectResponse.fromJsonString(String input) {
    return FooAutoReconnectResponse.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "count": count,
      "message": message,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("count=$count");
    _queryParts_.add("message=$message");
    return _queryParts_.join("&");
  }

  FooAutoReconnectResponse copyWith({
    int? count,
    String? message,
  }) {
    return FooAutoReconnectResponse(
      count: count ?? this.count,
      message: message ?? this.message,
    );
  }

  @override
  List<Object?> get props => [
        count,
        message,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooAutoReconnectResponse &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooAutoReconnectResponse ${toJsonString()}";
  }
}

class FooStreamConnectionErrorTestParams implements ArriModel {
  final int statusCode;
  final String statusMessage;
  const FooStreamConnectionErrorTestParams({
    required this.statusCode,
    required this.statusMessage,
  });

  factory FooStreamConnectionErrorTestParams.empty() {
    return FooStreamConnectionErrorTestParams(
      statusCode: 0,
      statusMessage: "",
    );
  }

  factory FooStreamConnectionErrorTestParams.fromJson(
      Map<String, dynamic> _input_) {
    final statusCode = intFromDynamic(_input_["statusCode"], 0);
    final statusMessage = typeFromDynamic<String>(_input_["statusMessage"], "");
    return FooStreamConnectionErrorTestParams(
      statusCode: statusCode,
      statusMessage: statusMessage,
    );
  }

  factory FooStreamConnectionErrorTestParams.fromJsonString(String input) {
    return FooStreamConnectionErrorTestParams.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "statusCode": statusCode,
      "statusMessage": statusMessage,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("statusCode=$statusCode");
    _queryParts_.add("statusMessage=$statusMessage");
    return _queryParts_.join("&");
  }

  FooStreamConnectionErrorTestParams copyWith({
    int? statusCode,
    String? statusMessage,
  }) {
    return FooStreamConnectionErrorTestParams(
      statusCode: statusCode ?? this.statusCode,
      statusMessage: statusMessage ?? this.statusMessage,
    );
  }

  @override
  List<Object?> get props => [
        statusCode,
        statusMessage,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooStreamConnectionErrorTestParams &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooStreamConnectionErrorTestParams ${toJsonString()}";
  }
}

class FooStreamConnectionErrorTestResponse implements ArriModel {
  final String message;
  const FooStreamConnectionErrorTestResponse({
    required this.message,
  });

  factory FooStreamConnectionErrorTestResponse.empty() {
    return FooStreamConnectionErrorTestResponse(
      message: "",
    );
  }

  factory FooStreamConnectionErrorTestResponse.fromJson(
      Map<String, dynamic> _input_) {
    final message = typeFromDynamic<String>(_input_["message"], "");
    return FooStreamConnectionErrorTestResponse(
      message: message,
    );
  }

  factory FooStreamConnectionErrorTestResponse.fromJsonString(String input) {
    return FooStreamConnectionErrorTestResponse.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "message": message,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("message=$message");
    return _queryParts_.join("&");
  }

  FooStreamConnectionErrorTestResponse copyWith({
    String? message,
  }) {
    return FooStreamConnectionErrorTestResponse(
      message: message ?? this.message,
    );
  }

  @override
  List<Object?> get props => [
        message,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooStreamConnectionErrorTestResponse &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooStreamConnectionErrorTestResponse ${toJsonString()}";
  }
}

class FooStreamLargeObjectsResponse implements ArriModel {
  final List<double> numbers;
  final List<FooStreamLargeObjectsResponseObjectsElement> objects;
  const FooStreamLargeObjectsResponse({
    required this.numbers,
    required this.objects,
  });

  factory FooStreamLargeObjectsResponse.empty() {
    return FooStreamLargeObjectsResponse(
      numbers: [],
      objects: [],
    );
  }

  factory FooStreamLargeObjectsResponse.fromJson(Map<String, dynamic> _input_) {
    final numbers = _input_["numbers"] is List
        ? (_input_["numbers"] as List)
            .map((_el_) => doubleFromDynamic(_el_, 0.0))
            .toList()
        : <double>[];
    final objects = _input_["objects"] is List
        ? (_input_["objects"] as List)
            .map((_el_) => _el_ is Map<String, dynamic>
                ? FooStreamLargeObjectsResponseObjectsElement.fromJson(_el_)
                : FooStreamLargeObjectsResponseObjectsElement.empty())
            .toList()
        : <FooStreamLargeObjectsResponseObjectsElement>[];
    return FooStreamLargeObjectsResponse(
      numbers: numbers,
      objects: objects,
    );
  }

  factory FooStreamLargeObjectsResponse.fromJsonString(String input) {
    return FooStreamLargeObjectsResponse.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "numbers": numbers.map((_el_) => _el_).toList(),
      "objects": objects.map((_el_) => _el_.toJson()).toList(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /StreamLargeObjectsResponse/numbers.");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /StreamLargeObjectsResponse/objects.");
    return _queryParts_.join("&");
  }

  FooStreamLargeObjectsResponse copyWith({
    List<double>? numbers,
    List<FooStreamLargeObjectsResponseObjectsElement>? objects,
  }) {
    return FooStreamLargeObjectsResponse(
      numbers: numbers ?? this.numbers,
      objects: objects ?? this.objects,
    );
  }

  @override
  List<Object?> get props => [
        numbers,
        objects,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooStreamLargeObjectsResponse &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooStreamLargeObjectsResponse ${toJsonString()}";
  }
}

class FooStreamLargeObjectsResponseObjectsElement implements ArriModel {
  final String id;
  final String name;
  final String email;
  const FooStreamLargeObjectsResponseObjectsElement({
    required this.id,
    required this.name,
    required this.email,
  });

  factory FooStreamLargeObjectsResponseObjectsElement.empty() {
    return FooStreamLargeObjectsResponseObjectsElement(
      id: "",
      name: "",
      email: "",
    );
  }

  factory FooStreamLargeObjectsResponseObjectsElement.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final name = typeFromDynamic<String>(_input_["name"], "");
    final email = typeFromDynamic<String>(_input_["email"], "");
    return FooStreamLargeObjectsResponseObjectsElement(
      id: id,
      name: name,
      email: email,
    );
  }

  factory FooStreamLargeObjectsResponseObjectsElement.fromJsonString(
      String input) {
    return FooStreamLargeObjectsResponseObjectsElement.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "name": name,
      "email": email,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("name=$name");
    _queryParts_.add("email=$email");
    return _queryParts_.join("&");
  }

  FooStreamLargeObjectsResponseObjectsElement copyWith({
    String? id,
    String? name,
    String? email,
  }) {
    return FooStreamLargeObjectsResponseObjectsElement(
      id: id ?? this.id,
      name: name ?? this.name,
      email: email ?? this.email,
    );
  }

  @override
  List<Object?> get props => [
        id,
        name,
        email,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooStreamLargeObjectsResponseObjectsElement &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooStreamLargeObjectsResponseObjectsElement ${toJsonString()}";
  }
}

class FooChatMessageParams implements ArriModel {
  final String channelId;
  const FooChatMessageParams({
    required this.channelId,
  });

  factory FooChatMessageParams.empty() {
    return FooChatMessageParams(
      channelId: "",
    );
  }

  factory FooChatMessageParams.fromJson(Map<String, dynamic> _input_) {
    final channelId = typeFromDynamic<String>(_input_["channelId"], "");
    return FooChatMessageParams(
      channelId: channelId,
    );
  }

  factory FooChatMessageParams.fromJsonString(String input) {
    return FooChatMessageParams.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "channelId": channelId,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("channelId=$channelId");
    return _queryParts_.join("&");
  }

  FooChatMessageParams copyWith({
    String? channelId,
  }) {
    return FooChatMessageParams(
      channelId: channelId ?? this.channelId,
    );
  }

  @override
  List<Object?> get props => [
        channelId,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooChatMessageParams && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooChatMessageParams ${toJsonString()}";
  }
}

sealed class FooChatMessage implements ArriModel {
  String get messageType;
  const FooChatMessage();

  factory FooChatMessage.empty() {
    return FooChatMessageText.empty();
  }

  factory FooChatMessage.fromJson(Map<String, dynamic> _input_) {
    final messageType = typeFromDynamic<String>(_input_["messageType"], "");
    switch (messageType) {
      case "TEXT":
        return FooChatMessageText.fromJson(_input_);
      case "IMAGE":
        return FooChatMessageImage.fromJson(_input_);
      case "URL":
        return FooChatMessageUrl.fromJson(_input_);
      default:
        return FooChatMessage.empty();
    }
  }

  factory FooChatMessage.fromJsonString(String input) {
    return FooChatMessage.fromJson(json.decode(input));
  }
}

class FooChatMessageText implements FooChatMessage {
  final String id;
  final String channelId;
  final String userId;
  final DateTime date;
  final String text;
  const FooChatMessageText({
    required this.id,
    required this.channelId,
    required this.userId,
    required this.date,
    required this.text,
  });

  @override
  String get messageType => "TEXT";

  factory FooChatMessageText.empty() {
    return FooChatMessageText(
      id: "",
      channelId: "",
      userId: "",
      date: DateTime(0),
      text: "",
    );
  }

  factory FooChatMessageText.fromJson(Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final channelId = typeFromDynamic<String>(_input_["channelId"], "");
    final userId = typeFromDynamic<String>(_input_["userId"], "");
    final date = dateTimeFromDynamic(_input_["date"], DateTime(0));
    final text = typeFromDynamic<String>(_input_["text"], "");
    return FooChatMessageText(
      id: id,
      channelId: channelId,
      userId: userId,
      date: date,
      text: text,
    );
  }

  factory FooChatMessageText.fromJsonString(String input) {
    return FooChatMessageText.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "messageType": messageType,
      "id": id,
      "channelId": channelId,
      "userId": userId,
      "date": date.toUtc().toIso8601String(),
      "text": text,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("messageType=$messageType");
    _queryParts_.add("id=$id");
    _queryParts_.add("channelId=$channelId");
    _queryParts_.add("userId=$userId");
    _queryParts_.add("date=${date.toUtc().toIso8601String()}");
    _queryParts_.add("text=$text");
    return _queryParts_.join("&");
  }

  FooChatMessageText copyWith({
    String? id,
    String? channelId,
    String? userId,
    DateTime? date,
    String? text,
  }) {
    return FooChatMessageText(
      id: id ?? this.id,
      channelId: channelId ?? this.channelId,
      userId: userId ?? this.userId,
      date: date ?? this.date,
      text: text ?? this.text,
    );
  }

  @override
  List<Object?> get props => [
        id,
        channelId,
        userId,
        date,
        text,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooChatMessageText && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooChatMessageText ${toJsonString()}";
  }
}

class FooChatMessageImage implements FooChatMessage {
  final String id;
  final String channelId;
  final String userId;
  final DateTime date;
  final String image;
  const FooChatMessageImage({
    required this.id,
    required this.channelId,
    required this.userId,
    required this.date,
    required this.image,
  });

  @override
  String get messageType => "IMAGE";

  factory FooChatMessageImage.empty() {
    return FooChatMessageImage(
      id: "",
      channelId: "",
      userId: "",
      date: DateTime(0),
      image: "",
    );
  }

  factory FooChatMessageImage.fromJson(Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final channelId = typeFromDynamic<String>(_input_["channelId"], "");
    final userId = typeFromDynamic<String>(_input_["userId"], "");
    final date = dateTimeFromDynamic(_input_["date"], DateTime(0));
    final image = typeFromDynamic<String>(_input_["image"], "");
    return FooChatMessageImage(
      id: id,
      channelId: channelId,
      userId: userId,
      date: date,
      image: image,
    );
  }

  factory FooChatMessageImage.fromJsonString(String input) {
    return FooChatMessageImage.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "messageType": messageType,
      "id": id,
      "channelId": channelId,
      "userId": userId,
      "date": date.toUtc().toIso8601String(),
      "image": image,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("messageType=$messageType");
    _queryParts_.add("id=$id");
    _queryParts_.add("channelId=$channelId");
    _queryParts_.add("userId=$userId");
    _queryParts_.add("date=${date.toUtc().toIso8601String()}");
    _queryParts_.add("image=$image");
    return _queryParts_.join("&");
  }

  FooChatMessageImage copyWith({
    String? id,
    String? channelId,
    String? userId,
    DateTime? date,
    String? image,
  }) {
    return FooChatMessageImage(
      id: id ?? this.id,
      channelId: channelId ?? this.channelId,
      userId: userId ?? this.userId,
      date: date ?? this.date,
      image: image ?? this.image,
    );
  }

  @override
  List<Object?> get props => [
        id,
        channelId,
        userId,
        date,
        image,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooChatMessageImage && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooChatMessageImage ${toJsonString()}";
  }
}

class FooChatMessageUrl implements FooChatMessage {
  final String id;
  final String channelId;
  final String userId;
  final DateTime date;
  final String url;
  const FooChatMessageUrl({
    required this.id,
    required this.channelId,
    required this.userId,
    required this.date,
    required this.url,
  });

  @override
  String get messageType => "URL";

  factory FooChatMessageUrl.empty() {
    return FooChatMessageUrl(
      id: "",
      channelId: "",
      userId: "",
      date: DateTime(0),
      url: "",
    );
  }

  factory FooChatMessageUrl.fromJson(Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final channelId = typeFromDynamic<String>(_input_["channelId"], "");
    final userId = typeFromDynamic<String>(_input_["userId"], "");
    final date = dateTimeFromDynamic(_input_["date"], DateTime(0));
    final url = typeFromDynamic<String>(_input_["url"], "");
    return FooChatMessageUrl(
      id: id,
      channelId: channelId,
      userId: userId,
      date: date,
      url: url,
    );
  }

  factory FooChatMessageUrl.fromJsonString(String input) {
    return FooChatMessageUrl.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "messageType": messageType,
      "id": id,
      "channelId": channelId,
      "userId": userId,
      "date": date.toUtc().toIso8601String(),
      "url": url,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("messageType=$messageType");
    _queryParts_.add("id=$id");
    _queryParts_.add("channelId=$channelId");
    _queryParts_.add("userId=$userId");
    _queryParts_.add("date=${date.toUtc().toIso8601String()}");
    _queryParts_.add("url=$url");
    return _queryParts_.join("&");
  }

  FooChatMessageUrl copyWith({
    String? id,
    String? channelId,
    String? userId,
    DateTime? date,
    String? url,
  }) {
    return FooChatMessageUrl(
      id: id ?? this.id,
      channelId: channelId ?? this.channelId,
      userId: userId ?? this.userId,
      date: date ?? this.date,
      url: url ?? this.url,
    );
  }

  @override
  List<Object?> get props => [
        id,
        channelId,
        userId,
        date,
        url,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooChatMessageUrl && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooChatMessageUrl ${toJsonString()}";
  }
}

class FooTestsStreamRetryWithNewCredentialsResponse implements ArriModel {
  final String message;
  const FooTestsStreamRetryWithNewCredentialsResponse({
    required this.message,
  });

  factory FooTestsStreamRetryWithNewCredentialsResponse.empty() {
    return FooTestsStreamRetryWithNewCredentialsResponse(
      message: "",
    );
  }

  factory FooTestsStreamRetryWithNewCredentialsResponse.fromJson(
      Map<String, dynamic> _input_) {
    final message = typeFromDynamic<String>(_input_["message"], "");
    return FooTestsStreamRetryWithNewCredentialsResponse(
      message: message,
    );
  }

  factory FooTestsStreamRetryWithNewCredentialsResponse.fromJsonString(
      String input) {
    return FooTestsStreamRetryWithNewCredentialsResponse.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "message": message,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("message=$message");
    return _queryParts_.join("&");
  }

  FooTestsStreamRetryWithNewCredentialsResponse copyWith({
    String? message,
  }) {
    return FooTestsStreamRetryWithNewCredentialsResponse(
      message: message ?? this.message,
    );
  }

  @override
  List<Object?> get props => [
        message,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooTestsStreamRetryWithNewCredentialsResponse &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooTestsStreamRetryWithNewCredentialsResponse ${toJsonString()}";
  }
}

class FooUsersWatchUserParams implements ArriModel {
  final String userId;
  const FooUsersWatchUserParams({
    required this.userId,
  });

  factory FooUsersWatchUserParams.empty() {
    return FooUsersWatchUserParams(
      userId: "",
    );
  }

  factory FooUsersWatchUserParams.fromJson(Map<String, dynamic> _input_) {
    final userId = typeFromDynamic<String>(_input_["userId"], "");
    return FooUsersWatchUserParams(
      userId: userId,
    );
  }

  factory FooUsersWatchUserParams.fromJsonString(String input) {
    return FooUsersWatchUserParams.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "userId": userId,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("userId=$userId");
    return _queryParts_.join("&");
  }

  FooUsersWatchUserParams copyWith({
    String? userId,
  }) {
    return FooUsersWatchUserParams(
      userId: userId ?? this.userId,
    );
  }

  @override
  List<Object?> get props => [
        userId,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooUsersWatchUserParams &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooUsersWatchUserParams ${toJsonString()}";
  }
}

class FooUsersWatchUserResponse implements ArriModel {
  final String id;
  final FooUsersWatchUserResponseRole role;

  /// A profile picture
  final FooUserPhoto? photo;
  final DateTime createdAt;
  final int numFollowers;
  final FooUserSettings settings;
  final List<FooUsersWatchUserResponseRecentNotificationsElement>
      recentNotifications;
  final Map<String, FooUsersWatchUserResponseBookmarksentry> bookmarks;
  final Map<String, dynamic> metadata;
  final List<dynamic> randomList;
  final String? bio;
  const FooUsersWatchUserResponse({
    required this.id,
    required this.role,
    required this.photo,
    required this.createdAt,
    required this.numFollowers,
    required this.settings,
    required this.recentNotifications,
    required this.bookmarks,
    required this.metadata,
    required this.randomList,
    this.bio,
  });

  factory FooUsersWatchUserResponse.empty() {
    return FooUsersWatchUserResponse(
      id: "",
      role: FooUsersWatchUserResponseRole.standard,
      photo: null,
      createdAt: DateTime(0),
      numFollowers: 0,
      settings: FooUserSettings.empty(),
      recentNotifications: [],
      bookmarks: {},
      metadata: {},
      randomList: [],
    );
  }

  factory FooUsersWatchUserResponse.fromJson(Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final role = FooUsersWatchUserResponseRole.fromString(
        typeFromDynamic<String>(_input_["role"], ""));
    final photo = _input_["photo"] is Map<String, dynamic>
        ? FooUserPhoto.fromJson(_input_["photo"])
        : null;
    final createdAt = dateTimeFromDynamic(_input_["createdAt"], DateTime(0));
    final numFollowers = intFromDynamic(_input_["numFollowers"], 0);
    final settings = _input_["settings"] is Map<String, dynamic>
        ? FooUserSettings.fromJson(_input_["settings"])
        : FooUserSettings.empty();
    final recentNotifications = _input_["recentNotifications"] is List
        ? (_input_["recentNotifications"] as List)
            .map((_el_) => _el_ is Map<String, dynamic>
                ? FooUsersWatchUserResponseRecentNotificationsElement.fromJson(
                    _el_)
                : FooUsersWatchUserResponseRecentNotificationsElement.empty())
            .toList()
        : <FooUsersWatchUserResponseRecentNotificationsElement>[];
    final bookmarks = _input_["bookmarks"] is Map<String, dynamic>
        ? (_input_["bookmarks"] as Map<String, dynamic>).map(
            (_key_, _val_) => MapEntry(
              _key_,
              _val_ is Map<String, dynamic>
                  ? FooUsersWatchUserResponseBookmarksentry.fromJson(_val_)
                  : FooUsersWatchUserResponseBookmarksentry.empty(),
            ),
          )
        : <String, FooUsersWatchUserResponseBookmarksentry>{};
    final metadata = _input_["metadata"] is Map<String, dynamic>
        ? (_input_["metadata"] as Map<String, dynamic>).map(
            (_key_, _val_) => MapEntry(
              _key_,
              _val_,
            ),
          )
        : <String, dynamic>{};
    final randomList = _input_["randomList"] is List
        ? (_input_["randomList"] as List).map((_el_) => _el_).toList()
        : <dynamic>[];
    final bio = nullableTypeFromDynamic<String>(_input_["bio"]);
    return FooUsersWatchUserResponse(
      id: id,
      role: role,
      photo: photo,
      createdAt: createdAt,
      numFollowers: numFollowers,
      settings: settings,
      recentNotifications: recentNotifications,
      bookmarks: bookmarks,
      metadata: metadata,
      randomList: randomList,
      bio: bio,
    );
  }

  factory FooUsersWatchUserResponse.fromJsonString(String input) {
    return FooUsersWatchUserResponse.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "role": role.serialValue,
      "photo": photo?.toJson(),
      "createdAt": createdAt.toUtc().toIso8601String(),
      "numFollowers": numFollowers,
      "settings": settings.toJson(),
      "recentNotifications":
          recentNotifications.map((_el_) => _el_.toJson()).toList(),
      "bookmarks": bookmarks.map(
        (_key_, _val_) => MapEntry(
          _key_,
          _val_.toJson(),
        ),
      ),
      "metadata": metadata.map(
        (_key_, _val_) => MapEntry(
          _key_,
          _val_,
        ),
      ),
      "randomList": randomList.map((_el_) => _el_).toList(),
    };
    if (bio != null) _output_["bio"] = bio;
    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("role=${role.serialValue}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /UsersWatchUserResponse/photo.");
    _queryParts_.add("createdAt=${createdAt.toUtc().toIso8601String()}");
    _queryParts_.add("numFollowers=$numFollowers");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /UsersWatchUserResponse/settings.");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /UsersWatchUserResponse/recentNotifications.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /UsersWatchUserResponse/bookmarks.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /UsersWatchUserResponse/metadata.");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /UsersWatchUserResponse/randomList.");
    if (bio != null) _queryParts_.add("bio=$bio");
    return _queryParts_.join("&");
  }

  FooUsersWatchUserResponse copyWith({
    String? id,
    FooUsersWatchUserResponseRole? role,
    FooUserPhoto? Function()? photo,
    DateTime? createdAt,
    int? numFollowers,
    FooUserSettings? settings,
    List<FooUsersWatchUserResponseRecentNotificationsElement>?
        recentNotifications,
    Map<String, FooUsersWatchUserResponseBookmarksentry>? bookmarks,
    Map<String, dynamic>? metadata,
    List<dynamic>? randomList,
    String? Function()? bio,
  }) {
    return FooUsersWatchUserResponse(
      id: id ?? this.id,
      role: role ?? this.role,
      photo: photo != null ? photo() : this.photo,
      createdAt: createdAt ?? this.createdAt,
      numFollowers: numFollowers ?? this.numFollowers,
      settings: settings ?? this.settings,
      recentNotifications: recentNotifications ?? this.recentNotifications,
      bookmarks: bookmarks ?? this.bookmarks,
      metadata: metadata ?? this.metadata,
      randomList: randomList ?? this.randomList,
      bio: bio != null ? bio() : this.bio,
    );
  }

  @override
  List<Object?> get props => [
        id,
        role,
        photo,
        createdAt,
        numFollowers,
        settings,
        recentNotifications,
        bookmarks,
        metadata,
        randomList,
        bio,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooUsersWatchUserResponse &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooUsersWatchUserResponse ${toJsonString()}";
  }
}

enum FooUsersWatchUserResponseRole
    implements Comparable<FooUsersWatchUserResponseRole> {
  standard("standard"),
  admin("admin");

  const FooUsersWatchUserResponseRole(this.serialValue);
  final String serialValue;

  factory FooUsersWatchUserResponseRole.fromString(String input) {
    for (final val in values) {
      if (val.serialValue == input) {
        return val;
      }
    }
    return standard;
  }

  @override
  int compareTo(FooUsersWatchUserResponseRole other) =>
      name.compareTo(other.name);
}

/// A profile picture
class FooUserPhoto implements ArriModel {
  final String url;
  final double width;
  final double height;
  final BigInt bytes;

  /// When the photo was last updated in nanoseconds
  final BigInt nanoseconds;
  const FooUserPhoto({
    required this.url,
    required this.width,
    required this.height,
    required this.bytes,
    required this.nanoseconds,
  });

  factory FooUserPhoto.empty() {
    return FooUserPhoto(
      url: "",
      width: 0.0,
      height: 0.0,
      bytes: BigInt.zero,
      nanoseconds: BigInt.zero,
    );
  }

  factory FooUserPhoto.fromJson(Map<String, dynamic> _input_) {
    final url = typeFromDynamic<String>(_input_["url"], "");
    final width = doubleFromDynamic(_input_["width"], 0.0);
    final height = doubleFromDynamic(_input_["height"], 0.0);
    final bytes = bigIntFromDynamic(_input_["bytes"], BigInt.zero);
    final nanoseconds = bigIntFromDynamic(_input_["nanoseconds"], BigInt.zero);
    return FooUserPhoto(
      url: url,
      width: width,
      height: height,
      bytes: bytes,
      nanoseconds: nanoseconds,
    );
  }

  factory FooUserPhoto.fromJsonString(String input) {
    return FooUserPhoto.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "url": url,
      "width": width,
      "height": height,
      "bytes": bytes.toString(),
      "nanoseconds": nanoseconds.toString(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("url=$url");
    _queryParts_.add("width=$width");
    _queryParts_.add("height=$height");
    _queryParts_.add("bytes=$bytes");
    _queryParts_.add("nanoseconds=$nanoseconds");
    return _queryParts_.join("&");
  }

  FooUserPhoto copyWith({
    String? url,
    double? width,
    double? height,
    BigInt? bytes,
    BigInt? nanoseconds,
  }) {
    return FooUserPhoto(
      url: url ?? this.url,
      width: width ?? this.width,
      height: height ?? this.height,
      bytes: bytes ?? this.bytes,
      nanoseconds: nanoseconds ?? this.nanoseconds,
    );
  }

  @override
  List<Object?> get props => [
        url,
        width,
        height,
        bytes,
        nanoseconds,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooUserPhoto && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooUserPhoto ${toJsonString()}";
  }
}

class FooUserSettings implements ArriModel {
  final bool notificationsEnabled;
  final FooUserSettingsPreferredTheme preferredTheme;
  const FooUserSettings({
    required this.notificationsEnabled,
    required this.preferredTheme,
  });

  factory FooUserSettings.empty() {
    return FooUserSettings(
      notificationsEnabled: false,
      preferredTheme: FooUserSettingsPreferredTheme.darkMode,
    );
  }

  factory FooUserSettings.fromJson(Map<String, dynamic> _input_) {
    final notificationsEnabled =
        typeFromDynamic<bool>(_input_["notificationsEnabled"], false);
    final preferredTheme = FooUserSettingsPreferredTheme.fromString(
        typeFromDynamic<String>(_input_["preferredTheme"], ""));
    return FooUserSettings(
      notificationsEnabled: notificationsEnabled,
      preferredTheme: preferredTheme,
    );
  }

  factory FooUserSettings.fromJsonString(String input) {
    return FooUserSettings.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "notificationsEnabled": notificationsEnabled,
      "preferredTheme": preferredTheme.serialValue,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("notificationsEnabled=$notificationsEnabled");
    _queryParts_.add("preferredTheme=${preferredTheme.serialValue}");
    return _queryParts_.join("&");
  }

  FooUserSettings copyWith({
    bool? notificationsEnabled,
    FooUserSettingsPreferredTheme? preferredTheme,
  }) {
    return FooUserSettings(
      notificationsEnabled: notificationsEnabled ?? this.notificationsEnabled,
      preferredTheme: preferredTheme ?? this.preferredTheme,
    );
  }

  @override
  List<Object?> get props => [
        notificationsEnabled,
        preferredTheme,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooUserSettings && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooUserSettings ${toJsonString()}";
  }
}

enum FooUserSettingsPreferredTheme
    implements Comparable<FooUserSettingsPreferredTheme> {
  darkMode("dark-mode"),
  lightMode("light-mode"),
  system("system");

  const FooUserSettingsPreferredTheme(this.serialValue);
  final String serialValue;

  factory FooUserSettingsPreferredTheme.fromString(String input) {
    for (final val in values) {
      if (val.serialValue == input) {
        return val;
      }
    }
    return darkMode;
  }

  @override
  int compareTo(FooUserSettingsPreferredTheme other) =>
      name.compareTo(other.name);
}

sealed class FooUsersWatchUserResponseRecentNotificationsElement
    implements ArriModel {
  String get notificationType;
  const FooUsersWatchUserResponseRecentNotificationsElement();

  factory FooUsersWatchUserResponseRecentNotificationsElement.empty() {
    return FooUsersWatchUserResponseRecentNotificationsElementPostLike.empty();
  }

  factory FooUsersWatchUserResponseRecentNotificationsElement.fromJson(
      Map<String, dynamic> _input_) {
    final notificationType =
        typeFromDynamic<String>(_input_["notificationType"], "");
    switch (notificationType) {
      case "POST_LIKE":
        return FooUsersWatchUserResponseRecentNotificationsElementPostLike
            .fromJson(_input_);
      case "POST_COMMENT":
        return FooUsersWatchUserResponseRecentNotificationsElementPostComment
            .fromJson(_input_);
      default:
        return FooUsersWatchUserResponseRecentNotificationsElement.empty();
    }
  }

  factory FooUsersWatchUserResponseRecentNotificationsElement.fromJsonString(
      String input) {
    return FooUsersWatchUserResponseRecentNotificationsElement.fromJson(
        json.decode(input));
  }
}

class FooUsersWatchUserResponseRecentNotificationsElementPostLike
    implements FooUsersWatchUserResponseRecentNotificationsElement {
  final String postId;
  final String userId;
  const FooUsersWatchUserResponseRecentNotificationsElementPostLike({
    required this.postId,
    required this.userId,
  });

  @override
  String get notificationType => "POST_LIKE";

  factory FooUsersWatchUserResponseRecentNotificationsElementPostLike.empty() {
    return FooUsersWatchUserResponseRecentNotificationsElementPostLike(
      postId: "",
      userId: "",
    );
  }

  factory FooUsersWatchUserResponseRecentNotificationsElementPostLike.fromJson(
      Map<String, dynamic> _input_) {
    final postId = typeFromDynamic<String>(_input_["postId"], "");
    final userId = typeFromDynamic<String>(_input_["userId"], "");
    return FooUsersWatchUserResponseRecentNotificationsElementPostLike(
      postId: postId,
      userId: userId,
    );
  }

  factory FooUsersWatchUserResponseRecentNotificationsElementPostLike.fromJsonString(
      String input) {
    return FooUsersWatchUserResponseRecentNotificationsElementPostLike.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "notificationType": notificationType,
      "postId": postId,
      "userId": userId,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("notificationType=$notificationType");
    _queryParts_.add("postId=$postId");
    _queryParts_.add("userId=$userId");
    return _queryParts_.join("&");
  }

  FooUsersWatchUserResponseRecentNotificationsElementPostLike copyWith({
    String? postId,
    String? userId,
  }) {
    return FooUsersWatchUserResponseRecentNotificationsElementPostLike(
      postId: postId ?? this.postId,
      userId: userId ?? this.userId,
    );
  }

  @override
  List<Object?> get props => [
        postId,
        userId,
      ];

  @override
  bool operator ==(Object other) {
    return other
            is FooUsersWatchUserResponseRecentNotificationsElementPostLike &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooUsersWatchUserResponseRecentNotificationsElementPostLike ${toJsonString()}";
  }
}

class FooUsersWatchUserResponseRecentNotificationsElementPostComment
    implements FooUsersWatchUserResponseRecentNotificationsElement {
  final String postId;
  final String userId;
  final String commentText;
  const FooUsersWatchUserResponseRecentNotificationsElementPostComment({
    required this.postId,
    required this.userId,
    required this.commentText,
  });

  @override
  String get notificationType => "POST_COMMENT";

  factory FooUsersWatchUserResponseRecentNotificationsElementPostComment.empty() {
    return FooUsersWatchUserResponseRecentNotificationsElementPostComment(
      postId: "",
      userId: "",
      commentText: "",
    );
  }

  factory FooUsersWatchUserResponseRecentNotificationsElementPostComment.fromJson(
      Map<String, dynamic> _input_) {
    final postId = typeFromDynamic<String>(_input_["postId"], "");
    final userId = typeFromDynamic<String>(_input_["userId"], "");
    final commentText = typeFromDynamic<String>(_input_["commentText"], "");
    return FooUsersWatchUserResponseRecentNotificationsElementPostComment(
      postId: postId,
      userId: userId,
      commentText: commentText,
    );
  }

  factory FooUsersWatchUserResponseRecentNotificationsElementPostComment.fromJsonString(
      String input) {
    return FooUsersWatchUserResponseRecentNotificationsElementPostComment
        .fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "notificationType": notificationType,
      "postId": postId,
      "userId": userId,
      "commentText": commentText,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("notificationType=$notificationType");
    _queryParts_.add("postId=$postId");
    _queryParts_.add("userId=$userId");
    _queryParts_.add("commentText=$commentText");
    return _queryParts_.join("&");
  }

  FooUsersWatchUserResponseRecentNotificationsElementPostComment copyWith({
    String? postId,
    String? userId,
    String? commentText,
  }) {
    return FooUsersWatchUserResponseRecentNotificationsElementPostComment(
      postId: postId ?? this.postId,
      userId: userId ?? this.userId,
      commentText: commentText ?? this.commentText,
    );
  }

  @override
  List<Object?> get props => [
        postId,
        userId,
        commentText,
      ];

  @override
  bool operator ==(Object other) {
    return other
            is FooUsersWatchUserResponseRecentNotificationsElementPostComment &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooUsersWatchUserResponseRecentNotificationsElementPostComment ${toJsonString()}";
  }
}

class FooUsersWatchUserResponseBookmarksentry implements ArriModel {
  final String postId;
  final String userId;
  const FooUsersWatchUserResponseBookmarksentry({
    required this.postId,
    required this.userId,
  });

  factory FooUsersWatchUserResponseBookmarksentry.empty() {
    return FooUsersWatchUserResponseBookmarksentry(
      postId: "",
      userId: "",
    );
  }

  factory FooUsersWatchUserResponseBookmarksentry.fromJson(
      Map<String, dynamic> _input_) {
    final postId = typeFromDynamic<String>(_input_["postId"], "");
    final userId = typeFromDynamic<String>(_input_["userId"], "");
    return FooUsersWatchUserResponseBookmarksentry(
      postId: postId,
      userId: userId,
    );
  }

  factory FooUsersWatchUserResponseBookmarksentry.fromJsonString(String input) {
    return FooUsersWatchUserResponseBookmarksentry.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "postId": postId,
      "userId": userId,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("postId=$postId");
    _queryParts_.add("userId=$userId");
    return _queryParts_.join("&");
  }

  FooUsersWatchUserResponseBookmarksentry copyWith({
    String? postId,
    String? userId,
  }) {
    return FooUsersWatchUserResponseBookmarksentry(
      postId: postId ?? this.postId,
      userId: userId ?? this.userId,
    );
  }

  @override
  List<Object?> get props => [
        postId,
        userId,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooUsersWatchUserResponseBookmarksentry &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooUsersWatchUserResponseBookmarksentry ${toJsonString()}";
  }
}
