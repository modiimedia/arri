// this file was autogenerated by arri
// ignore_for_file: type=lint, unused_field, unnecessary_cast
import 'dart:async';
import 'dart:convert';
import 'package:arri_client/arri_client.dart';
import 'package:http/http.dart' as http;

class TestClientPrefixed {
  final String _baseUrl;
  final String _wsConnectionUrl;

  final http.Client Function()? _createHttpClient;
  final String? _clientVersion = "10";
  final FutureOr<Map<String, String>> Function()? _headers;
  final OnErrorHook? _onError;
  final int? _retry;
  final Duration? _retryDelay;
  final double? _heartbeatTimeoutMultiplier;
  final Duration? _timeout;
  final String _defaultTransport;
  late final Map<String, Dispatcher> _dispatchers;

  TestClientPrefixed({
    required String baseUrl,
    required String wsConnectionUrl,
    http.Client Function()? createHttpClient,
    FutureOr<Map<String, String>> Function()? headers,
    OnErrorHook? onError,
    int? retry,
    Duration? retryDelay,
    double? heartbeatTimeoutMultiplier,
    Duration? timeout,
    String? defaultTransport,
    Map<String, Dispatcher>? dispatchers,
  })  : _baseUrl = baseUrl,
        _wsConnectionUrl = wsConnectionUrl,
        _createHttpClient = createHttpClient,
        _headers = headers,
        _onError = onError,
        _retry = retry,
        _retryDelay = retryDelay,
        _heartbeatTimeoutMultiplier = heartbeatTimeoutMultiplier,
        _timeout = timeout,
        _defaultTransport = defaultTransport ?? "http" {
    _dispatchers = dispatchers ?? {};
    if (_dispatchers["http"] == null) {
      _dispatchers["http"] = HttpDispatcher(
        baseUrl: baseUrl,
        createHttpClient: _createHttpClient,
      );
    }
    if (_dispatchers["ws"] == null) {
      _dispatchers["ws"] = WsDispatcher(
        connectionUrl: _wsConnectionUrl,
        heartbeatTimeoutMultiplier: _heartbeatTimeoutMultiplier,
      );
    }
  }

  Future<FooDefaultPayload> emptyParamsGetRequest({
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "emptyParamsGetRequest",
        path: "/rpcs/tests/empty-params-get-request",
        reqId: getRequestId(),
        method: HttpMethod.get,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: null,
      ),
      responseDecoder: (input) => FooDefaultPayload.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<FooDefaultPayload> emptyParamsPostRequest({
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "emptyParamsPostRequest",
        path: "/rpcs/tests/empty-params-post-request",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: null,
      ),
      responseDecoder: (input) => FooDefaultPayload.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<void> emptyResponseGetRequest(
    FooDefaultPayload params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "emptyResponseGetRequest",
        path: "/rpcs/tests/empty-response-get-request",
        reqId: getRequestId(),
        method: HttpMethod.get,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (_) => {},
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<void> emptyResponsePostRequest(
    FooDefaultPayload params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "emptyResponsePostRequest",
        path: "/rpcs/tests/empty-response-post-request",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (_) => {},
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  /// If the target language supports it. Generated code should mark this procedure as deprecated.
  @deprecated
  Future<void> deprecatedRpc(
    FooDeprecatedRpcParams params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "deprecatedRpc",
        path: "/rpcs/tests/deprecated-rpc",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (_) => {},
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<FooDiscriminatorWithEmptyObject> sendDiscriminatorWithEmptyObject(
    FooDiscriminatorWithEmptyObject params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "sendDiscriminatorWithEmptyObject",
        path: "/rpcs/tests/send-discriminator-with-empty-object",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (input) =>
          FooDiscriminatorWithEmptyObject.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<void> sendError(
    FooSendErrorParams params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "sendError",
        path: "/rpcs/tests/send-error",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (_) => {},
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<FooObjectWithEveryType> sendObject(
    FooObjectWithEveryType params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "sendObject",
        path: "/rpcs/tests/send-object",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (input) => FooObjectWithEveryType.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<FooObjectWithEveryNullableType> sendObjectWithNullableFields(
    FooObjectWithEveryNullableType params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "sendObjectWithNullableFields",
        path: "/rpcs/tests/send-object-with-nullable-fields",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (input) =>
          FooObjectWithEveryNullableType.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<FooObjectWithPascalCaseKeys> sendObjectWithPascalCaseKeys(
    FooObjectWithPascalCaseKeys params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "sendObjectWithPascalCaseKeys",
        path: "/rpcs/tests/send-object-with-pascal-case-keys",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (input) =>
          FooObjectWithPascalCaseKeys.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<FooObjectWithSnakeCaseKeys> sendObjectWithSnakeCaseKeys(
    FooObjectWithSnakeCaseKeys params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "sendObjectWithSnakeCaseKeys",
        path: "/rpcs/tests/send-object-with-snake-case-keys",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (input) =>
          FooObjectWithSnakeCaseKeys.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<FooObjectWithEveryOptionalType> sendPartialObject(
    FooObjectWithEveryOptionalType params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "sendPartialObject",
        path: "/rpcs/tests/send-partial-object",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (input) =>
          FooObjectWithEveryOptionalType.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<FooRecursiveObject> sendRecursiveObject(
    FooRecursiveObject params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "sendRecursiveObject",
        path: "/rpcs/tests/send-recursive-object",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (input) => FooRecursiveObject.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }

  Future<FooRecursiveUnion> sendRecursiveUnion(
    FooRecursiveUnion params, {
    String? transport,
    Duration? timeout,
    int? retry,
    Duration? retryDelay,
    OnErrorHook? onError,
  }) async {
    final selectedTransport =
        resolveTransport(["http"], transport ?? _defaultTransport);
    final dispatcher = _dispatchers[selectedTransport];
    if (dispatcher == null) throw MissingDispatcherError(selectedTransport);
    return dispatcher.handleRpc(
      req: RpcRequest(
        procedure: "sendRecursiveUnion",
        path: "/rpcs/tests/send-recursive-union",
        reqId: getRequestId(),
        method: null,
        clientVersion: _clientVersion,
        customHeaders: _headers,
        data: params,
      ),
      responseDecoder: (input) => FooRecursiveUnion.fromJsonString(input),
      timeout: timeout ?? _timeout,
      retry: retry ?? _retry,
      retryDelay: retryDelay ?? _retryDelay,
      onError: onError ?? _onError,
    );
  }
}

class FooManuallyAddedModel implements ArriModel {
  /// FOO
  final String hello;
  const FooManuallyAddedModel({
    required this.hello,
  });

  factory FooManuallyAddedModel.empty() {
    return FooManuallyAddedModel(
      hello: "",
    );
  }

  factory FooManuallyAddedModel.fromJson(Map<String, dynamic> _input_) {
    final hello = typeFromDynamic<String>(_input_["hello"], "");
    return FooManuallyAddedModel(
      hello: hello,
    );
  }

  factory FooManuallyAddedModel.fromJsonString(String input) {
    return FooManuallyAddedModel.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "hello": hello,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("hello=$hello");
    return _queryParts_.join("&");
  }

  FooManuallyAddedModel copyWith({
    String? hello,
  }) {
    return FooManuallyAddedModel(
      hello: hello ?? this.hello,
    );
  }

  @override
  List<Object?> get props => [
        hello,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooManuallyAddedModel && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooManuallyAddedModel ${toJsonString()}";
  }
}

class FooDefaultPayload implements ArriModel {
  final String message;
  const FooDefaultPayload({
    required this.message,
  });

  factory FooDefaultPayload.empty() {
    return FooDefaultPayload(
      message: "",
    );
  }

  factory FooDefaultPayload.fromJson(Map<String, dynamic> _input_) {
    final message = typeFromDynamic<String>(_input_["message"], "");
    return FooDefaultPayload(
      message: message,
    );
  }

  factory FooDefaultPayload.fromJsonString(String input) {
    return FooDefaultPayload.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "message": message,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("message=$message");
    return _queryParts_.join("&");
  }

  FooDefaultPayload copyWith({
    String? message,
  }) {
    return FooDefaultPayload(
      message: message ?? this.message,
    );
  }

  @override
  List<Object?> get props => [
        message,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooDefaultPayload && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooDefaultPayload ${toJsonString()}";
  }
}

@deprecated
class FooDeprecatedRpcParams implements ArriModel {
  @deprecated
  final String deprecatedField;
  const FooDeprecatedRpcParams({
    required this.deprecatedField,
  });

  factory FooDeprecatedRpcParams.empty() {
    return FooDeprecatedRpcParams(
      deprecatedField: "",
    );
  }

  factory FooDeprecatedRpcParams.fromJson(Map<String, dynamic> _input_) {
    final deprecatedField =
        typeFromDynamic<String>(_input_["deprecatedField"], "");
    return FooDeprecatedRpcParams(
      deprecatedField: deprecatedField,
    );
  }

  factory FooDeprecatedRpcParams.fromJsonString(String input) {
    return FooDeprecatedRpcParams.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "deprecatedField": deprecatedField,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("deprecatedField=$deprecatedField");
    return _queryParts_.join("&");
  }

  FooDeprecatedRpcParams copyWith({
    String? deprecatedField,
  }) {
    return FooDeprecatedRpcParams(
      deprecatedField: deprecatedField ?? this.deprecatedField,
    );
  }

  @override
  List<Object?> get props => [
        deprecatedField,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooDeprecatedRpcParams && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooDeprecatedRpcParams ${toJsonString()}";
  }
}

sealed class FooDiscriminatorWithEmptyObject implements ArriModel {
  String get type;
  const FooDiscriminatorWithEmptyObject();

  factory FooDiscriminatorWithEmptyObject.empty() {
    return FooDiscriminatorWithEmptyObjectEmpty.empty();
  }

  factory FooDiscriminatorWithEmptyObject.fromJson(
      Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "EMPTY":
        return FooDiscriminatorWithEmptyObjectEmpty.fromJson(_input_);
      case "NOT_EMPTY":
        return FooDiscriminatorWithEmptyObjectNotEmpty.fromJson(_input_);
      default:
        return FooDiscriminatorWithEmptyObject.empty();
    }
  }

  factory FooDiscriminatorWithEmptyObject.fromJsonString(String input) {
    return FooDiscriminatorWithEmptyObject.fromJson(json.decode(input));
  }
}

class FooDiscriminatorWithEmptyObjectEmpty
    implements FooDiscriminatorWithEmptyObject {
  const FooDiscriminatorWithEmptyObjectEmpty();

  @override
  String get type => "EMPTY";

  factory FooDiscriminatorWithEmptyObjectEmpty.empty() {
    return FooDiscriminatorWithEmptyObjectEmpty();
  }

  factory FooDiscriminatorWithEmptyObjectEmpty.fromJson(
      Map<String, dynamic> _input_) {
    return FooDiscriminatorWithEmptyObjectEmpty();
  }

  factory FooDiscriminatorWithEmptyObjectEmpty.fromJsonString(String input) {
    return FooDiscriminatorWithEmptyObjectEmpty.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    return _queryParts_.join("&");
  }

  FooDiscriminatorWithEmptyObjectEmpty copyWith() {
    return FooDiscriminatorWithEmptyObjectEmpty();
  }

  @override
  List<Object?> get props => [];

  @override
  bool operator ==(Object other) {
    return other is FooDiscriminatorWithEmptyObjectEmpty &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooDiscriminatorWithEmptyObjectEmpty ${toJsonString()}";
  }
}

class FooDiscriminatorWithEmptyObjectNotEmpty
    implements FooDiscriminatorWithEmptyObject {
  final String foo;
  final double bar;
  final bool baz;
  const FooDiscriminatorWithEmptyObjectNotEmpty({
    required this.foo,
    required this.bar,
    required this.baz,
  });

  @override
  String get type => "NOT_EMPTY";

  factory FooDiscriminatorWithEmptyObjectNotEmpty.empty() {
    return FooDiscriminatorWithEmptyObjectNotEmpty(
      foo: "",
      bar: 0.0,
      baz: false,
    );
  }

  factory FooDiscriminatorWithEmptyObjectNotEmpty.fromJson(
      Map<String, dynamic> _input_) {
    final foo = typeFromDynamic<String>(_input_["foo"], "");
    final bar = doubleFromDynamic(_input_["bar"], 0.0);
    final baz = typeFromDynamic<bool>(_input_["baz"], false);
    return FooDiscriminatorWithEmptyObjectNotEmpty(
      foo: foo,
      bar: bar,
      baz: baz,
    );
  }

  factory FooDiscriminatorWithEmptyObjectNotEmpty.fromJsonString(String input) {
    return FooDiscriminatorWithEmptyObjectNotEmpty.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "foo": foo,
      "bar": bar,
      "baz": baz,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("foo=$foo");
    _queryParts_.add("bar=$bar");
    _queryParts_.add("baz=$baz");
    return _queryParts_.join("&");
  }

  FooDiscriminatorWithEmptyObjectNotEmpty copyWith({
    String? foo,
    double? bar,
    bool? baz,
  }) {
    return FooDiscriminatorWithEmptyObjectNotEmpty(
      foo: foo ?? this.foo,
      bar: bar ?? this.bar,
      baz: baz ?? this.baz,
    );
  }

  @override
  List<Object?> get props => [
        foo,
        bar,
        baz,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooDiscriminatorWithEmptyObjectNotEmpty &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooDiscriminatorWithEmptyObjectNotEmpty ${toJsonString()}";
  }
}

class FooSendErrorParams implements ArriModel {
  final int code;
  final String message;
  const FooSendErrorParams({
    required this.code,
    required this.message,
  });

  factory FooSendErrorParams.empty() {
    return FooSendErrorParams(
      code: 0,
      message: "",
    );
  }

  factory FooSendErrorParams.fromJson(Map<String, dynamic> _input_) {
    final code = intFromDynamic(_input_["code"], 0);
    final message = typeFromDynamic<String>(_input_["message"], "");
    return FooSendErrorParams(
      code: code,
      message: message,
    );
  }

  factory FooSendErrorParams.fromJsonString(String input) {
    return FooSendErrorParams.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "code": code,
      "message": message,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("code=$code");
    _queryParts_.add("message=$message");
    return _queryParts_.join("&");
  }

  FooSendErrorParams copyWith({
    int? code,
    String? message,
  }) {
    return FooSendErrorParams(
      code: code ?? this.code,
      message: message ?? this.message,
    );
  }

  @override
  List<Object?> get props => [
        code,
        message,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooSendErrorParams && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooSendErrorParams ${toJsonString()}";
  }
}

class FooObjectWithEveryType implements ArriModel {
  final dynamic any;
  final bool boolean;
  final String string;
  final DateTime timestamp;
  final double float32;
  final double float64;
  final int int8;
  final int uint8;
  final int int16;
  final int uint16;
  final int int32;
  final int uint32;
  final BigInt int64;
  final BigInt uint64;
  final FooObjectWithEveryTypeEnumerator enumerator;
  final List<bool> array;
  final FooObjectWithEveryTypeObject object;
  final Map<String, BigInt> record;
  final FooObjectWithEveryTypeDiscriminator discriminator;
  final FooObjectWithEveryTypeNestedObject nestedObject;
  final List<List<FooObjectWithEveryTypeNestedArrayElementElement>> nestedArray;
  const FooObjectWithEveryType({
    required this.any,
    required this.boolean,
    required this.string,
    required this.timestamp,
    required this.float32,
    required this.float64,
    required this.int8,
    required this.uint8,
    required this.int16,
    required this.uint16,
    required this.int32,
    required this.uint32,
    required this.int64,
    required this.uint64,
    required this.enumerator,
    required this.array,
    required this.object,
    required this.record,
    required this.discriminator,
    required this.nestedObject,
    required this.nestedArray,
  });

  factory FooObjectWithEveryType.empty() {
    return FooObjectWithEveryType(
      any: null,
      boolean: false,
      string: "",
      timestamp: DateTime.now(),
      float32: 0.0,
      float64: 0.0,
      int8: 0,
      uint8: 0,
      int16: 0,
      uint16: 0,
      int32: 0,
      uint32: 0,
      int64: BigInt.zero,
      uint64: BigInt.zero,
      enumerator: FooObjectWithEveryTypeEnumerator.a,
      array: [],
      object: FooObjectWithEveryTypeObject.empty(),
      record: {},
      discriminator: FooObjectWithEveryTypeDiscriminator.empty(),
      nestedObject: FooObjectWithEveryTypeNestedObject.empty(),
      nestedArray: [],
    );
  }

  factory FooObjectWithEveryType.fromJson(Map<String, dynamic> _input_) {
    final any = _input_["any"];
    final boolean = typeFromDynamic<bool>(_input_["boolean"], false);
    final string = typeFromDynamic<String>(_input_["string"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    final float32 = doubleFromDynamic(_input_["float32"], 0.0);
    final float64 = doubleFromDynamic(_input_["float64"], 0.0);
    final int8 = intFromDynamic(_input_["int8"], 0);
    final uint8 = intFromDynamic(_input_["uint8"], 0);
    final int16 = intFromDynamic(_input_["int16"], 0);
    final uint16 = intFromDynamic(_input_["uint16"], 0);
    final int32 = intFromDynamic(_input_["int32"], 0);
    final uint32 = intFromDynamic(_input_["uint32"], 0);
    final int64 = bigIntFromDynamic(_input_["int64"], BigInt.zero);
    final uint64 = bigIntFromDynamic(_input_["uint64"], BigInt.zero);
    final enumerator = FooObjectWithEveryTypeEnumerator.fromString(
        typeFromDynamic<String>(_input_["enumerator"], ""));
    final array = _input_["array"] is List
        ? (_input_["array"] as List)
            .map((_el_) => typeFromDynamic<bool>(_el_, false))
            .toList()
        : <bool>[];
    final object = _input_["object"] is Map<String, dynamic>
        ? FooObjectWithEveryTypeObject.fromJson(_input_["object"])
        : FooObjectWithEveryTypeObject.empty();
    final record = _input_["record"] is Map<String, dynamic>
        ? (_input_["record"] as Map<String, dynamic>).map(
            (_key_, _val_) => MapEntry(
              _key_,
              bigIntFromDynamic(_val_, BigInt.zero),
            ),
          )
        : <String, BigInt>{};
    final discriminator = _input_["discriminator"] is Map<String, dynamic>
        ? FooObjectWithEveryTypeDiscriminator.fromJson(_input_["discriminator"])
        : FooObjectWithEveryTypeDiscriminator.empty();
    final nestedObject = _input_["nestedObject"] is Map<String, dynamic>
        ? FooObjectWithEveryTypeNestedObject.fromJson(_input_["nestedObject"])
        : FooObjectWithEveryTypeNestedObject.empty();
    final nestedArray = _input_["nestedArray"] is List
        ? (_input_["nestedArray"] as List)
            .map((_el_) => _el_ is List
                ? (_el_ as List)
                    .map((_el_) => _el_ is Map<String, dynamic>
                        ? FooObjectWithEveryTypeNestedArrayElementElement
                            .fromJson(_el_)
                        : FooObjectWithEveryTypeNestedArrayElementElement
                            .empty())
                    .toList()
                : <FooObjectWithEveryTypeNestedArrayElementElement>[])
            .toList()
        : <List<FooObjectWithEveryTypeNestedArrayElementElement>>[];
    return FooObjectWithEveryType(
      any: any,
      boolean: boolean,
      string: string,
      timestamp: timestamp,
      float32: float32,
      float64: float64,
      int8: int8,
      uint8: uint8,
      int16: int16,
      uint16: uint16,
      int32: int32,
      uint32: uint32,
      int64: int64,
      uint64: uint64,
      enumerator: enumerator,
      array: array,
      object: object,
      record: record,
      discriminator: discriminator,
      nestedObject: nestedObject,
      nestedArray: nestedArray,
    );
  }

  factory FooObjectWithEveryType.fromJsonString(String input) {
    return FooObjectWithEveryType.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "any": any,
      "boolean": boolean,
      "string": string,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "float32": float32,
      "float64": float64,
      "int8": int8,
      "uint8": uint8,
      "int16": int16,
      "uint16": uint16,
      "int32": int32,
      "uint32": uint32,
      "int64": int64.toString(),
      "uint64": uint64.toString(),
      "enumerator": enumerator.serialValue,
      "array": array.map((_el_) => _el_).toList(),
      "object": object.toJson(),
      "record": record.map(
        (_key_, _val_) => MapEntry(
          _key_,
          _val_.toString(),
        ),
      ),
      "discriminator": discriminator.toJson(),
      "nestedObject": nestedObject.toJson(),
      "nestedArray": nestedArray
          .map((_el_) => _el_.map((_el_) => _el_.toJson()).toList())
          .toList(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    print(
        "[WARNING] any's cannot be serialized to query params. Skipping field at /ObjectWithEveryType/any.");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("string=$string");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    _queryParts_.add("float32=$float32");
    _queryParts_.add("float64=$float64");
    _queryParts_.add("int8=$int8");
    _queryParts_.add("uint8=$uint8");
    _queryParts_.add("int16=$int16");
    _queryParts_.add("uint16=$uint16");
    _queryParts_.add("int32=$int32");
    _queryParts_.add("uint32=$uint32");
    _queryParts_.add("int64=$int64");
    _queryParts_.add("uint64=$uint64");
    _queryParts_.add("enumerator=${enumerator.serialValue}");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryType/array.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryType/object.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryType/record.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryType/discriminator.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryType/nestedObject.");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryType/nestedArray.");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryType copyWith({
    dynamic any,
    bool? boolean,
    String? string,
    DateTime? timestamp,
    double? float32,
    double? float64,
    int? int8,
    int? uint8,
    int? int16,
    int? uint16,
    int? int32,
    int? uint32,
    BigInt? int64,
    BigInt? uint64,
    FooObjectWithEveryTypeEnumerator? enumerator,
    List<bool>? array,
    FooObjectWithEveryTypeObject? object,
    Map<String, BigInt>? record,
    FooObjectWithEveryTypeDiscriminator? discriminator,
    FooObjectWithEveryTypeNestedObject? nestedObject,
    List<List<FooObjectWithEveryTypeNestedArrayElementElement>>? nestedArray,
  }) {
    return FooObjectWithEveryType(
      any: any ?? this.any,
      boolean: boolean ?? this.boolean,
      string: string ?? this.string,
      timestamp: timestamp ?? this.timestamp,
      float32: float32 ?? this.float32,
      float64: float64 ?? this.float64,
      int8: int8 ?? this.int8,
      uint8: uint8 ?? this.uint8,
      int16: int16 ?? this.int16,
      uint16: uint16 ?? this.uint16,
      int32: int32 ?? this.int32,
      uint32: uint32 ?? this.uint32,
      int64: int64 ?? this.int64,
      uint64: uint64 ?? this.uint64,
      enumerator: enumerator ?? this.enumerator,
      array: array ?? this.array,
      object: object ?? this.object,
      record: record ?? this.record,
      discriminator: discriminator ?? this.discriminator,
      nestedObject: nestedObject ?? this.nestedObject,
      nestedArray: nestedArray ?? this.nestedArray,
    );
  }

  @override
  List<Object?> get props => [
        any,
        boolean,
        string,
        timestamp,
        float32,
        float64,
        int8,
        uint8,
        int16,
        uint16,
        int32,
        uint32,
        int64,
        uint64,
        enumerator,
        array,
        object,
        record,
        discriminator,
        nestedObject,
        nestedArray,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryType && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryType ${toJsonString()}";
  }
}

enum FooObjectWithEveryTypeEnumerator
    implements Comparable<FooObjectWithEveryTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const FooObjectWithEveryTypeEnumerator(this.serialValue);
  final String serialValue;

  factory FooObjectWithEveryTypeEnumerator.fromString(String input) {
    for (final val in values) {
      if (val.serialValue == input) {
        return val;
      }
    }
    return a;
  }

  @override
  int compareTo(FooObjectWithEveryTypeEnumerator other) =>
      name.compareTo(other.name);
}

class FooObjectWithEveryTypeObject implements ArriModel {
  final String string;
  final bool boolean;
  final DateTime timestamp;
  const FooObjectWithEveryTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });

  factory FooObjectWithEveryTypeObject.empty() {
    return FooObjectWithEveryTypeObject(
      string: "",
      boolean: false,
      timestamp: DateTime.now(),
    );
  }

  factory FooObjectWithEveryTypeObject.fromJson(Map<String, dynamic> _input_) {
    final string = typeFromDynamic<String>(_input_["string"], "");
    final boolean = typeFromDynamic<bool>(_input_["boolean"], false);
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    return FooObjectWithEveryTypeObject(
      string: string,
      boolean: boolean,
      timestamp: timestamp,
    );
  }

  factory FooObjectWithEveryTypeObject.fromJsonString(String input) {
    return FooObjectWithEveryTypeObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("string=$string");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryTypeObject copyWith({
    String? string,
    bool? boolean,
    DateTime? timestamp,
  }) {
    return FooObjectWithEveryTypeObject(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        string,
        boolean,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryTypeObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryTypeObject ${toJsonString()}";
  }
}

sealed class FooObjectWithEveryTypeDiscriminator implements ArriModel {
  String get type;
  const FooObjectWithEveryTypeDiscriminator();

  factory FooObjectWithEveryTypeDiscriminator.empty() {
    return FooObjectWithEveryTypeDiscriminatorA.empty();
  }

  factory FooObjectWithEveryTypeDiscriminator.fromJson(
      Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "A":
        return FooObjectWithEveryTypeDiscriminatorA.fromJson(_input_);
      case "B":
        return FooObjectWithEveryTypeDiscriminatorB.fromJson(_input_);
      default:
        return FooObjectWithEveryTypeDiscriminator.empty();
    }
  }

  factory FooObjectWithEveryTypeDiscriminator.fromJsonString(String input) {
    return FooObjectWithEveryTypeDiscriminator.fromJson(json.decode(input));
  }
}

class FooObjectWithEveryTypeDiscriminatorA
    implements FooObjectWithEveryTypeDiscriminator {
  final String title;
  const FooObjectWithEveryTypeDiscriminatorA({
    required this.title,
  });

  @override
  String get type => "A";

  factory FooObjectWithEveryTypeDiscriminatorA.empty() {
    return FooObjectWithEveryTypeDiscriminatorA(
      title: "",
    );
  }

  factory FooObjectWithEveryTypeDiscriminatorA.fromJson(
      Map<String, dynamic> _input_) {
    final title = typeFromDynamic<String>(_input_["title"], "");
    return FooObjectWithEveryTypeDiscriminatorA(
      title: title,
    );
  }

  factory FooObjectWithEveryTypeDiscriminatorA.fromJsonString(String input) {
    return FooObjectWithEveryTypeDiscriminatorA.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryTypeDiscriminatorA copyWith({
    String? title,
  }) {
    return FooObjectWithEveryTypeDiscriminatorA(
      title: title ?? this.title,
    );
  }

  @override
  List<Object?> get props => [
        title,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryTypeDiscriminatorA &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryTypeDiscriminatorA ${toJsonString()}";
  }
}

class FooObjectWithEveryTypeDiscriminatorB
    implements FooObjectWithEveryTypeDiscriminator {
  final String title;
  final String description;
  const FooObjectWithEveryTypeDiscriminatorB({
    required this.title,
    required this.description,
  });

  @override
  String get type => "B";

  factory FooObjectWithEveryTypeDiscriminatorB.empty() {
    return FooObjectWithEveryTypeDiscriminatorB(
      title: "",
      description: "",
    );
  }

  factory FooObjectWithEveryTypeDiscriminatorB.fromJson(
      Map<String, dynamic> _input_) {
    final title = typeFromDynamic<String>(_input_["title"], "");
    final description = typeFromDynamic<String>(_input_["description"], "");
    return FooObjectWithEveryTypeDiscriminatorB(
      title: title,
      description: description,
    );
  }

  factory FooObjectWithEveryTypeDiscriminatorB.fromJsonString(String input) {
    return FooObjectWithEveryTypeDiscriminatorB.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    _queryParts_.add("description=$description");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryTypeDiscriminatorB copyWith({
    String? title,
    String? description,
  }) {
    return FooObjectWithEveryTypeDiscriminatorB(
      title: title ?? this.title,
      description: description ?? this.description,
    );
  }

  @override
  List<Object?> get props => [
        title,
        description,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryTypeDiscriminatorB &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryTypeDiscriminatorB ${toJsonString()}";
  }
}

class FooObjectWithEveryTypeNestedObject implements ArriModel {
  final String id;
  final DateTime timestamp;
  final FooObjectWithEveryTypeNestedObjectData data;
  const FooObjectWithEveryTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory FooObjectWithEveryTypeNestedObject.empty() {
    return FooObjectWithEveryTypeNestedObject(
      id: "",
      timestamp: DateTime.now(),
      data: FooObjectWithEveryTypeNestedObjectData.empty(),
    );
  }

  factory FooObjectWithEveryTypeNestedObject.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    final data = _input_["data"] is Map<String, dynamic>
        ? FooObjectWithEveryTypeNestedObjectData.fromJson(_input_["data"])
        : FooObjectWithEveryTypeNestedObjectData.empty();
    return FooObjectWithEveryTypeNestedObject(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory FooObjectWithEveryTypeNestedObject.fromJsonString(String input) {
    return FooObjectWithEveryTypeNestedObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryTypeNestedObject/data.");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryTypeNestedObject copyWith({
    String? id,
    DateTime? timestamp,
    FooObjectWithEveryTypeNestedObjectData? data,
  }) {
    return FooObjectWithEveryTypeNestedObject(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryTypeNestedObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryTypeNestedObject ${toJsonString()}";
  }
}

class FooObjectWithEveryTypeNestedObjectData implements ArriModel {
  final String id;
  final DateTime timestamp;
  final FooObjectWithEveryTypeNestedObjectDataData data;
  const FooObjectWithEveryTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory FooObjectWithEveryTypeNestedObjectData.empty() {
    return FooObjectWithEveryTypeNestedObjectData(
      id: "",
      timestamp: DateTime.now(),
      data: FooObjectWithEveryTypeNestedObjectDataData.empty(),
    );
  }

  factory FooObjectWithEveryTypeNestedObjectData.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    final data = _input_["data"] is Map<String, dynamic>
        ? FooObjectWithEveryTypeNestedObjectDataData.fromJson(_input_["data"])
        : FooObjectWithEveryTypeNestedObjectDataData.empty();
    return FooObjectWithEveryTypeNestedObjectData(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory FooObjectWithEveryTypeNestedObjectData.fromJsonString(String input) {
    return FooObjectWithEveryTypeNestedObjectData.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryTypeNestedObjectData/data.");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryTypeNestedObjectData copyWith({
    String? id,
    DateTime? timestamp,
    FooObjectWithEveryTypeNestedObjectDataData? data,
  }) {
    return FooObjectWithEveryTypeNestedObjectData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryTypeNestedObjectData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryTypeNestedObjectData ${toJsonString()}";
  }
}

class FooObjectWithEveryTypeNestedObjectDataData implements ArriModel {
  final String id;
  final DateTime timestamp;
  const FooObjectWithEveryTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });

  factory FooObjectWithEveryTypeNestedObjectDataData.empty() {
    return FooObjectWithEveryTypeNestedObjectDataData(
      id: "",
      timestamp: DateTime.now(),
    );
  }

  factory FooObjectWithEveryTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    return FooObjectWithEveryTypeNestedObjectDataData(
      id: id,
      timestamp: timestamp,
    );
  }

  factory FooObjectWithEveryTypeNestedObjectDataData.fromJsonString(
      String input) {
    return FooObjectWithEveryTypeNestedObjectDataData.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryTypeNestedObjectDataData copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return FooObjectWithEveryTypeNestedObjectDataData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryTypeNestedObjectDataData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryTypeNestedObjectDataData ${toJsonString()}";
  }
}

class FooObjectWithEveryTypeNestedArrayElementElement implements ArriModel {
  final String id;
  final DateTime timestamp;
  const FooObjectWithEveryTypeNestedArrayElementElement({
    required this.id,
    required this.timestamp,
  });

  factory FooObjectWithEveryTypeNestedArrayElementElement.empty() {
    return FooObjectWithEveryTypeNestedArrayElementElement(
      id: "",
      timestamp: DateTime.now(),
    );
  }

  factory FooObjectWithEveryTypeNestedArrayElementElement.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    return FooObjectWithEveryTypeNestedArrayElementElement(
      id: id,
      timestamp: timestamp,
    );
  }

  factory FooObjectWithEveryTypeNestedArrayElementElement.fromJsonString(
      String input) {
    return FooObjectWithEveryTypeNestedArrayElementElement.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryTypeNestedArrayElementElement copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return FooObjectWithEveryTypeNestedArrayElementElement(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryTypeNestedArrayElementElement &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryTypeNestedArrayElementElement ${toJsonString()}";
  }
}

class FooObjectWithEveryNullableType implements ArriModel {
  final dynamic any;
  final bool? boolean;
  final String? string;
  final DateTime? timestamp;
  final double? float32;
  final double? float64;
  final int? int8;
  final int? uint8;
  final int? int16;
  final int? uint16;
  final int? int32;
  final int? uint32;
  final BigInt? int64;
  final BigInt? uint64;
  final FooObjectWithEveryNullableTypeEnumerator? enumerator;
  final List<bool?>? array;
  final FooObjectWithEveryNullableTypeObject? object;
  final Map<String, BigInt?>? record;
  final FooObjectWithEveryNullableTypeDiscriminator? discriminator;
  final FooObjectWithEveryNullableTypeNestedObject? nestedObject;
  final List<List<FooObjectWithEveryNullableTypeNestedArrayElementElement?>?>?
      nestedArray;
  const FooObjectWithEveryNullableType({
    required this.any,
    required this.boolean,
    required this.string,
    required this.timestamp,
    required this.float32,
    required this.float64,
    required this.int8,
    required this.uint8,
    required this.int16,
    required this.uint16,
    required this.int32,
    required this.uint32,
    required this.int64,
    required this.uint64,
    required this.enumerator,
    required this.array,
    required this.object,
    required this.record,
    required this.discriminator,
    required this.nestedObject,
    required this.nestedArray,
  });

  factory FooObjectWithEveryNullableType.empty() {
    return FooObjectWithEveryNullableType(
      any: null,
      boolean: null,
      string: null,
      timestamp: null,
      float32: null,
      float64: null,
      int8: null,
      uint8: null,
      int16: null,
      uint16: null,
      int32: null,
      uint32: null,
      int64: null,
      uint64: null,
      enumerator: null,
      array: null,
      object: null,
      record: null,
      discriminator: null,
      nestedObject: null,
      nestedArray: null,
    );
  }

  factory FooObjectWithEveryNullableType.fromJson(
      Map<String, dynamic> _input_) {
    final any = _input_["any"];
    final boolean = nullableTypeFromDynamic<bool>(_input_["boolean"]);
    final string = nullableTypeFromDynamic<String>(_input_["string"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    final float32 = nullableDoubleFromDynamic(_input_["float32"]);
    final float64 = nullableDoubleFromDynamic(_input_["float64"]);
    final int8 = nullableIntFromDynamic(_input_["int8"]);
    final uint8 = nullableIntFromDynamic(_input_["uint8"]);
    final int16 = nullableIntFromDynamic(_input_["int16"]);
    final uint16 = nullableIntFromDynamic(_input_["uint16"]);
    final int32 = nullableIntFromDynamic(_input_["int32"]);
    final uint32 = nullableIntFromDynamic(_input_["uint32"]);
    final int64 = nullableBigIntFromDynamic(_input_["int64"]);
    final uint64 = nullableBigIntFromDynamic(_input_["uint64"]);
    final enumerator = _input_["enumerator"] is String
        ? FooObjectWithEveryNullableTypeEnumerator.fromString(
            _input_["enumerator"])
        : null;
    final array = _input_["array"] is List
        ? (_input_["array"] as List)
            .map((_el_) => nullableTypeFromDynamic<bool>(_el_))
            .toList()
        : null;
    final object = _input_["object"] is Map<String, dynamic>
        ? FooObjectWithEveryNullableTypeObject.fromJson(_input_["object"])
        : null;
    final record = _input_["record"] is Map<String, dynamic>
        ? (_input_["record"] as Map<String, dynamic>).map(
            (_key_, _val_) => MapEntry(
              _key_,
              nullableBigIntFromDynamic(_val_),
            ),
          )
        : null;
    final discriminator = _input_["discriminator"] is Map<String, dynamic>
        ? FooObjectWithEveryNullableTypeDiscriminator.fromJson(
            _input_["discriminator"])
        : null;
    final nestedObject = _input_["nestedObject"] is Map<String, dynamic>
        ? FooObjectWithEveryNullableTypeNestedObject.fromJson(
            _input_["nestedObject"])
        : null;
    final nestedArray = _input_["nestedArray"] is List
        ? (_input_["nestedArray"] as List)
            .map((_el_) => _el_ is List
                ? (_el_ as List)
                    .map((_el_) => _el_ is Map<String, dynamic>
                        ? FooObjectWithEveryNullableTypeNestedArrayElementElement
                            .fromJson(_el_)
                        : null)
                    .toList()
                : null)
            .toList()
        : null;
    return FooObjectWithEveryNullableType(
      any: any,
      boolean: boolean,
      string: string,
      timestamp: timestamp,
      float32: float32,
      float64: float64,
      int8: int8,
      uint8: uint8,
      int16: int16,
      uint16: uint16,
      int32: int32,
      uint32: uint32,
      int64: int64,
      uint64: uint64,
      enumerator: enumerator,
      array: array,
      object: object,
      record: record,
      discriminator: discriminator,
      nestedObject: nestedObject,
      nestedArray: nestedArray,
    );
  }

  factory FooObjectWithEveryNullableType.fromJsonString(String input) {
    return FooObjectWithEveryNullableType.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "any": any,
      "boolean": boolean,
      "string": string,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "float32": float32,
      "float64": float64,
      "int8": int8,
      "uint8": uint8,
      "int16": int16,
      "uint16": uint16,
      "int32": int32,
      "uint32": uint32,
      "int64": int64?.toString(),
      "uint64": uint64?.toString(),
      "enumerator": enumerator?.serialValue,
      "array": array?.map((_el_) => _el_).toList(),
      "object": object?.toJson(),
      "record": record?.map(
        (_key_, _val_) => MapEntry(
          _key_,
          _val_?.toString(),
        ),
      ),
      "discriminator": discriminator?.toJson(),
      "nestedObject": nestedObject?.toJson(),
      "nestedArray": nestedArray
          ?.map((_el_) => _el_?.map((_el_) => _el_?.toJson()).toList())
          .toList(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    print(
        "[WARNING] any's cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/any.");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("string=$string");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    _queryParts_.add("float32=$float32");
    _queryParts_.add("float64=$float64");
    _queryParts_.add("int8=$int8");
    _queryParts_.add("uint8=$uint8");
    _queryParts_.add("int16=$int16");
    _queryParts_.add("uint16=$uint16");
    _queryParts_.add("int32=$int32");
    _queryParts_.add("uint32=$uint32");
    _queryParts_.add("int64=$int64");
    _queryParts_.add("uint64=$uint64");
    _queryParts_.add("enumerator=${enumerator?.serialValue}");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/array.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/object.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/record.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/discriminator.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/nestedObject.");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableType/nestedArray.");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryNullableType copyWith({
    dynamic Function()? any,
    bool? Function()? boolean,
    String? Function()? string,
    DateTime? Function()? timestamp,
    double? Function()? float32,
    double? Function()? float64,
    int? Function()? int8,
    int? Function()? uint8,
    int? Function()? int16,
    int? Function()? uint16,
    int? Function()? int32,
    int? Function()? uint32,
    BigInt? Function()? int64,
    BigInt? Function()? uint64,
    FooObjectWithEveryNullableTypeEnumerator? Function()? enumerator,
    List<bool?>? Function()? array,
    FooObjectWithEveryNullableTypeObject? Function()? object,
    Map<String, BigInt?>? Function()? record,
    FooObjectWithEveryNullableTypeDiscriminator? Function()? discriminator,
    FooObjectWithEveryNullableTypeNestedObject? Function()? nestedObject,
    List<List<FooObjectWithEveryNullableTypeNestedArrayElementElement?>?>?
            Function()?
        nestedArray,
  }) {
    return FooObjectWithEveryNullableType(
      any: any != null ? any() : this.any,
      boolean: boolean != null ? boolean() : this.boolean,
      string: string != null ? string() : this.string,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
      float32: float32 != null ? float32() : this.float32,
      float64: float64 != null ? float64() : this.float64,
      int8: int8 != null ? int8() : this.int8,
      uint8: uint8 != null ? uint8() : this.uint8,
      int16: int16 != null ? int16() : this.int16,
      uint16: uint16 != null ? uint16() : this.uint16,
      int32: int32 != null ? int32() : this.int32,
      uint32: uint32 != null ? uint32() : this.uint32,
      int64: int64 != null ? int64() : this.int64,
      uint64: uint64 != null ? uint64() : this.uint64,
      enumerator: enumerator != null ? enumerator() : this.enumerator,
      array: array != null ? array() : this.array,
      object: object != null ? object() : this.object,
      record: record != null ? record() : this.record,
      discriminator:
          discriminator != null ? discriminator() : this.discriminator,
      nestedObject: nestedObject != null ? nestedObject() : this.nestedObject,
      nestedArray: nestedArray != null ? nestedArray() : this.nestedArray,
    );
  }

  @override
  List<Object?> get props => [
        any,
        boolean,
        string,
        timestamp,
        float32,
        float64,
        int8,
        uint8,
        int16,
        uint16,
        int32,
        uint32,
        int64,
        uint64,
        enumerator,
        array,
        object,
        record,
        discriminator,
        nestedObject,
        nestedArray,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryNullableType &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryNullableType ${toJsonString()}";
  }
}

enum FooObjectWithEveryNullableTypeEnumerator
    implements Comparable<FooObjectWithEveryNullableTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const FooObjectWithEveryNullableTypeEnumerator(this.serialValue);
  final String serialValue;

  factory FooObjectWithEveryNullableTypeEnumerator.fromString(String input) {
    for (final val in values) {
      if (val.serialValue == input) {
        return val;
      }
    }
    return a;
  }

  @override
  int compareTo(FooObjectWithEveryNullableTypeEnumerator other) =>
      name.compareTo(other.name);
}

class FooObjectWithEveryNullableTypeObject implements ArriModel {
  final String? string;
  final bool? boolean;
  final DateTime? timestamp;
  const FooObjectWithEveryNullableTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });

  factory FooObjectWithEveryNullableTypeObject.empty() {
    return FooObjectWithEveryNullableTypeObject(
      string: null,
      boolean: null,
      timestamp: null,
    );
  }

  factory FooObjectWithEveryNullableTypeObject.fromJson(
      Map<String, dynamic> _input_) {
    final string = nullableTypeFromDynamic<String>(_input_["string"]);
    final boolean = nullableTypeFromDynamic<bool>(_input_["boolean"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    return FooObjectWithEveryNullableTypeObject(
      string: string,
      boolean: boolean,
      timestamp: timestamp,
    );
  }

  factory FooObjectWithEveryNullableTypeObject.fromJsonString(String input) {
    return FooObjectWithEveryNullableTypeObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("string=$string");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryNullableTypeObject copyWith({
    String? Function()? string,
    bool? Function()? boolean,
    DateTime? Function()? timestamp,
  }) {
    return FooObjectWithEveryNullableTypeObject(
      string: string != null ? string() : this.string,
      boolean: boolean != null ? boolean() : this.boolean,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        string,
        boolean,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryNullableTypeObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryNullableTypeObject ${toJsonString()}";
  }
}

sealed class FooObjectWithEveryNullableTypeDiscriminator implements ArriModel {
  String get type;
  const FooObjectWithEveryNullableTypeDiscriminator();

  factory FooObjectWithEveryNullableTypeDiscriminator.empty() {
    return FooObjectWithEveryNullableTypeDiscriminatorA.empty();
  }

  factory FooObjectWithEveryNullableTypeDiscriminator.fromJson(
      Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "A":
        return FooObjectWithEveryNullableTypeDiscriminatorA.fromJson(_input_);
      case "B":
        return FooObjectWithEveryNullableTypeDiscriminatorB.fromJson(_input_);
      default:
        return FooObjectWithEveryNullableTypeDiscriminator.empty();
    }
  }

  factory FooObjectWithEveryNullableTypeDiscriminator.fromJsonString(
      String input) {
    return FooObjectWithEveryNullableTypeDiscriminator.fromJson(
        json.decode(input));
  }
}

class FooObjectWithEveryNullableTypeDiscriminatorA
    implements FooObjectWithEveryNullableTypeDiscriminator {
  final String? title;
  const FooObjectWithEveryNullableTypeDiscriminatorA({
    required this.title,
  });

  @override
  String get type => "A";

  factory FooObjectWithEveryNullableTypeDiscriminatorA.empty() {
    return FooObjectWithEveryNullableTypeDiscriminatorA(
      title: null,
    );
  }

  factory FooObjectWithEveryNullableTypeDiscriminatorA.fromJson(
      Map<String, dynamic> _input_) {
    final title = nullableTypeFromDynamic<String>(_input_["title"]);
    return FooObjectWithEveryNullableTypeDiscriminatorA(
      title: title,
    );
  }

  factory FooObjectWithEveryNullableTypeDiscriminatorA.fromJsonString(
      String input) {
    return FooObjectWithEveryNullableTypeDiscriminatorA.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryNullableTypeDiscriminatorA copyWith({
    String? Function()? title,
  }) {
    return FooObjectWithEveryNullableTypeDiscriminatorA(
      title: title != null ? title() : this.title,
    );
  }

  @override
  List<Object?> get props => [
        title,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryNullableTypeDiscriminatorA &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryNullableTypeDiscriminatorA ${toJsonString()}";
  }
}

class FooObjectWithEveryNullableTypeDiscriminatorB
    implements FooObjectWithEveryNullableTypeDiscriminator {
  final String? title;
  final String? description;
  const FooObjectWithEveryNullableTypeDiscriminatorB({
    required this.title,
    required this.description,
  });

  @override
  String get type => "B";

  factory FooObjectWithEveryNullableTypeDiscriminatorB.empty() {
    return FooObjectWithEveryNullableTypeDiscriminatorB(
      title: null,
      description: null,
    );
  }

  factory FooObjectWithEveryNullableTypeDiscriminatorB.fromJson(
      Map<String, dynamic> _input_) {
    final title = nullableTypeFromDynamic<String>(_input_["title"]);
    final description = nullableTypeFromDynamic<String>(_input_["description"]);
    return FooObjectWithEveryNullableTypeDiscriminatorB(
      title: title,
      description: description,
    );
  }

  factory FooObjectWithEveryNullableTypeDiscriminatorB.fromJsonString(
      String input) {
    return FooObjectWithEveryNullableTypeDiscriminatorB.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    _queryParts_.add("description=$description");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryNullableTypeDiscriminatorB copyWith({
    String? Function()? title,
    String? Function()? description,
  }) {
    return FooObjectWithEveryNullableTypeDiscriminatorB(
      title: title != null ? title() : this.title,
      description: description != null ? description() : this.description,
    );
  }

  @override
  List<Object?> get props => [
        title,
        description,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryNullableTypeDiscriminatorB &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryNullableTypeDiscriminatorB ${toJsonString()}";
  }
}

class FooObjectWithEveryNullableTypeNestedObject implements ArriModel {
  final String? id;
  final DateTime? timestamp;
  final FooObjectWithEveryNullableTypeNestedObjectData? data;
  const FooObjectWithEveryNullableTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory FooObjectWithEveryNullableTypeNestedObject.empty() {
    return FooObjectWithEveryNullableTypeNestedObject(
      id: null,
      timestamp: null,
      data: null,
    );
  }

  factory FooObjectWithEveryNullableTypeNestedObject.fromJson(
      Map<String, dynamic> _input_) {
    final id = nullableTypeFromDynamic<String>(_input_["id"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    final data = _input_["data"] is Map<String, dynamic>
        ? FooObjectWithEveryNullableTypeNestedObjectData.fromJson(
            _input_["data"])
        : null;
    return FooObjectWithEveryNullableTypeNestedObject(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory FooObjectWithEveryNullableTypeNestedObject.fromJsonString(
      String input) {
    return FooObjectWithEveryNullableTypeNestedObject.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "data": data?.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableTypeNestedObject/data.");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryNullableTypeNestedObject copyWith({
    String? Function()? id,
    DateTime? Function()? timestamp,
    FooObjectWithEveryNullableTypeNestedObjectData? Function()? data,
  }) {
    return FooObjectWithEveryNullableTypeNestedObject(
      id: id != null ? id() : this.id,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
      data: data != null ? data() : this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryNullableTypeNestedObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryNullableTypeNestedObject ${toJsonString()}";
  }
}

class FooObjectWithEveryNullableTypeNestedObjectData implements ArriModel {
  final String? id;
  final DateTime? timestamp;
  final FooObjectWithEveryNullableTypeNestedObjectDataData? data;
  const FooObjectWithEveryNullableTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory FooObjectWithEveryNullableTypeNestedObjectData.empty() {
    return FooObjectWithEveryNullableTypeNestedObjectData(
      id: null,
      timestamp: null,
      data: null,
    );
  }

  factory FooObjectWithEveryNullableTypeNestedObjectData.fromJson(
      Map<String, dynamic> _input_) {
    final id = nullableTypeFromDynamic<String>(_input_["id"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    final data = _input_["data"] is Map<String, dynamic>
        ? FooObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
            _input_["data"])
        : null;
    return FooObjectWithEveryNullableTypeNestedObjectData(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory FooObjectWithEveryNullableTypeNestedObjectData.fromJsonString(
      String input) {
    return FooObjectWithEveryNullableTypeNestedObjectData.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
      "data": data?.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryNullableTypeNestedObjectData/data.");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryNullableTypeNestedObjectData copyWith({
    String? Function()? id,
    DateTime? Function()? timestamp,
    FooObjectWithEveryNullableTypeNestedObjectDataData? Function()? data,
  }) {
    return FooObjectWithEveryNullableTypeNestedObjectData(
      id: id != null ? id() : this.id,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
      data: data != null ? data() : this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryNullableTypeNestedObjectData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryNullableTypeNestedObjectData ${toJsonString()}";
  }
}

class FooObjectWithEveryNullableTypeNestedObjectDataData implements ArriModel {
  final String? id;
  final DateTime? timestamp;
  const FooObjectWithEveryNullableTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });

  factory FooObjectWithEveryNullableTypeNestedObjectDataData.empty() {
    return FooObjectWithEveryNullableTypeNestedObjectDataData(
      id: null,
      timestamp: null,
    );
  }

  factory FooObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> _input_) {
    final id = nullableTypeFromDynamic<String>(_input_["id"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    return FooObjectWithEveryNullableTypeNestedObjectDataData(
      id: id,
      timestamp: timestamp,
    );
  }

  factory FooObjectWithEveryNullableTypeNestedObjectDataData.fromJsonString(
      String input) {
    return FooObjectWithEveryNullableTypeNestedObjectDataData.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryNullableTypeNestedObjectDataData copyWith({
    String? Function()? id,
    DateTime? Function()? timestamp,
  }) {
    return FooObjectWithEveryNullableTypeNestedObjectDataData(
      id: id != null ? id() : this.id,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryNullableTypeNestedObjectDataData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryNullableTypeNestedObjectDataData ${toJsonString()}";
  }
}

class FooObjectWithEveryNullableTypeNestedArrayElementElement
    implements ArriModel {
  final String? id;
  final DateTime? timestamp;
  const FooObjectWithEveryNullableTypeNestedArrayElementElement({
    required this.id,
    required this.timestamp,
  });

  factory FooObjectWithEveryNullableTypeNestedArrayElementElement.empty() {
    return FooObjectWithEveryNullableTypeNestedArrayElementElement(
      id: null,
      timestamp: null,
    );
  }

  factory FooObjectWithEveryNullableTypeNestedArrayElementElement.fromJson(
      Map<String, dynamic> _input_) {
    final id = nullableTypeFromDynamic<String>(_input_["id"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    return FooObjectWithEveryNullableTypeNestedArrayElementElement(
      id: id,
      timestamp: timestamp,
    );
  }

  factory FooObjectWithEveryNullableTypeNestedArrayElementElement.fromJsonString(
      String input) {
    return FooObjectWithEveryNullableTypeNestedArrayElementElement.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp?.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp?.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryNullableTypeNestedArrayElementElement copyWith({
    String? Function()? id,
    DateTime? Function()? timestamp,
  }) {
    return FooObjectWithEveryNullableTypeNestedArrayElementElement(
      id: id != null ? id() : this.id,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryNullableTypeNestedArrayElementElement &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryNullableTypeNestedArrayElementElement ${toJsonString()}";
  }
}

class FooObjectWithPascalCaseKeys implements ArriModel {
  final DateTime createdAt;
  final String displayName;
  final String? phoneNumber;
  final String? emailAddress;
  final bool? isAdmin;
  const FooObjectWithPascalCaseKeys({
    required this.createdAt,
    required this.displayName,
    required this.phoneNumber,
    this.emailAddress,
    this.isAdmin,
  });

  factory FooObjectWithPascalCaseKeys.empty() {
    return FooObjectWithPascalCaseKeys(
      createdAt: DateTime.now(),
      displayName: "",
      phoneNumber: null,
    );
  }

  factory FooObjectWithPascalCaseKeys.fromJson(Map<String, dynamic> _input_) {
    final createdAt = dateTimeFromDynamic(_input_["CreatedAt"], DateTime.now());
    final displayName = typeFromDynamic<String>(_input_["DisplayName"], "");
    final phoneNumber = nullableTypeFromDynamic<String>(_input_["PhoneNumber"]);
    final emailAddress =
        nullableTypeFromDynamic<String>(_input_["EmailAddress"]);
    final isAdmin = nullableTypeFromDynamic<bool>(_input_["IsAdmin"]);
    return FooObjectWithPascalCaseKeys(
      createdAt: createdAt,
      displayName: displayName,
      phoneNumber: phoneNumber,
      emailAddress: emailAddress,
      isAdmin: isAdmin,
    );
  }

  factory FooObjectWithPascalCaseKeys.fromJsonString(String input) {
    return FooObjectWithPascalCaseKeys.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "CreatedAt": createdAt.toUtc().toIso8601String(),
      "DisplayName": displayName,
      "PhoneNumber": phoneNumber,
    };
    if (emailAddress != null) _output_["EmailAddress"] = emailAddress;
    if (isAdmin != null) _output_["IsAdmin"] = isAdmin;
    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("CreatedAt=${createdAt.toUtc().toIso8601String()}");
    _queryParts_.add("DisplayName=$displayName");
    _queryParts_.add("PhoneNumber=$phoneNumber");
    if (emailAddress != null) _queryParts_.add("EmailAddress=$emailAddress");
    if (isAdmin != null) _queryParts_.add("IsAdmin=$isAdmin");
    return _queryParts_.join("&");
  }

  FooObjectWithPascalCaseKeys copyWith({
    DateTime? createdAt,
    String? displayName,
    String? Function()? phoneNumber,
    String? Function()? emailAddress,
    bool? Function()? isAdmin,
  }) {
    return FooObjectWithPascalCaseKeys(
      createdAt: createdAt ?? this.createdAt,
      displayName: displayName ?? this.displayName,
      phoneNumber: phoneNumber != null ? phoneNumber() : this.phoneNumber,
      emailAddress: emailAddress != null ? emailAddress() : this.emailAddress,
      isAdmin: isAdmin != null ? isAdmin() : this.isAdmin,
    );
  }

  @override
  List<Object?> get props => [
        createdAt,
        displayName,
        phoneNumber,
        emailAddress,
        isAdmin,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithPascalCaseKeys &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithPascalCaseKeys ${toJsonString()}";
  }
}

class FooObjectWithSnakeCaseKeys implements ArriModel {
  final DateTime createdAt;
  final String displayName;
  final String? phoneNumber;
  final String? emailAddress;
  final bool? isAdmin;
  const FooObjectWithSnakeCaseKeys({
    required this.createdAt,
    required this.displayName,
    required this.phoneNumber,
    this.emailAddress,
    this.isAdmin,
  });

  factory FooObjectWithSnakeCaseKeys.empty() {
    return FooObjectWithSnakeCaseKeys(
      createdAt: DateTime.now(),
      displayName: "",
      phoneNumber: null,
    );
  }

  factory FooObjectWithSnakeCaseKeys.fromJson(Map<String, dynamic> _input_) {
    final createdAt =
        dateTimeFromDynamic(_input_["created_at"], DateTime.now());
    final displayName = typeFromDynamic<String>(_input_["display_name"], "");
    final phoneNumber =
        nullableTypeFromDynamic<String>(_input_["phone_number"]);
    final emailAddress =
        nullableTypeFromDynamic<String>(_input_["email_address"]);
    final isAdmin = nullableTypeFromDynamic<bool>(_input_["is_admin"]);
    return FooObjectWithSnakeCaseKeys(
      createdAt: createdAt,
      displayName: displayName,
      phoneNumber: phoneNumber,
      emailAddress: emailAddress,
      isAdmin: isAdmin,
    );
  }

  factory FooObjectWithSnakeCaseKeys.fromJsonString(String input) {
    return FooObjectWithSnakeCaseKeys.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "created_at": createdAt.toUtc().toIso8601String(),
      "display_name": displayName,
      "phone_number": phoneNumber,
    };
    if (emailAddress != null) _output_["email_address"] = emailAddress;
    if (isAdmin != null) _output_["is_admin"] = isAdmin;
    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("created_at=${createdAt.toUtc().toIso8601String()}");
    _queryParts_.add("display_name=$displayName");
    _queryParts_.add("phone_number=$phoneNumber");
    if (emailAddress != null) _queryParts_.add("email_address=$emailAddress");
    if (isAdmin != null) _queryParts_.add("is_admin=$isAdmin");
    return _queryParts_.join("&");
  }

  FooObjectWithSnakeCaseKeys copyWith({
    DateTime? createdAt,
    String? displayName,
    String? Function()? phoneNumber,
    String? Function()? emailAddress,
    bool? Function()? isAdmin,
  }) {
    return FooObjectWithSnakeCaseKeys(
      createdAt: createdAt ?? this.createdAt,
      displayName: displayName ?? this.displayName,
      phoneNumber: phoneNumber != null ? phoneNumber() : this.phoneNumber,
      emailAddress: emailAddress != null ? emailAddress() : this.emailAddress,
      isAdmin: isAdmin != null ? isAdmin() : this.isAdmin,
    );
  }

  @override
  List<Object?> get props => [
        createdAt,
        displayName,
        phoneNumber,
        emailAddress,
        isAdmin,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithSnakeCaseKeys &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithSnakeCaseKeys ${toJsonString()}";
  }
}

class FooObjectWithEveryOptionalType implements ArriModel {
  final dynamic any;
  final bool? boolean;
  final String? string;
  final DateTime? timestamp;
  final double? float32;
  final double? float64;
  final int? int8;
  final int? uint8;
  final int? int16;
  final int? uint16;
  final int? int32;
  final int? uint32;
  final BigInt? int64;
  final BigInt? uint64;
  final FooObjectWithEveryOptionalTypeEnumerator? enumerator;
  final List<bool>? array;
  final FooObjectWithEveryOptionalTypeObject? object;
  final Map<String, BigInt>? record;
  final FooObjectWithEveryOptionalTypeDiscriminator? discriminator;
  final FooObjectWithEveryOptionalTypeNestedObject? nestedObject;
  final List<List<FooObjectWithEveryOptionalTypeNestedArrayElementElement>>?
      nestedArray;
  const FooObjectWithEveryOptionalType({
    this.any,
    this.boolean,
    this.string,
    this.timestamp,
    this.float32,
    this.float64,
    this.int8,
    this.uint8,
    this.int16,
    this.uint16,
    this.int32,
    this.uint32,
    this.int64,
    this.uint64,
    this.enumerator,
    this.array,
    this.object,
    this.record,
    this.discriminator,
    this.nestedObject,
    this.nestedArray,
  });

  factory FooObjectWithEveryOptionalType.empty() {
    return FooObjectWithEveryOptionalType();
  }

  factory FooObjectWithEveryOptionalType.fromJson(
      Map<String, dynamic> _input_) {
    final any = _input_["any"];
    final boolean = nullableTypeFromDynamic<bool>(_input_["boolean"]);
    final string = nullableTypeFromDynamic<String>(_input_["string"]);
    final timestamp = nullableDateTimeFromDynamic(_input_["timestamp"]);
    final float32 = nullableDoubleFromDynamic(_input_["float32"]);
    final float64 = nullableDoubleFromDynamic(_input_["float64"]);
    final int8 = nullableIntFromDynamic(_input_["int8"]);
    final uint8 = nullableIntFromDynamic(_input_["uint8"]);
    final int16 = nullableIntFromDynamic(_input_["int16"]);
    final uint16 = nullableIntFromDynamic(_input_["uint16"]);
    final int32 = nullableIntFromDynamic(_input_["int32"]);
    final uint32 = nullableIntFromDynamic(_input_["uint32"]);
    final int64 = nullableBigIntFromDynamic(_input_["int64"]);
    final uint64 = nullableBigIntFromDynamic(_input_["uint64"]);
    final enumerator = _input_["enumerator"] is String
        ? FooObjectWithEveryOptionalTypeEnumerator.fromString(
            _input_["enumerator"])
        : null;
    final array = _input_["array"] is List
        ? (_input_["array"] as List)
            .map((_el_) => typeFromDynamic<bool>(_el_, false))
            .toList()
        : null;
    final object = _input_["object"] is Map<String, dynamic>
        ? FooObjectWithEveryOptionalTypeObject.fromJson(_input_["object"])
        : null;
    final record = _input_["record"] is Map<String, dynamic>
        ? (_input_["record"] as Map<String, dynamic>).map(
            (_key_, _val_) => MapEntry(
              _key_,
              bigIntFromDynamic(_val_, BigInt.zero),
            ),
          )
        : null;
    final discriminator = _input_["discriminator"] is Map<String, dynamic>
        ? FooObjectWithEveryOptionalTypeDiscriminator.fromJson(
            _input_["discriminator"])
        : null;
    final nestedObject = _input_["nestedObject"] is Map<String, dynamic>
        ? FooObjectWithEveryOptionalTypeNestedObject.fromJson(
            _input_["nestedObject"])
        : null;
    final nestedArray = _input_["nestedArray"] is List
        ? (_input_["nestedArray"] as List)
            .map((_el_) => _el_ is List
                ? (_el_ as List)
                    .map((_el_) => _el_ is Map<String, dynamic>
                        ? FooObjectWithEveryOptionalTypeNestedArrayElementElement
                            .fromJson(_el_)
                        : FooObjectWithEveryOptionalTypeNestedArrayElementElement
                            .empty())
                    .toList()
                : <FooObjectWithEveryOptionalTypeNestedArrayElementElement>[])
            .toList()
        : null;
    return FooObjectWithEveryOptionalType(
      any: any,
      boolean: boolean,
      string: string,
      timestamp: timestamp,
      float32: float32,
      float64: float64,
      int8: int8,
      uint8: uint8,
      int16: int16,
      uint16: uint16,
      int32: int32,
      uint32: uint32,
      int64: int64,
      uint64: uint64,
      enumerator: enumerator,
      array: array,
      object: object,
      record: record,
      discriminator: discriminator,
      nestedObject: nestedObject,
      nestedArray: nestedArray,
    );
  }

  factory FooObjectWithEveryOptionalType.fromJsonString(String input) {
    return FooObjectWithEveryOptionalType.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{};
    if (any != null) _output_["any"] = any;
    if (boolean != null) _output_["boolean"] = boolean;
    if (string != null) _output_["string"] = string;
    if (timestamp != null)
      _output_["timestamp"] = timestamp!.toUtc().toIso8601String();
    if (float32 != null) _output_["float32"] = float32;
    if (float64 != null) _output_["float64"] = float64;
    if (int8 != null) _output_["int8"] = int8;
    if (uint8 != null) _output_["uint8"] = uint8;
    if (int16 != null) _output_["int16"] = int16;
    if (uint16 != null) _output_["uint16"] = uint16;
    if (int32 != null) _output_["int32"] = int32;
    if (uint32 != null) _output_["uint32"] = uint32;
    if (int64 != null) _output_["int64"] = int64!.toString();
    if (uint64 != null) _output_["uint64"] = uint64!.toString();
    if (enumerator != null) _output_["enumerator"] = enumerator!.serialValue;
    if (array != null) _output_["array"] = array!.map((_el_) => _el_).toList();
    if (object != null) _output_["object"] = object!.toJson();
    if (record != null)
      _output_["record"] = record!.map(
        (_key_, _val_) => MapEntry(
          _key_,
          _val_.toString(),
        ),
      );
    if (discriminator != null)
      _output_["discriminator"] = discriminator!.toJson();
    if (nestedObject != null) _output_["nestedObject"] = nestedObject!.toJson();
    if (nestedArray != null)
      _output_["nestedArray"] = nestedArray!
          .map((_el_) => _el_.map((_el_) => _el_.toJson()).toList())
          .toList();
    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    print(
        "[WARNING] any's cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/any.");
    if (boolean != null) _queryParts_.add("boolean=$boolean");
    if (string != null) _queryParts_.add("string=$string");
    if (timestamp != null)
      _queryParts_.add("timestamp=${timestamp!.toUtc().toIso8601String()}");
    if (float32 != null) _queryParts_.add("float32=$float32");
    if (float64 != null) _queryParts_.add("float64=$float64");
    if (int8 != null) _queryParts_.add("int8=$int8");
    if (uint8 != null) _queryParts_.add("uint8=$uint8");
    if (int16 != null) _queryParts_.add("int16=$int16");
    if (uint16 != null) _queryParts_.add("uint16=$uint16");
    if (int32 != null) _queryParts_.add("int32=$int32");
    if (uint32 != null) _queryParts_.add("uint32=$uint32");
    if (int64 != null) _queryParts_.add("int64=$int64");
    if (uint64 != null) _queryParts_.add("uint64=$uint64");
    if (enumerator != null)
      _queryParts_.add("enumerator=${enumerator!.serialValue}");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/array.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/object.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/record.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/discriminator.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/nestedObject.");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalType/nestedArray.");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryOptionalType copyWith({
    dynamic Function()? any,
    bool? Function()? boolean,
    String? Function()? string,
    DateTime? Function()? timestamp,
    double? Function()? float32,
    double? Function()? float64,
    int? Function()? int8,
    int? Function()? uint8,
    int? Function()? int16,
    int? Function()? uint16,
    int? Function()? int32,
    int? Function()? uint32,
    BigInt? Function()? int64,
    BigInt? Function()? uint64,
    FooObjectWithEveryOptionalTypeEnumerator? Function()? enumerator,
    List<bool>? Function()? array,
    FooObjectWithEveryOptionalTypeObject? Function()? object,
    Map<String, BigInt>? Function()? record,
    FooObjectWithEveryOptionalTypeDiscriminator? Function()? discriminator,
    FooObjectWithEveryOptionalTypeNestedObject? Function()? nestedObject,
    List<List<FooObjectWithEveryOptionalTypeNestedArrayElementElement>>?
            Function()?
        nestedArray,
  }) {
    return FooObjectWithEveryOptionalType(
      any: any != null ? any() : this.any,
      boolean: boolean != null ? boolean() : this.boolean,
      string: string != null ? string() : this.string,
      timestamp: timestamp != null ? timestamp() : this.timestamp,
      float32: float32 != null ? float32() : this.float32,
      float64: float64 != null ? float64() : this.float64,
      int8: int8 != null ? int8() : this.int8,
      uint8: uint8 != null ? uint8() : this.uint8,
      int16: int16 != null ? int16() : this.int16,
      uint16: uint16 != null ? uint16() : this.uint16,
      int32: int32 != null ? int32() : this.int32,
      uint32: uint32 != null ? uint32() : this.uint32,
      int64: int64 != null ? int64() : this.int64,
      uint64: uint64 != null ? uint64() : this.uint64,
      enumerator: enumerator != null ? enumerator() : this.enumerator,
      array: array != null ? array() : this.array,
      object: object != null ? object() : this.object,
      record: record != null ? record() : this.record,
      discriminator:
          discriminator != null ? discriminator() : this.discriminator,
      nestedObject: nestedObject != null ? nestedObject() : this.nestedObject,
      nestedArray: nestedArray != null ? nestedArray() : this.nestedArray,
    );
  }

  @override
  List<Object?> get props => [
        any,
        boolean,
        string,
        timestamp,
        float32,
        float64,
        int8,
        uint8,
        int16,
        uint16,
        int32,
        uint32,
        int64,
        uint64,
        enumerator,
        array,
        object,
        record,
        discriminator,
        nestedObject,
        nestedArray,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryOptionalType &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryOptionalType ${toJsonString()}";
  }
}

enum FooObjectWithEveryOptionalTypeEnumerator
    implements Comparable<FooObjectWithEveryOptionalTypeEnumerator> {
  a("A"),
  b("B"),
  c("C");

  const FooObjectWithEveryOptionalTypeEnumerator(this.serialValue);
  final String serialValue;

  factory FooObjectWithEveryOptionalTypeEnumerator.fromString(String input) {
    for (final val in values) {
      if (val.serialValue == input) {
        return val;
      }
    }
    return a;
  }

  @override
  int compareTo(FooObjectWithEveryOptionalTypeEnumerator other) =>
      name.compareTo(other.name);
}

class FooObjectWithEveryOptionalTypeObject implements ArriModel {
  final String string;
  final bool boolean;
  final DateTime timestamp;
  const FooObjectWithEveryOptionalTypeObject({
    required this.string,
    required this.boolean,
    required this.timestamp,
  });

  factory FooObjectWithEveryOptionalTypeObject.empty() {
    return FooObjectWithEveryOptionalTypeObject(
      string: "",
      boolean: false,
      timestamp: DateTime.now(),
    );
  }

  factory FooObjectWithEveryOptionalTypeObject.fromJson(
      Map<String, dynamic> _input_) {
    final string = typeFromDynamic<String>(_input_["string"], "");
    final boolean = typeFromDynamic<bool>(_input_["boolean"], false);
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    return FooObjectWithEveryOptionalTypeObject(
      string: string,
      boolean: boolean,
      timestamp: timestamp,
    );
  }

  factory FooObjectWithEveryOptionalTypeObject.fromJsonString(String input) {
    return FooObjectWithEveryOptionalTypeObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "string": string,
      "boolean": boolean,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("string=$string");
    _queryParts_.add("boolean=$boolean");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryOptionalTypeObject copyWith({
    String? string,
    bool? boolean,
    DateTime? timestamp,
  }) {
    return FooObjectWithEveryOptionalTypeObject(
      string: string ?? this.string,
      boolean: boolean ?? this.boolean,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        string,
        boolean,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryOptionalTypeObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryOptionalTypeObject ${toJsonString()}";
  }
}

sealed class FooObjectWithEveryOptionalTypeDiscriminator implements ArriModel {
  String get type;
  const FooObjectWithEveryOptionalTypeDiscriminator();

  factory FooObjectWithEveryOptionalTypeDiscriminator.empty() {
    return FooObjectWithEveryOptionalTypeDiscriminatorA.empty();
  }

  factory FooObjectWithEveryOptionalTypeDiscriminator.fromJson(
      Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "A":
        return FooObjectWithEveryOptionalTypeDiscriminatorA.fromJson(_input_);
      case "B":
        return FooObjectWithEveryOptionalTypeDiscriminatorB.fromJson(_input_);
      default:
        return FooObjectWithEveryOptionalTypeDiscriminator.empty();
    }
  }

  factory FooObjectWithEveryOptionalTypeDiscriminator.fromJsonString(
      String input) {
    return FooObjectWithEveryOptionalTypeDiscriminator.fromJson(
        json.decode(input));
  }
}

class FooObjectWithEveryOptionalTypeDiscriminatorA
    implements FooObjectWithEveryOptionalTypeDiscriminator {
  final String title;
  const FooObjectWithEveryOptionalTypeDiscriminatorA({
    required this.title,
  });

  @override
  String get type => "A";

  factory FooObjectWithEveryOptionalTypeDiscriminatorA.empty() {
    return FooObjectWithEveryOptionalTypeDiscriminatorA(
      title: "",
    );
  }

  factory FooObjectWithEveryOptionalTypeDiscriminatorA.fromJson(
      Map<String, dynamic> _input_) {
    final title = typeFromDynamic<String>(_input_["title"], "");
    return FooObjectWithEveryOptionalTypeDiscriminatorA(
      title: title,
    );
  }

  factory FooObjectWithEveryOptionalTypeDiscriminatorA.fromJsonString(
      String input) {
    return FooObjectWithEveryOptionalTypeDiscriminatorA.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryOptionalTypeDiscriminatorA copyWith({
    String? title,
  }) {
    return FooObjectWithEveryOptionalTypeDiscriminatorA(
      title: title ?? this.title,
    );
  }

  @override
  List<Object?> get props => [
        title,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryOptionalTypeDiscriminatorA &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryOptionalTypeDiscriminatorA ${toJsonString()}";
  }
}

class FooObjectWithEveryOptionalTypeDiscriminatorB
    implements FooObjectWithEveryOptionalTypeDiscriminator {
  final String title;
  final String description;
  const FooObjectWithEveryOptionalTypeDiscriminatorB({
    required this.title,
    required this.description,
  });

  @override
  String get type => "B";

  factory FooObjectWithEveryOptionalTypeDiscriminatorB.empty() {
    return FooObjectWithEveryOptionalTypeDiscriminatorB(
      title: "",
      description: "",
    );
  }

  factory FooObjectWithEveryOptionalTypeDiscriminatorB.fromJson(
      Map<String, dynamic> _input_) {
    final title = typeFromDynamic<String>(_input_["title"], "");
    final description = typeFromDynamic<String>(_input_["description"], "");
    return FooObjectWithEveryOptionalTypeDiscriminatorB(
      title: title,
      description: description,
    );
  }

  factory FooObjectWithEveryOptionalTypeDiscriminatorB.fromJsonString(
      String input) {
    return FooObjectWithEveryOptionalTypeDiscriminatorB.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "title": title,
      "description": description,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("title=$title");
    _queryParts_.add("description=$description");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryOptionalTypeDiscriminatorB copyWith({
    String? title,
    String? description,
  }) {
    return FooObjectWithEveryOptionalTypeDiscriminatorB(
      title: title ?? this.title,
      description: description ?? this.description,
    );
  }

  @override
  List<Object?> get props => [
        title,
        description,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryOptionalTypeDiscriminatorB &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryOptionalTypeDiscriminatorB ${toJsonString()}";
  }
}

class FooObjectWithEveryOptionalTypeNestedObject implements ArriModel {
  final String id;
  final DateTime timestamp;
  final FooObjectWithEveryOptionalTypeNestedObjectData data;
  const FooObjectWithEveryOptionalTypeNestedObject({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory FooObjectWithEveryOptionalTypeNestedObject.empty() {
    return FooObjectWithEveryOptionalTypeNestedObject(
      id: "",
      timestamp: DateTime.now(),
      data: FooObjectWithEveryOptionalTypeNestedObjectData.empty(),
    );
  }

  factory FooObjectWithEveryOptionalTypeNestedObject.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    final data = _input_["data"] is Map<String, dynamic>
        ? FooObjectWithEveryOptionalTypeNestedObjectData.fromJson(
            _input_["data"])
        : FooObjectWithEveryOptionalTypeNestedObjectData.empty();
    return FooObjectWithEveryOptionalTypeNestedObject(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory FooObjectWithEveryOptionalTypeNestedObject.fromJsonString(
      String input) {
    return FooObjectWithEveryOptionalTypeNestedObject.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalTypeNestedObject/data.");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryOptionalTypeNestedObject copyWith({
    String? id,
    DateTime? timestamp,
    FooObjectWithEveryOptionalTypeNestedObjectData? data,
  }) {
    return FooObjectWithEveryOptionalTypeNestedObject(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryOptionalTypeNestedObject &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryOptionalTypeNestedObject ${toJsonString()}";
  }
}

class FooObjectWithEveryOptionalTypeNestedObjectData implements ArriModel {
  final String id;
  final DateTime timestamp;
  final FooObjectWithEveryOptionalTypeNestedObjectDataData data;
  const FooObjectWithEveryOptionalTypeNestedObjectData({
    required this.id,
    required this.timestamp,
    required this.data,
  });

  factory FooObjectWithEveryOptionalTypeNestedObjectData.empty() {
    return FooObjectWithEveryOptionalTypeNestedObjectData(
      id: "",
      timestamp: DateTime.now(),
      data: FooObjectWithEveryOptionalTypeNestedObjectDataData.empty(),
    );
  }

  factory FooObjectWithEveryOptionalTypeNestedObjectData.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    final data = _input_["data"] is Map<String, dynamic>
        ? FooObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
            _input_["data"])
        : FooObjectWithEveryOptionalTypeNestedObjectDataData.empty();
    return FooObjectWithEveryOptionalTypeNestedObjectData(
      id: id,
      timestamp: timestamp,
      data: data,
    );
  }

  factory FooObjectWithEveryOptionalTypeNestedObjectData.fromJsonString(
      String input) {
    return FooObjectWithEveryOptionalTypeNestedObjectData.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /ObjectWithEveryOptionalTypeNestedObjectData/data.");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryOptionalTypeNestedObjectData copyWith({
    String? id,
    DateTime? timestamp,
    FooObjectWithEveryOptionalTypeNestedObjectDataData? data,
  }) {
    return FooObjectWithEveryOptionalTypeNestedObjectData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryOptionalTypeNestedObjectData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryOptionalTypeNestedObjectData ${toJsonString()}";
  }
}

class FooObjectWithEveryOptionalTypeNestedObjectDataData implements ArriModel {
  final String id;
  final DateTime timestamp;
  const FooObjectWithEveryOptionalTypeNestedObjectDataData({
    required this.id,
    required this.timestamp,
  });

  factory FooObjectWithEveryOptionalTypeNestedObjectDataData.empty() {
    return FooObjectWithEveryOptionalTypeNestedObjectDataData(
      id: "",
      timestamp: DateTime.now(),
    );
  }

  factory FooObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    return FooObjectWithEveryOptionalTypeNestedObjectDataData(
      id: id,
      timestamp: timestamp,
    );
  }

  factory FooObjectWithEveryOptionalTypeNestedObjectDataData.fromJsonString(
      String input) {
    return FooObjectWithEveryOptionalTypeNestedObjectDataData.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryOptionalTypeNestedObjectDataData copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return FooObjectWithEveryOptionalTypeNestedObjectDataData(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryOptionalTypeNestedObjectDataData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryOptionalTypeNestedObjectDataData ${toJsonString()}";
  }
}

class FooObjectWithEveryOptionalTypeNestedArrayElementElement
    implements ArriModel {
  final String id;
  final DateTime timestamp;
  const FooObjectWithEveryOptionalTypeNestedArrayElementElement({
    required this.id,
    required this.timestamp,
  });

  factory FooObjectWithEveryOptionalTypeNestedArrayElementElement.empty() {
    return FooObjectWithEveryOptionalTypeNestedArrayElementElement(
      id: "",
      timestamp: DateTime.now(),
    );
  }

  factory FooObjectWithEveryOptionalTypeNestedArrayElementElement.fromJson(
      Map<String, dynamic> _input_) {
    final id = typeFromDynamic<String>(_input_["id"], "");
    final timestamp = dateTimeFromDynamic(_input_["timestamp"], DateTime.now());
    return FooObjectWithEveryOptionalTypeNestedArrayElementElement(
      id: id,
      timestamp: timestamp,
    );
  }

  factory FooObjectWithEveryOptionalTypeNestedArrayElementElement.fromJsonString(
      String input) {
    return FooObjectWithEveryOptionalTypeNestedArrayElementElement.fromJson(
        json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "id": id,
      "timestamp": timestamp.toUtc().toIso8601String(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("id=$id");
    _queryParts_.add("timestamp=${timestamp.toUtc().toIso8601String()}");
    return _queryParts_.join("&");
  }

  FooObjectWithEveryOptionalTypeNestedArrayElementElement copyWith({
    String? id,
    DateTime? timestamp,
  }) {
    return FooObjectWithEveryOptionalTypeNestedArrayElementElement(
      id: id ?? this.id,
      timestamp: timestamp ?? this.timestamp,
    );
  }

  @override
  List<Object?> get props => [
        id,
        timestamp,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooObjectWithEveryOptionalTypeNestedArrayElementElement &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooObjectWithEveryOptionalTypeNestedArrayElementElement ${toJsonString()}";
  }
}

class FooRecursiveObject implements ArriModel {
  final FooRecursiveObject? left;
  final FooRecursiveObject? right;
  final String value;
  const FooRecursiveObject({
    required this.left,
    required this.right,
    required this.value,
  });

  factory FooRecursiveObject.empty() {
    return FooRecursiveObject(
      left: null,
      right: null,
      value: "",
    );
  }

  factory FooRecursiveObject.fromJson(Map<String, dynamic> _input_) {
    final left = _input_["left"] is Map<String, dynamic>
        ? FooRecursiveObject.fromJson(_input_["left"])
        : null;
    final right = _input_["right"] is Map<String, dynamic>
        ? FooRecursiveObject.fromJson(_input_["right"])
        : null;
    final value = typeFromDynamic<String>(_input_["value"], "");
    return FooRecursiveObject(
      left: left,
      right: right,
      value: value,
    );
  }

  factory FooRecursiveObject.fromJsonString(String input) {
    return FooRecursiveObject.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "left": left?.toJson(),
      "right": right?.toJson(),
      "value": value,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /RecursiveObject/left.");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /RecursiveObject/right.");
    _queryParts_.add("value=$value");
    return _queryParts_.join("&");
  }

  FooRecursiveObject copyWith({
    FooRecursiveObject? Function()? left,
    FooRecursiveObject? Function()? right,
    String? value,
  }) {
    return FooRecursiveObject(
      left: left != null ? left() : this.left,
      right: right != null ? right() : this.right,
      value: value ?? this.value,
    );
  }

  @override
  List<Object?> get props => [
        left,
        right,
        value,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooRecursiveObject && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooRecursiveObject ${toJsonString()}";
  }
}

sealed class FooRecursiveUnion implements ArriModel {
  String get type;
  const FooRecursiveUnion();

  factory FooRecursiveUnion.empty() {
    return FooRecursiveUnionChild.empty();
  }

  factory FooRecursiveUnion.fromJson(Map<String, dynamic> _input_) {
    final type = typeFromDynamic<String>(_input_["type"], "");
    switch (type) {
      case "CHILD":
        return FooRecursiveUnionChild.fromJson(_input_);
      case "CHILDREN":
        return FooRecursiveUnionChildren.fromJson(_input_);
      case "TEXT":
        return FooRecursiveUnionText.fromJson(_input_);
      case "SHAPE":
        return FooRecursiveUnionShape.fromJson(_input_);
      default:
        return FooRecursiveUnion.empty();
    }
  }

  factory FooRecursiveUnion.fromJsonString(String input) {
    return FooRecursiveUnion.fromJson(json.decode(input));
  }
}

/// Child node
class FooRecursiveUnionChild implements FooRecursiveUnion {
  final FooRecursiveUnion data;
  const FooRecursiveUnionChild({
    required this.data,
  });

  @override
  String get type => "CHILD";

  factory FooRecursiveUnionChild.empty() {
    return FooRecursiveUnionChild(
      data: FooRecursiveUnion.empty(),
    );
  }

  factory FooRecursiveUnionChild.fromJson(Map<String, dynamic> _input_) {
    final data = _input_["data"] is Map<String, dynamic>
        ? FooRecursiveUnion.fromJson(_input_["data"])
        : FooRecursiveUnion.empty();
    return FooRecursiveUnionChild(
      data: data,
    );
  }

  factory FooRecursiveUnionChild.fromJsonString(String input) {
    return FooRecursiveUnionChild.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /RecursiveUnionChild/data.");
    return _queryParts_.join("&");
  }

  FooRecursiveUnionChild copyWith({
    FooRecursiveUnion? data,
  }) {
    return FooRecursiveUnionChild(
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooRecursiveUnionChild && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooRecursiveUnionChild ${toJsonString()}";
  }
}

/// List of children node
class FooRecursiveUnionChildren implements FooRecursiveUnion {
  final List<FooRecursiveUnion> data;
  const FooRecursiveUnionChildren({
    required this.data,
  });

  @override
  String get type => "CHILDREN";

  factory FooRecursiveUnionChildren.empty() {
    return FooRecursiveUnionChildren(
      data: [],
    );
  }

  factory FooRecursiveUnionChildren.fromJson(Map<String, dynamic> _input_) {
    final data = _input_["data"] is List
        ? (_input_["data"] as List)
            .map((_el_) => _el_ is Map<String, dynamic>
                ? FooRecursiveUnion.fromJson(_el_)
                : FooRecursiveUnion.empty())
            .toList()
        : <FooRecursiveUnion>[];
    return FooRecursiveUnionChildren(
      data: data,
    );
  }

  factory FooRecursiveUnionChildren.fromJsonString(String input) {
    return FooRecursiveUnionChildren.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "data": data.map((_el_) => _el_.toJson()).toList(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    print(
        "[WARNING] arrays cannot be serialized to query params. Skipping field at /RecursiveUnionChildren/data.");
    return _queryParts_.join("&");
  }

  FooRecursiveUnionChildren copyWith({
    List<FooRecursiveUnion>? data,
  }) {
    return FooRecursiveUnionChildren(
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooRecursiveUnionChildren &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooRecursiveUnionChildren ${toJsonString()}";
  }
}

/// Text node
class FooRecursiveUnionText implements FooRecursiveUnion {
  final String data;
  const FooRecursiveUnionText({
    required this.data,
  });

  @override
  String get type => "TEXT";

  factory FooRecursiveUnionText.empty() {
    return FooRecursiveUnionText(
      data: "",
    );
  }

  factory FooRecursiveUnionText.fromJson(Map<String, dynamic> _input_) {
    final data = typeFromDynamic<String>(_input_["data"], "");
    return FooRecursiveUnionText(
      data: data,
    );
  }

  factory FooRecursiveUnionText.fromJsonString(String input) {
    return FooRecursiveUnionText.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "data": data,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    _queryParts_.add("data=$data");
    return _queryParts_.join("&");
  }

  FooRecursiveUnionText copyWith({
    String? data,
  }) {
    return FooRecursiveUnionText(
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooRecursiveUnionText && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooRecursiveUnionText ${toJsonString()}";
  }
}

/// Shape node
class FooRecursiveUnionShape implements FooRecursiveUnion {
  final FooRecursiveUnionShapeData data;
  const FooRecursiveUnionShape({
    required this.data,
  });

  @override
  String get type => "SHAPE";

  factory FooRecursiveUnionShape.empty() {
    return FooRecursiveUnionShape(
      data: FooRecursiveUnionShapeData.empty(),
    );
  }

  factory FooRecursiveUnionShape.fromJson(Map<String, dynamic> _input_) {
    final data = _input_["data"] is Map<String, dynamic>
        ? FooRecursiveUnionShapeData.fromJson(_input_["data"])
        : FooRecursiveUnionShapeData.empty();
    return FooRecursiveUnionShape(
      data: data,
    );
  }

  factory FooRecursiveUnionShape.fromJsonString(String input) {
    return FooRecursiveUnionShape.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "type": type,
      "data": data.toJson(),
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("type=$type");
    print(
        "[WARNING] nested objects cannot be serialized to query params. Skipping field at /RecursiveUnionShape/data.");
    return _queryParts_.join("&");
  }

  FooRecursiveUnionShape copyWith({
    FooRecursiveUnionShapeData? data,
  }) {
    return FooRecursiveUnionShape(
      data: data ?? this.data,
    );
  }

  @override
  List<Object?> get props => [
        data,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooRecursiveUnionShape && listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooRecursiveUnionShape ${toJsonString()}";
  }
}

class FooRecursiveUnionShapeData implements ArriModel {
  final double width;
  final double height;
  final String color;
  const FooRecursiveUnionShapeData({
    required this.width,
    required this.height,
    required this.color,
  });

  factory FooRecursiveUnionShapeData.empty() {
    return FooRecursiveUnionShapeData(
      width: 0.0,
      height: 0.0,
      color: "",
    );
  }

  factory FooRecursiveUnionShapeData.fromJson(Map<String, dynamic> _input_) {
    final width = doubleFromDynamic(_input_["width"], 0.0);
    final height = doubleFromDynamic(_input_["height"], 0.0);
    final color = typeFromDynamic<String>(_input_["color"], "");
    return FooRecursiveUnionShapeData(
      width: width,
      height: height,
      color: color,
    );
  }

  factory FooRecursiveUnionShapeData.fromJsonString(String input) {
    return FooRecursiveUnionShapeData.fromJson(json.decode(input));
  }

  @override
  Map<String, dynamic> toJson() {
    final _output_ = <String, dynamic>{
      "width": width,
      "height": height,
      "color": color,
    };

    return _output_;
  }

  @override
  String toJsonString() {
    return json.encode(toJson());
  }

  @override
  String toUrlQueryParams() {
    final _queryParts_ = <String>[];
    _queryParts_.add("width=$width");
    _queryParts_.add("height=$height");
    _queryParts_.add("color=$color");
    return _queryParts_.join("&");
  }

  FooRecursiveUnionShapeData copyWith({
    double? width,
    double? height,
    String? color,
  }) {
    return FooRecursiveUnionShapeData(
      width: width ?? this.width,
      height: height ?? this.height,
      color: color ?? this.color,
    );
  }

  @override
  List<Object?> get props => [
        width,
        height,
        color,
      ];

  @override
  bool operator ==(Object other) {
    return other is FooRecursiveUnionShapeData &&
        listsAreEqual(props, other.props);
  }

  @override
  int get hashCode => listToHashCode(props);

  @override
  String toString() {
    return "FooRecursiveUnionShapeData ${toJsonString()}";
  }
}
